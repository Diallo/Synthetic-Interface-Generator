#include "V2_StateMachineController.h"
#ifdef CLIENT_STUB_API
#include "V2StubAdapterImpl.h"
#endif

namespace StateMachineController {

#ifdef SSCF_VERSION
V2_StateMachineController::V2_StateMachineController(
					class EventRepository *er,
					class UNDEFINED::V2Server *srv, int sim_mode) {
	m_eventRepo = er;
	m_serverPtr = srv;
	current = new p1_1();
	
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_niHandler = nullptr;




	// timer = new NotificationCallbackThread(this);
	timer = new NotificationCallbackThread(*this, sim_mode);
	timer->setSingleShot(false);
	timer->setInterval(NotificationCallbackThread::Interval(10*1000));
	timer->start(true);
	
	#ifdef CLIENT_STUB_API
	client_api_handler = new EventAPIHandlerImpl(*this);
	// isCBActive = false;
	
	// Register call backs to the state machine controller
	client_api_handler->getNIHandler().register_outTRp1_1_3398718_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398718_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398719_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398719_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398720_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398720_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_1_3398724_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_1_3398724_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_4_3398725_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_4_3398725_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_3_3398727_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_3_3398727_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_4_3398731_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_4_3398731_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_5_3398733_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_5_3398733_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_2_3398735_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_2_3398735_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_3_3398736_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_3_3398736_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398738_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398738_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_3_3398740_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_3_3398740_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_1_3398744_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_1_3398744_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_1_3398745_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_1_3398745_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_10_3398748_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_10_3398748_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_6_3398756_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_6_3398756_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_4_3398759_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_4_3398759_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_6_3398761_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_6_3398761_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_6_3398762_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_6_3398762_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_4_3398763_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_4_3398763_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_11_3398764_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_11_3398764_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_8_3398766_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_8_3398766_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_10_3398769_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_10_3398769_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_12_3398771_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_12_3398771_clHandler);
	client_api_handler->getNIHandler().register_outTRp6_1_3398773_CBHandler(&StateMachineController::V2_StateMachineController::outTRp6_1_3398773_clHandler);
	client_api_handler->getNIHandler().register_outTRp7_1_3398775_CBHandler(&StateMachineController::V2_StateMachineController::outTRp7_1_3398775_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_2_3398777_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_2_3398777_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_6_3398778_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_6_3398778_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_14_3398782_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_14_3398782_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_3_3398784_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_3_3398784_clHandler);
	client_api_handler->getNIHandler().register_outTRp8_1_3398788_CBHandler(&StateMachineController::V2_StateMachineController::outTRp8_1_3398788_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_1_3398789_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_1_3398789_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_17_3398791_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_17_3398791_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_7_3398793_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_7_3398793_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_7_3398794_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_7_3398794_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_4_3398797_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_4_3398797_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_29_3398799_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_29_3398799_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_2_3398801_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_2_3398801_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_13_3398802_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_13_3398802_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_7_3398804_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_7_3398804_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_32_3398806_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_32_3398806_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_20_3398809_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_20_3398809_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_3_3398810_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_3_3398810_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398811_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398811_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_9_3398815_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_9_3398815_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_4_3398816_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_4_3398816_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_4_3398817_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_4_3398817_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_25_3398820_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_25_3398820_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_10_3398821_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_10_3398821_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_26_3398822_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_26_3398822_clHandler);
	client_api_handler->getNIHandler().register_outTRp11_1_3398824_CBHandler(&StateMachineController::V2_StateMachineController::outTRp11_1_3398824_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_1_3398829_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_1_3398829_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_2_3398830_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_2_3398830_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_5_3398831_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_5_3398831_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_21_3398832_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_21_3398832_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_29_3398835_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_29_3398835_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_21_3398836_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_21_3398836_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_20_3398837_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_20_3398837_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_2_3398839_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_2_3398839_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_8_3398840_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_8_3398840_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_5_3398844_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_5_3398844_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_12_3398846_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_12_3398846_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_9_3398848_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_9_3398848_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_7_3398851_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_7_3398851_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_13_3398852_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_13_3398852_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_40_3398853_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_40_3398853_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_40_3398855_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_40_3398855_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_6_3398857_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_6_3398857_clHandler);
	client_api_handler->getNIHandler().register_outTRp17_1_3398863_CBHandler(&StateMachineController::V2_StateMachineController::outTRp17_1_3398863_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_3_3398866_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_3_3398866_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_10_3398867_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_10_3398867_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_3_3398869_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_3_3398869_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_1_3398870_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_1_3398870_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_2_3398873_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_2_3398873_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_1_3398874_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_1_3398874_clHandler);
	client_api_handler->getNIHandler().register_outTRp19_1_3398877_CBHandler(&StateMachineController::V2_StateMachineController::outTRp19_1_3398877_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_10_3398879_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_10_3398879_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_52_3398880_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_52_3398880_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_52_3398881_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_52_3398881_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_41_3398883_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_41_3398883_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_36_3398884_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_36_3398884_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_34_3398885_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_34_3398885_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_31_3398886_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_31_3398886_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_29_3398887_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_29_3398887_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_18_3398888_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_18_3398888_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_60_3398889_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_60_3398889_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_62_3398890_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_62_3398890_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_60_3398891_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_60_3398891_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_62_3398892_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_62_3398892_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_62_3398893_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_62_3398893_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_61_3398894_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_61_3398894_clHandler);
	#endif
	
	run_simulation = true;
	// std::cout<<std::endl<<"INFO: State Machine Controller has been Constructed!"<<std::endl;
	// std::cout<<"INFO: Notification Callback Thread is Running..."<<std::endl;
}
#endif
#ifndef SSCF_VERSION
#ifdef SSCF_CLIENT_STUB_ADAPTER
V2_StateMachineController::V2_StateMachineController(class EventRepository *er, int sim_mode, 
	SscfClientConnection<UNDEFINED::V2Proxy, UNDEFINED::V2>& m_connection) {
#endif
#ifndef SSCF_CLIENT_STUB_ADAPTER
V2_StateMachineController::V2_StateMachineController(class EventRepository *er, int sim_mode) {
#endif
	m_eventRepo = er;
	current = new p1_1();
	
	publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_niHandler = nullptr;


	// timer = new NotificationCallbackThread(this, sim_mode);
	timer = new NotificationCallbackThread(*this, sim_mode);
	timer->setSingleShot(false);
	timer->setInterval(NotificationCallbackThread::Interval(10*1000));
	timer->start(true);

	#ifdef CLIENT_STUB_API
	
	#ifndef SSCF_CLIENT_STUB_ADAPTER
	client_api_handler = new EventAPIHandlerImpl(*this);
	// isCBActive = false;
	#endif
	
	#ifdef SSCF_CLIENT_STUB_ADAPTER
	client_api_handler = new EventAPIHandlerImpl(*this, m_connection);
	// isCBActive = false;
	#endif
	
	// Register call backs to the state machine controller
	client_api_handler->getNIHandler().register_outTRp1_1_3398718_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398718_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398719_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398719_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398720_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398720_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_1_3398724_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_1_3398724_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_4_3398725_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_4_3398725_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_3_3398727_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_3_3398727_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_4_3398731_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_4_3398731_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_5_3398733_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_5_3398733_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_2_3398735_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_2_3398735_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_3_3398736_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_3_3398736_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398738_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398738_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_3_3398740_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_3_3398740_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_1_3398744_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_1_3398744_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_1_3398745_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_1_3398745_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_10_3398748_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_10_3398748_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_6_3398756_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_6_3398756_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_4_3398759_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_4_3398759_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_6_3398761_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_6_3398761_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_6_3398762_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_6_3398762_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_4_3398763_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_4_3398763_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_11_3398764_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_11_3398764_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_8_3398766_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_8_3398766_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_10_3398769_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_10_3398769_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_12_3398771_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_12_3398771_clHandler);
	client_api_handler->getNIHandler().register_outTRp6_1_3398773_CBHandler(&StateMachineController::V2_StateMachineController::outTRp6_1_3398773_clHandler);
	client_api_handler->getNIHandler().register_outTRp7_1_3398775_CBHandler(&StateMachineController::V2_StateMachineController::outTRp7_1_3398775_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_2_3398777_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_2_3398777_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_6_3398778_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_6_3398778_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_14_3398782_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_14_3398782_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_3_3398784_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_3_3398784_clHandler);
	client_api_handler->getNIHandler().register_outTRp8_1_3398788_CBHandler(&StateMachineController::V2_StateMachineController::outTRp8_1_3398788_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_1_3398789_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_1_3398789_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_17_3398791_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_17_3398791_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_7_3398793_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_7_3398793_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_7_3398794_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_7_3398794_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_4_3398797_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_4_3398797_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_29_3398799_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_29_3398799_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_2_3398801_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_2_3398801_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_13_3398802_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_13_3398802_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_7_3398804_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_7_3398804_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_32_3398806_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_32_3398806_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_20_3398809_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_20_3398809_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_3_3398810_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_3_3398810_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398811_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398811_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_9_3398815_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_9_3398815_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_4_3398816_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_4_3398816_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_4_3398817_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_4_3398817_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_25_3398820_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_25_3398820_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_10_3398821_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_10_3398821_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_26_3398822_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_26_3398822_clHandler);
	client_api_handler->getNIHandler().register_outTRp11_1_3398824_CBHandler(&StateMachineController::V2_StateMachineController::outTRp11_1_3398824_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_1_3398829_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_1_3398829_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_2_3398830_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_2_3398830_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_5_3398831_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_5_3398831_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_21_3398832_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_21_3398832_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_29_3398835_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_29_3398835_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_21_3398836_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_21_3398836_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_20_3398837_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_20_3398837_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_2_3398839_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_2_3398839_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_8_3398840_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_8_3398840_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_5_3398844_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_5_3398844_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_12_3398846_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_12_3398846_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_9_3398848_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_9_3398848_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_7_3398851_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_7_3398851_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_13_3398852_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_13_3398852_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_40_3398853_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_40_3398853_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_40_3398855_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_40_3398855_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_6_3398857_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_6_3398857_clHandler);
	client_api_handler->getNIHandler().register_outTRp17_1_3398863_CBHandler(&StateMachineController::V2_StateMachineController::outTRp17_1_3398863_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_3_3398866_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_3_3398866_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_10_3398867_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_10_3398867_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_3_3398869_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_3_3398869_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_1_3398870_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_1_3398870_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_2_3398873_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_2_3398873_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_1_3398874_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_1_3398874_clHandler);
	client_api_handler->getNIHandler().register_outTRp19_1_3398877_CBHandler(&StateMachineController::V2_StateMachineController::outTRp19_1_3398877_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_10_3398879_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_10_3398879_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_52_3398880_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_52_3398880_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_52_3398881_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_52_3398881_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_41_3398883_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_41_3398883_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_36_3398884_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_36_3398884_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_34_3398885_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_34_3398885_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_31_3398886_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_31_3398886_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_29_3398887_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_29_3398887_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_18_3398888_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_18_3398888_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_60_3398889_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_60_3398889_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_62_3398890_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_62_3398890_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_60_3398891_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_60_3398891_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_62_3398892_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_62_3398892_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_62_3398893_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_62_3398893_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_61_3398894_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_61_3398894_clHandler);
	#endif

	run_simulation = true;
	// std::cout<<std::endl<<"INFO: State Machine Controller has been Constructed!"<<std::endl;
	// std::cout<<"INFO: Notification Callback Thread has been Constructed!"<<std::endl;
}
#endif
#ifdef QT_GUI
V2_StateMachineController::V2_StateMachineController(class EventRepository *er, class MainWindow *mw, int sim_mode) {
	m_eventRepo = er;
	m_mw = mw; 
	current = new p1_1();
	
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_niHandler = nullptr;

			
	//timer = new NotificationCallbackThread(this, sim_mode);
	timer = new NotificationCallbackThread(*this, sim_mode);
	timer->setSingleShot(false);
	timer->setInterval(NotificationCallbackThread::Interval(10*1000));
	timer->start(true);

	#ifdef CLIENT_STUB_API
	client_api_handler = new EventAPIHandlerImpl(*this);
	// isCBActive = false;
	
	// Register call backs to the state machine controller
	client_api_handler->getNIHandler().register_outTRp1_1_3398718_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398718_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398719_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398719_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398720_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398720_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_1_3398724_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_1_3398724_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_4_3398725_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_4_3398725_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_3_3398727_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_3_3398727_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_4_3398731_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_4_3398731_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_5_3398733_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_5_3398733_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_2_3398735_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_2_3398735_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_3_3398736_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_3_3398736_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398738_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398738_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_3_3398740_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_3_3398740_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_1_3398744_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_1_3398744_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_1_3398745_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_1_3398745_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_10_3398748_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_10_3398748_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_6_3398756_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_6_3398756_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_4_3398759_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_4_3398759_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_6_3398761_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_6_3398761_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_6_3398762_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_6_3398762_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_4_3398763_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_4_3398763_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_11_3398764_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_11_3398764_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_8_3398766_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_8_3398766_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_10_3398769_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_10_3398769_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_12_3398771_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_12_3398771_clHandler);
	client_api_handler->getNIHandler().register_outTRp6_1_3398773_CBHandler(&StateMachineController::V2_StateMachineController::outTRp6_1_3398773_clHandler);
	client_api_handler->getNIHandler().register_outTRp7_1_3398775_CBHandler(&StateMachineController::V2_StateMachineController::outTRp7_1_3398775_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_2_3398777_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_2_3398777_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_6_3398778_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_6_3398778_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_14_3398782_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_14_3398782_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_3_3398784_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_3_3398784_clHandler);
	client_api_handler->getNIHandler().register_outTRp8_1_3398788_CBHandler(&StateMachineController::V2_StateMachineController::outTRp8_1_3398788_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_1_3398789_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_1_3398789_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_17_3398791_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_17_3398791_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_7_3398793_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_7_3398793_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_7_3398794_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_7_3398794_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_4_3398797_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_4_3398797_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_29_3398799_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_29_3398799_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_2_3398801_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_2_3398801_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_13_3398802_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_13_3398802_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_7_3398804_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_7_3398804_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_32_3398806_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_32_3398806_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_20_3398809_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_20_3398809_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_3_3398810_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_3_3398810_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_1_3398811_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_1_3398811_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_9_3398815_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_9_3398815_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_4_3398816_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_4_3398816_clHandler);
	client_api_handler->getNIHandler().register_outTRp5_4_3398817_CBHandler(&StateMachineController::V2_StateMachineController::outTRp5_4_3398817_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_25_3398820_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_25_3398820_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_10_3398821_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_10_3398821_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_26_3398822_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_26_3398822_clHandler);
	client_api_handler->getNIHandler().register_outTRp11_1_3398824_CBHandler(&StateMachineController::V2_StateMachineController::outTRp11_1_3398824_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_1_3398829_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_1_3398829_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_2_3398830_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_2_3398830_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_5_3398831_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_5_3398831_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_21_3398832_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_21_3398832_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_29_3398835_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_29_3398835_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_21_3398836_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_21_3398836_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_20_3398837_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_20_3398837_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_2_3398839_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_2_3398839_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_8_3398840_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_8_3398840_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_5_3398844_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_5_3398844_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_12_3398846_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_12_3398846_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_9_3398848_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_9_3398848_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_7_3398851_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_7_3398851_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_13_3398852_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_13_3398852_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_40_3398853_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_40_3398853_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_40_3398855_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_40_3398855_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_6_3398857_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_6_3398857_clHandler);
	client_api_handler->getNIHandler().register_outTRp17_1_3398863_CBHandler(&StateMachineController::V2_StateMachineController::outTRp17_1_3398863_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_3_3398866_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_3_3398866_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_10_3398867_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_10_3398867_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_3_3398869_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_3_3398869_clHandler);
	client_api_handler->getNIHandler().register_outTRp9_1_3398870_CBHandler(&StateMachineController::V2_StateMachineController::outTRp9_1_3398870_clHandler);
	client_api_handler->getNIHandler().register_outTRp4_2_3398873_CBHandler(&StateMachineController::V2_StateMachineController::outTRp4_2_3398873_clHandler);
	client_api_handler->getNIHandler().register_outTRp2_1_3398874_CBHandler(&StateMachineController::V2_StateMachineController::outTRp2_1_3398874_clHandler);
	client_api_handler->getNIHandler().register_outTRp19_1_3398877_CBHandler(&StateMachineController::V2_StateMachineController::outTRp19_1_3398877_clHandler);
	client_api_handler->getNIHandler().register_outTRp1_10_3398879_CBHandler(&StateMachineController::V2_StateMachineController::outTRp1_10_3398879_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_52_3398880_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_52_3398880_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_52_3398881_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_52_3398881_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_41_3398883_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_41_3398883_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_36_3398884_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_36_3398884_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_34_3398885_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_34_3398885_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_31_3398886_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_31_3398886_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_29_3398887_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_29_3398887_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_18_3398888_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_18_3398888_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_60_3398889_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_60_3398889_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_62_3398890_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_62_3398890_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_60_3398891_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_60_3398891_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_62_3398892_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_62_3398892_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_62_3398893_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_62_3398893_clHandler);
	client_api_handler->getNIHandler().register_outTRp3_61_3398894_CBHandler(&StateMachineController::V2_StateMachineController::outTRp3_61_3398894_clHandler);
	#endif

	run_simulation = true;
	// std::cout<<std::endl<<"INFO: State Machine Controller has been Constructed!"<<std::endl;
	// std::cout<<"INFO: Notification Callback Thread has been Constructed!"<<std::endl;
}		
#endif
V2_StateMachineController::~V2_StateMachineController() 
{
	// TODO delete all state machine variables! Memory Leak
	timer->stop();
	if(timer != nullptr)
	{
		std::cout<< std::endl <<"Destroying Callback Thread Instance! "<<std::endl;
		delete timer;
		timer = nullptr;
	}
	delete current;
	std::cout<< std::endl <<"Destroyed State Machine Controller! "<<std::endl;
}

void V2_StateMachineController::setSimMode(int sim_mode) 
{ 
	timer->setSimMode(sim_mode);
	publishToEventRepo(m_eventRepo);
}

void V2_StateMachineController::toggleSimulation(bool print_vars)
{
	if(run_simulation) { 
		run_simulation = false;
		std::cout<<std::endl<<"Stopping Simulation..."<<std::endl;
		if(print_vars) displaySMVars();
	}
	else {
		run_simulation = true;
		std::cout<<std::endl<<"Starting Simulation..."<<std::endl;
		#ifndef QT_GUI
		publishToEventRepo(m_eventRepo);
		//event_status_msg.clear();
		#endif
	}
}

void V2_StateMachineController::setTextColor(string col)
{
}

string V2_StateMachineController::getCurrentState()
{
	return current->getCurrentState();
}

list<string> V2_StateMachineController::getCurrentCommandStatusList()
{
	return current->getCurrentCommandStatusList();
}

list<string> V2_StateMachineController::getCurrentSignalStatusList()
{
	return current->getCurrentSignalStatusList();
}

list<string> V2_StateMachineController::getCurrentNotificationStatusList()
{
	return current->getCurrentNotificationStatusList();
}

void V2_StateMachineController::publishToEventRepo(EventRepository *er)
{
	if(er!=nullptr)
	{
		er->setEventsMap(	getCurrentCommandStatusList(),
							getCurrentSignalStatusList(),
							getCurrentNotificationStatusList(),
							event_status_msg
							);
	}
	#ifdef QT_GUI
	if(m_mw!=nullptr)
	{
		m_mw->setEventsMap(	getCurrentState(),
							c.getLoggedGUIMsgs(),
							getCurrentCommandStatusList(),
							getCurrentSignalStatusList(),
							getCurrentNotificationStatusList(),
							event_status_msg
							);
		
	}
	#endif
}

void V2_StateMachineController::executeAvailableCommandsAndSignalsInState()
{
	if(run_simulation)
	{
		// std::cout<<"INFO@Thread_Callback_Method: Checking Lock Available..."<<std::endl;
		std::unique_lock<std::mutex> mlock(m_mutex);
		if (!isIdle())
		{
			m_condVar.wait(mlock, std::bind(&V2_StateMachineController::isIdle, this));
		}
		// std::cout<<"INFO@Thread_Callback_Method: Acquired Lock!"<<std::endl;
		
		#ifdef CLIENT_STUB_API
		// isCBActive = true;
		// Added: DB
		// m_idle = false;
		// m_condVar.notify_all();

		if(isNotificationExpected)
		{
			std::cout << "FATAL: The Controller has Detected a Race Condition!" << std::endl;
			//throw (StubException("EXCEPTION: RACE CONDITION DETECTED!", RACE_CONDITION));
		}
		if(isNotificationInProcess)
		{
			std::cout << "BUSY: Notification is being Processed, Skipping Event Call!" << std::endl;
			return;
		}
		#endif
		
		if(current->checkEnabledCommandAndSignalInState(this))
		{
			// std::cout << std::endl << "INFO@Thread_Callback_Method: Possible Commands/Signals in State!" << std::endl;
			event_status_msg.clear();
			try {
				current->executeAvailableCommandsAndSignalsInState(this);
			} catch (const StateMachineController::StubException& e) {
				// so that future notifications can be processed.
				std::cout<< "Clearing All Pending Notifications..." << std::endl;
				#ifdef CLIENT_STUB_API
				client_api_handler->closeEventContext();
				#endif
				std::cout << e.what() << std::endl;
			}
			publishToEventRepo(m_eventRepo);
		}
		// else std::cout<<"INFO: No possible notifications in State!"<<std::endl;
		
		#ifdef CLIENT_STUB_API
		// Added: DB
		// m_idle = true;
		// m_condVar.notify_all();
		// isCBActive = false;
		#endif
	}
}

void V2_StateMachineController::executeInternalTransitions()
{
	if(run_simulation) 
	{
		// std::cout<<"INFO@Thread_Callback_Method: Checking Lock Available..."<<std::endl;
		std::unique_lock<std::mutex> mlock(m_mutex);
		if(!isIdle())
		{
			m_condVar.wait(mlock, std::bind(&V2_StateMachineController::isIdle, this));
		}
		// std::cout<<"INFO@Thread_Callback_Method: Acquired Lock!"<<std::endl;
		
		if(current->isNotificationPossibleInState(this))
		{
			// std::cout<<std::endl<<"INFO@Thread_Callback_Method: Possible notifications in State!"<<std::endl;
			event_status_msg.clear();
			current->executeInternalTransitions(this);
			// This prevents UI output when an excluded notification was found!
			if(!event_status_msg.empty()) publishToEventRepo(m_eventRepo);
		}
		// else std::cout<<"INFO: No possible notifications in State!"<<std::endl;
	}
}

bool V2_StateMachineController::isIdle()
{
	return m_idle;
}

void V2_StateMachineController::displaySMVars()
{
	setTextColor("EVENT");
	std::cout<<"---------------------------------------------"<<std::endl;
	std::cout<<"CURRENT STATE: "<<getCurrentState()<<std::endl;
	std::cout<<"---------------------------------------------"<<std::endl;


	setTextColor("DATA");
	std::cout<<"---------------------------------------------"<<std::endl;
	std::cout<<"No State Variables to Display..."<<std::endl;
	std::cout<<"---------------------------------------------"<<std::endl;
    #ifdef QT_GUI
    event_status_msg.clear();
    c.clearLoggedMsgs();
    #endif
	setTextColor("ANY");
	#ifdef QT_GUI
	publishToEventRepo(m_eventRepo);
	event_status_msg.clear();
	#endif
}

// Command Definition

// Signal Definition
void V2_StateMachineController::_V2_inTRp2_1_3398721()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_1_3398721(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_1_3398721(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_1_3398721(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_1_3398721(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_1_3398721(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_1_3398722()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_1_3398722(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_1_3398722(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_1_3398722(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_1_3398722(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_1_3398722(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_1_3398723()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_1_3398723(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_1_3398723(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_1_3398723(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_1_3398723(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_1_3398723(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_2_3398726()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_2_3398726(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_2_3398726(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_2_3398726(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_2_3398726(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_2_3398726(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_1_3398728()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_1_3398728(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_1_3398728(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_1_3398728(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_1_3398728(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_1_3398728(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_4_3398729()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_4_3398729(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_4_3398729(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_4_3398729(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_4_3398729(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_4_3398729(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_1_3398732()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_1_3398732(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_1_3398732(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_1_3398732(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_1_3398732(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_1_3398732(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_5_3398734()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_5_3398734(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_5_3398734(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_5_3398734(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_5_3398734(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_5_3398734(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_4_3398737()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_4_3398737(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_4_3398737(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_4_3398737(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_4_3398737(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_4_3398737(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_2_3398739()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_2_3398739(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_2_3398739(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_2_3398739(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_2_3398739(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_2_3398739(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_10_3398741()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_10_3398741(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_10_3398741(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_10_3398741(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_10_3398741(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_10_3398741(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_2_3398742()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_2_3398742(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_2_3398742(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_2_3398742(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_2_3398742(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_2_3398742(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_2_3398743()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_2_3398743(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_2_3398743(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_2_3398743(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_2_3398743(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_2_3398743(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_4_3398746()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_4_3398746(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_4_3398746(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_4_3398746(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_4_3398746(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_4_3398746(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_9_3398747()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_9_3398747(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_9_3398747(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_9_3398747(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_9_3398747(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_9_3398747(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_5_3398749()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_5_3398749(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_5_3398749(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_5_3398749(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_5_3398749(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_5_3398749(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_4_3398750()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_4_3398750(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_4_3398750(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_4_3398750(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_4_3398750(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_4_3398750(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_9_3398751()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_9_3398751(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_9_3398751(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_9_3398751(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_9_3398751(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_9_3398751(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_8_3398752()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_8_3398752(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_8_3398752(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_8_3398752(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_8_3398752(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_8_3398752(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_1_3398753()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_1_3398753(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_1_3398753(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_1_3398753(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_1_3398753(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_1_3398753(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_3_3398754()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_3_3398754(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_3_3398754(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_3_3398754(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_3_3398754(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_3_3398754(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_5_3398755()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_5_3398755(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_5_3398755(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_5_3398755(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_5_3398755(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_5_3398755(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_1_3398757()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_1_3398757(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_1_3398757(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_1_3398757(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_1_3398757(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_1_3398757(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_3_3398758()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_3_3398758(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_3_3398758(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_3_3398758(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_3_3398758(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_3_3398758(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_5_3398760()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_5_3398760(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_5_3398760(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_5_3398760(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_5_3398760(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_5_3398760(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_12_3398765()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_12_3398765(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_12_3398765(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_12_3398765(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_12_3398765(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_12_3398765(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_8_3398767()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_8_3398767(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_8_3398767(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_8_3398767(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_8_3398767(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_8_3398767(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_9_3398768()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_9_3398768(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_9_3398768(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_9_3398768(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_9_3398768(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_9_3398768(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_11_3398770()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_11_3398770(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_11_3398770(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_11_3398770(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_11_3398770(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_11_3398770(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_4_3398772()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_4_3398772(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_4_3398772(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_4_3398772(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_4_3398772(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_4_3398772(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_26_3398774()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_26_3398774(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_26_3398774(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_26_3398774(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_26_3398774(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_26_3398774(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp5_1_3398776()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp5_1_3398776(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp5_1_3398776(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp5_1_3398776(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp5_1_3398776(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp5_1_3398776(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_8_3398780()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_8_3398780(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_8_3398780(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_8_3398780(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_8_3398780(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_8_3398780(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_3_3398781()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_3_3398781(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_3_3398781(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_3_3398781(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_3_3398781(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_3_3398781(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_2_3398783()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_2_3398783(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_2_3398783(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_2_3398783(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_2_3398783(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_2_3398783(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_14_3398785()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_14_3398785(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_14_3398785(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_14_3398785(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_14_3398785(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_14_3398785(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_12_3398786()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_12_3398786(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_12_3398786(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_12_3398786(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_12_3398786(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_12_3398786(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_12_3398787()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_12_3398787(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_12_3398787(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_12_3398787(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_12_3398787(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_12_3398787(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_16_3398790()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_16_3398790(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_16_3398790(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_16_3398790(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_16_3398790(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_16_3398790(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_13_3398792()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_13_3398792(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_13_3398792(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_13_3398792(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_13_3398792(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_13_3398792(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp10_1_3398795()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp10_1_3398795(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp10_1_3398795(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp10_1_3398795(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp10_1_3398795(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp10_1_3398795(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp11_1_3398796()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp11_1_3398796(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp11_1_3398796(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp11_1_3398796(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp11_1_3398796(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp11_1_3398796(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_18_3398798()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_18_3398798(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_18_3398798(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_18_3398798(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_18_3398798(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_18_3398798(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp9_1_3398800()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp9_1_3398800(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp9_1_3398800(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp9_1_3398800(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp9_1_3398800(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp9_1_3398800(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_14_3398803()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_14_3398803(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_14_3398803(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_14_3398803(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_14_3398803(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_14_3398803(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp10_1_3398805()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp10_1_3398805(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp10_1_3398805(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp10_1_3398805(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp10_1_3398805(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp10_1_3398805(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp5_3_3398807()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp5_3_3398807(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp5_3_3398807(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp5_3_3398807(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp5_3_3398807(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp5_3_3398807(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_9_3398808()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_9_3398808(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_9_3398808(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_9_3398808(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_9_3398808(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_9_3398808(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_2_3398812()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_2_3398812(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_2_3398812(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_2_3398812(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_2_3398812(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_2_3398812(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_10_3398813()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_10_3398813(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_10_3398813(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_10_3398813(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_10_3398813(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_10_3398813(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_17_3398814()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_17_3398814(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_17_3398814(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_17_3398814(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_17_3398814(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_17_3398814(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp12_1_3398818()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp12_1_3398818(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp12_1_3398818(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp12_1_3398818(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp12_1_3398818(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp12_1_3398818(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp13_1_3398819()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp13_1_3398819(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp13_1_3398819(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp13_1_3398819(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp13_1_3398819(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp13_1_3398819(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_27_3398823()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_27_3398823(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_27_3398823(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_27_3398823(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_27_3398823(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_27_3398823(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_5_3398825()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_5_3398825(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_5_3398825(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_5_3398825(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_5_3398825(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_5_3398825(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_5_3398826()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_5_3398826(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_5_3398826(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_5_3398826(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_5_3398826(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_5_3398826(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_15_3398827()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_15_3398827(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_15_3398827(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_15_3398827(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_15_3398827(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_15_3398827(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_31_3398828()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_31_3398828(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_31_3398828(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_31_3398828(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_31_3398828(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_31_3398828(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_14_3398833()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_14_3398833(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_14_3398833(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_14_3398833(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_14_3398833(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_14_3398833(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_32_3398834()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_32_3398834(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_32_3398834(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_32_3398834(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_32_3398834(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_32_3398834(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp4_1_3398838()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp4_1_3398838(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp4_1_3398838(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp4_1_3398838(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp4_1_3398838(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp4_1_3398838(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp14_1_3398841()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp14_1_3398841(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp14_1_3398841(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp14_1_3398841(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp14_1_3398841(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp14_1_3398841(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_3_3398842()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_3_3398842(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_3_3398842(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_3_3398842(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_3_3398842(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_3_3398842(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_8_3398847()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_8_3398847(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_8_3398847(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_8_3398847(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_8_3398847(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_8_3398847(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_10_3398849()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_10_3398849(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_10_3398849(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_10_3398849(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_10_3398849(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_10_3398849(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_6_3398850()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_6_3398850(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_6_3398850(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_6_3398850(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_6_3398850(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_6_3398850(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp15_1_3398854()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp15_1_3398854(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp15_1_3398854(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp15_1_3398854(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp15_1_3398854(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp15_1_3398854(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp16_1_3398856()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp16_1_3398856(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp16_1_3398856(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp16_1_3398856(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp16_1_3398856(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp16_1_3398856(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp17_1_3398858()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp17_1_3398858(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp17_1_3398858(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp17_1_3398858(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp17_1_3398858(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp17_1_3398858(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_15_3398859()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_15_3398859(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_15_3398859(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_15_3398859(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_15_3398859(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_15_3398859(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_34_3398860()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_34_3398860(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_34_3398860(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_34_3398860(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_34_3398860(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_34_3398860(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_24_3398861()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_24_3398861(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_24_3398861(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_24_3398861(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_24_3398861(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_24_3398861(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp1_7_3398862()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_7_3398862(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp1_7_3398862(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp1_7_3398862(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp1_7_3398862(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp1_7_3398862(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp17_2_3398864()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp17_2_3398864(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp17_2_3398864(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp17_2_3398864(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp17_2_3398864(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp17_2_3398864(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_27_3398865()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_27_3398865(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_27_3398865(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_27_3398865(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_27_3398865(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_27_3398865(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp4_2_3398868()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp4_2_3398868(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp4_2_3398868(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp4_2_3398868(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp4_2_3398868(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp4_2_3398868(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp18_1_3398871()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp18_1_3398871(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp18_1_3398871(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp18_1_3398871(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp18_1_3398871(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp18_1_3398871(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_22_3398872()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_22_3398872(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_22_3398872(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_22_3398872(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_22_3398872(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_22_3398872(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp2_2_3398875()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_2_3398875(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp2_2_3398875(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp2_2_3398875(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp2_2_3398875(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp2_2_3398875(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp4_1_3398876()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp4_1_3398876(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp4_1_3398876(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp4_1_3398876(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp4_1_3398876(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp4_1_3398876(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
void V2_StateMachineController::_V2_inTRp3_28_3398878()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_28_3398878(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_inTRp3_28_3398878(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_inTRp3_28_3398878(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

bool V2_StateMachineController::isEnabledV2_inTRp3_28_3398878(int instance_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();

	event_status_msg.clear();

	bool is_instance_enabled = current->isEnabledV2_inTRp3_28_3398878(this, instance_id);

	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);

	m_idle = true;
	m_condVar.notify_one();

	return is_instance_enabled;
	}
// Notifications: This should only be used by Server GUI
// Extension Feature for Client State Machine
void V2_StateMachineController::_V2_outTRp1_1_3398718()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_1_3398718(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_1_3398719()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_1_3398719(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_1_3398720()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_1_3398720(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_1_3398724()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_1_3398724(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_4_3398725()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_4_3398725(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_3_3398727()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_3_3398727(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_4_3398731()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_4_3398731(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_5_3398733()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_5_3398733(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_2_3398735()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_2_3398735(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_3_3398736()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_3_3398736(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_1_3398738()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_1_3398738(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_3_3398740()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_3_3398740(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp4_1_3398744()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp4_1_3398744(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp5_1_3398745()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp5_1_3398745(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_10_3398748()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_10_3398748(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_6_3398756()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_6_3398756(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_4_3398759()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_4_3398759(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_6_3398761()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_6_3398761(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_6_3398762()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_6_3398762(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_4_3398763()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_4_3398763(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_11_3398764()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_11_3398764(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_8_3398766()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_8_3398766(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_10_3398769()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_10_3398769(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_12_3398771()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_12_3398771(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp6_1_3398773()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp6_1_3398773(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp7_1_3398775()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp7_1_3398775(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp5_2_3398777()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp5_2_3398777(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_6_3398778()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_6_3398778(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_14_3398782()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_14_3398782(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_3_3398784()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_3_3398784(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp8_1_3398788()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp8_1_3398788(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_1_3398789()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_1_3398789(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_17_3398791()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_17_3398791(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_7_3398793()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_7_3398793(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_7_3398794()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_7_3398794(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_4_3398797()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_4_3398797(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_29_3398799()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_29_3398799(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_2_3398801()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_2_3398801(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_13_3398802()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_13_3398802(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_7_3398804()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_7_3398804(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_32_3398806()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_32_3398806(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_20_3398809()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_20_3398809(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_3_3398810()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_3_3398810(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_1_3398811()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_1_3398811(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_9_3398815()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_9_3398815(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp5_4_3398816()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp5_4_3398816(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp5_4_3398817()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp5_4_3398817(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_25_3398820()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_25_3398820(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_10_3398821()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_10_3398821(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_26_3398822()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_26_3398822(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp11_1_3398824()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp11_1_3398824(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_1_3398829()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_1_3398829(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_2_3398830()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_2_3398830(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_5_3398831()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_5_3398831(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_21_3398832()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_21_3398832(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_29_3398835()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_29_3398835(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_21_3398836()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_21_3398836(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_20_3398837()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_20_3398837(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp4_2_3398839()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp4_2_3398839(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_8_3398840()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_8_3398840(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_5_3398844()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_5_3398844(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_12_3398846()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_12_3398846(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_9_3398848()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_9_3398848(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_7_3398851()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_7_3398851(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_13_3398852()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_13_3398852(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_40_3398853()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_40_3398853(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_40_3398855()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_40_3398855(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_6_3398857()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_6_3398857(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp17_1_3398863()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp17_1_3398863(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_3_3398866()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_3_3398866(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_10_3398867()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_10_3398867(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp4_3_3398869()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp4_3_3398869(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_1_3398870()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_1_3398870(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp4_2_3398873()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp4_2_3398873(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_1_3398874()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_1_3398874(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp19_1_3398877()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp19_1_3398877(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_10_3398879()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_10_3398879(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_52_3398880()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_52_3398880(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_52_3398881()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_52_3398881(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_41_3398883()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_41_3398883(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_36_3398884()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_36_3398884(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_34_3398885()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_34_3398885(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_31_3398886()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_31_3398886(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_29_3398887()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_29_3398887(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_18_3398888()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_18_3398888(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_60_3398889()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_60_3398889(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_62_3398890()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_62_3398890(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_60_3398891()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_60_3398891(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_62_3398892()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_62_3398892(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_62_3398893()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_62_3398893(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_61_3398894()
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_61_3398894(this);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

void V2_StateMachineController::_V2_outTRp1_1_3398718(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_1_3398718(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_1_3398719(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_1_3398719(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_1_3398720(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_1_3398720(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_1_3398724(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_1_3398724(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_4_3398725(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_4_3398725(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_3_3398727(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_3_3398727(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_4_3398731(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_4_3398731(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_5_3398733(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_5_3398733(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_2_3398735(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_2_3398735(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_3_3398736(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_3_3398736(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_1_3398738(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_1_3398738(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_3_3398740(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_3_3398740(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp4_1_3398744(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp4_1_3398744(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp5_1_3398745(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp5_1_3398745(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_10_3398748(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_10_3398748(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_6_3398756(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_6_3398756(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_4_3398759(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_4_3398759(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_6_3398761(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_6_3398761(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_6_3398762(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_6_3398762(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_4_3398763(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_4_3398763(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_11_3398764(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_11_3398764(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_8_3398766(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_8_3398766(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_10_3398769(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_10_3398769(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_12_3398771(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_12_3398771(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp6_1_3398773(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp6_1_3398773(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp7_1_3398775(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp7_1_3398775(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp5_2_3398777(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp5_2_3398777(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_6_3398778(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_6_3398778(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_14_3398782(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_14_3398782(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_3_3398784(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_3_3398784(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp8_1_3398788(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp8_1_3398788(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_1_3398789(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_1_3398789(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_17_3398791(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_17_3398791(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_7_3398793(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_7_3398793(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_7_3398794(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_7_3398794(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_4_3398797(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_4_3398797(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_29_3398799(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_29_3398799(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_2_3398801(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_2_3398801(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_13_3398802(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_13_3398802(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_7_3398804(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_7_3398804(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_32_3398806(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_32_3398806(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_20_3398809(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_20_3398809(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_3_3398810(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_3_3398810(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_1_3398811(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_1_3398811(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_9_3398815(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_9_3398815(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp5_4_3398816(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp5_4_3398816(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp5_4_3398817(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp5_4_3398817(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_25_3398820(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_25_3398820(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_10_3398821(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_10_3398821(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_26_3398822(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_26_3398822(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp11_1_3398824(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp11_1_3398824(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_1_3398829(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_1_3398829(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_2_3398830(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_2_3398830(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_5_3398831(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_5_3398831(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_21_3398832(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_21_3398832(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_29_3398835(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_29_3398835(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_21_3398836(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_21_3398836(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_20_3398837(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_20_3398837(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp4_2_3398839(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp4_2_3398839(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_8_3398840(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_8_3398840(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_5_3398844(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_5_3398844(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_12_3398846(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_12_3398846(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_9_3398848(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_9_3398848(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_7_3398851(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_7_3398851(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_13_3398852(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_13_3398852(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_40_3398853(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_40_3398853(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_40_3398855(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_40_3398855(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_6_3398857(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_6_3398857(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp17_1_3398863(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp17_1_3398863(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_3_3398866(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_3_3398866(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_10_3398867(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_10_3398867(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp4_3_3398869(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp4_3_3398869(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp9_1_3398870(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp9_1_3398870(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp4_2_3398873(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp4_2_3398873(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp2_1_3398874(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp2_1_3398874(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp19_1_3398877(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp19_1_3398877(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp1_10_3398879(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp1_10_3398879(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_52_3398880(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_52_3398880(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_52_3398881(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_52_3398881(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_41_3398883(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_41_3398883(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_36_3398884(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_36_3398884(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_34_3398885(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_34_3398885(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_31_3398886(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_31_3398886(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_29_3398887(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_29_3398887(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_18_3398888(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_18_3398888(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_60_3398889(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_60_3398889(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_62_3398890(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_62_3398890(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_60_3398891(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_60_3398891(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_62_3398892(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_62_3398892(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_62_3398893(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_62_3398893(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}
void V2_StateMachineController::_V2_outTRp3_61_3398894(int instance_id, int clause_id)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	current->V2_outTRp3_61_3398894(this, instance_id, clause_id);
	publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
}

std::vector<int> V2_StateMachineController::_match_V2_outTRp1_1_3398718(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_1_3398718(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_1_3398719(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_1_3398719(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_1_3398720(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_1_3398720(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_1_3398724(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_1_3398724(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_4_3398725(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_4_3398725(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_3_3398727(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_3_3398727(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_4_3398731(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_4_3398731(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_5_3398733(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_5_3398733(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_2_3398735(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_2_3398735(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_3_3398736(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_3_3398736(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_1_3398738(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_1_3398738(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp2_3_3398740(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp2_3_3398740(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp4_1_3398744(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp4_1_3398744(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp5_1_3398745(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp5_1_3398745(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_10_3398748(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_10_3398748(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_6_3398756(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_6_3398756(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_4_3398759(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_4_3398759(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_6_3398761(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_6_3398761(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp2_6_3398762(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp2_6_3398762(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_4_3398763(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_4_3398763(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_11_3398764(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_11_3398764(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_8_3398766(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_8_3398766(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_10_3398769(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_10_3398769(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_12_3398771(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_12_3398771(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp6_1_3398773(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp6_1_3398773(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp7_1_3398775(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp7_1_3398775(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp5_2_3398777(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp5_2_3398777(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_6_3398778(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_6_3398778(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_14_3398782(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_14_3398782(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_3_3398784(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_3_3398784(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp8_1_3398788(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp8_1_3398788(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp9_1_3398789(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp9_1_3398789(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_17_3398791(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_17_3398791(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_7_3398793(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_7_3398793(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_7_3398794(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_7_3398794(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_4_3398797(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_4_3398797(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_29_3398799(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_29_3398799(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp9_2_3398801(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp9_2_3398801(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_13_3398802(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_13_3398802(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_7_3398804(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_7_3398804(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_32_3398806(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_32_3398806(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_20_3398809(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_20_3398809(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp9_3_3398810(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp9_3_3398810(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_1_3398811(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_1_3398811(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_9_3398815(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_9_3398815(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp5_4_3398816(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp5_4_3398816(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp5_4_3398817(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp5_4_3398817(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_25_3398820(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_25_3398820(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp2_10_3398821(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp2_10_3398821(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_26_3398822(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_26_3398822(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp11_1_3398824(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp11_1_3398824(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp9_1_3398829(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp9_1_3398829(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_2_3398830(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_2_3398830(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp9_5_3398831(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp9_5_3398831(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_21_3398832(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_21_3398832(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_29_3398835(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_29_3398835(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_21_3398836(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_21_3398836(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_20_3398837(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_20_3398837(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp4_2_3398839(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp4_2_3398839(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_8_3398840(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_8_3398840(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_5_3398844(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_5_3398844(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_12_3398846(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_12_3398846(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp2_9_3398848(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp2_9_3398848(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp2_7_3398851(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp2_7_3398851(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_13_3398852(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_13_3398852(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_40_3398853(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_40_3398853(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_40_3398855(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_40_3398855(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_6_3398857(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_6_3398857(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp17_1_3398863(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp17_1_3398863(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_3_3398866(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_3_3398866(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_10_3398867(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_10_3398867(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp4_3_3398869(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp4_3_3398869(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp9_1_3398870(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp9_1_3398870(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp4_2_3398873(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp4_2_3398873(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp2_1_3398874(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp2_1_3398874(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp19_1_3398877(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp19_1_3398877(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp1_10_3398879(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp1_10_3398879(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_52_3398880(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_52_3398880(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_52_3398881(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_52_3398881(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_41_3398883(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_41_3398883(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_36_3398884(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_36_3398884(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_34_3398885(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_34_3398885(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_31_3398886(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_31_3398886(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_29_3398887(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_29_3398887(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_18_3398888(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_18_3398888(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_60_3398889(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_60_3398889(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_62_3398890(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_62_3398890(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_60_3398891(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_60_3398891(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_62_3398892(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_62_3398892(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_62_3398893(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_62_3398893(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}
std::vector<int> V2_StateMachineController::_match_V2_outTRp3_61_3398894(std::vector<std::string>  list_of_rcvd_notifications)
{
	std::lock_guard<std::mutex> guard(m_mutex);
	m_idle = false;
	m_condVar.notify_one();
	
	event_status_msg.clear();
	std::vector<int> matched_instance_clause_id = current->match_V2_outTRp3_61_3398894(this, list_of_rcvd_notifications);
	event_status_msg.clear();
	//publishToEventRepo(m_eventRepo);
	
	m_idle = true;
	m_condVar.notify_one();
	return matched_instance_clause_id;
}




/*********** Concrete State Class: p1_1 ***********/

list<string> p1_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_1_3398811");
	return retStr;
}

string p1_1::getCurrentState() { return name; }

list<string> p1_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_1", NO_ENABLED_GUARDS));
	}
}

bool p1_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_1_3398811
void p1_1::V2_outTRp1_1_3398811(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_1_3398811 -> Going From p1_1 to p1_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_1 => p1_2");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398811");
								smc->event_status_msg.push_back(" <!> State Update: p1_1 => p1_2");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398811"<<std::endl;
							std::cout<<" <!> State Update: p1_1 => p1_2"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_2());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_1_3398811
std::vector<int> p1_1::match_V2_outTRp1_1_3398811(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_1_3398811");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_1_3398811
void p1_1::V2_outTRp1_1_3398811(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_1_3398811 -> Going From p1_1 to p1_2"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_1 => p1_2");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398811");
							smc->event_status_msg.push_back(" <!> State Update: p1_1 => p1_2");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398811"<<std::endl;
						std::cout<<" <!> State Update: p1_1 => p1_2"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_2());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_1::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398811");
					smc->event_status_msg.push_back(" <!> State Update: p1_1 => p1_2");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398811"<<std::endl;
					std::cout<<" <!> State Update: p1_1 => p1_2"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_1_3398811();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_1_3398811");
					if(smc->m_outTRp1_1_3398811_Handler != nullptr)
					{
						smc->m_outTRp1_1_3398811_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_1 => p1_2");
					smc->setCurrent(new p1_2());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_1!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_43 ***********/

list<string> p1_43::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_43::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_31_3398828");
	return retStr;
}
		
list<string> p1_43::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_43::getCurrentState() { return name; }

list<string> p1_43::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_43::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_31_3398828
	{
	list_of_enabled_signals.push_back("V2_inTRp1_31_3398828");
	}
	return list_of_enabled_signals;
}

void p1_43::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_31_3398828"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_31_3398828();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_31_3398828( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_31_3398828( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_31_3398828"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_31_3398828" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_31_3398828(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_31_3398828" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_31_3398828( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_31_3398828 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_31_3398828(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_31_3398828(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_31_3398828(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_31_3398828 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_31_3398828 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_31_3398828" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_31_3398828( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_31_3398828 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_43"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_43", NO_ENABLED_GUARDS));
	}
}

bool p1_43::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_43::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_43::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_31_3398828
bool p1_43::isEnabledV2_inTRp1_31_3398828(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_31_3398828
std::vector<int> p1_43::V2_inTRp1_31_3398828(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_31_3398828");
							smc->event_status_msg.push_back(" <!> State Update: p1_43 => p1_44");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_31_3398828"<<std::endl;
							// std::cout<<" <!> State Update: From p1_43 => p1_44"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_43 => p1_44");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_31_3398828 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_43");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_43!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_31_3398828
void p1_43::V2_inTRp1_31_3398828(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_31_3398828");
							smc->event_status_msg.push_back(" <!> State Update: p1_43 => p1_44");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_31_3398828"<<std::endl;
							std::cout<<" <!> State Update: From p1_43 => p1_44"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_43 => p1_44");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_44());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_31_3398828 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_43");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_43!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_31_3398828
void p1_43::V2_inTRp1_31_3398828(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_31_3398828");
				smc->event_status_msg.push_back(" <!> State Update: p1_43 => p1_44");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_31_3398828"<<std::endl;
				std::cout<<" <!> State Update: From p1_43 => p1_44"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_43 => p1_44");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_44());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_31_3398828 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_43");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_43!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_35 ***********/

list<string> p1_35::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_35::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_35::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_20_3398809");
	return retStr;
}

string p1_35::getCurrentState() { return name; }

list<string> p1_35::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_35::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_35::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_35"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_35", NO_ENABLED_GUARDS));
	}
}

bool p1_35::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_35::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_35::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_20_3398809
void p1_35::V2_outTRp1_20_3398809(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_20_3398809 -> Going From p1_35 to p1_36"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_35 => p1_36");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_20_3398809");
								smc->event_status_msg.push_back(" <!> State Update: p1_35 => p1_36");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_20_3398809"<<std::endl;
							std::cout<<" <!> State Update: p1_35 => p1_36"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_36());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_35");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_20_3398809
std::vector<int> p1_35::match_V2_outTRp1_20_3398809(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_20_3398809");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_35");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_20_3398809
void p1_35::V2_outTRp1_20_3398809(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_20_3398809 -> Going From p1_35 to p1_36"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_35 => p1_36");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_20_3398809");
							smc->event_status_msg.push_back(" <!> State Update: p1_35 => p1_36");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_20_3398809"<<std::endl;
						std::cout<<" <!> State Update: p1_35 => p1_36"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_36());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_35");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_35::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_20_3398809");
					smc->event_status_msg.push_back(" <!> State Update: p1_35 => p1_36");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_20_3398809"<<std::endl;
					std::cout<<" <!> State Update: p1_35 => p1_36"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_20_3398809();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_20_3398809");
					if(smc->m_outTRp1_20_3398809_Handler != nullptr)
					{
						smc->m_outTRp1_20_3398809_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_35 => p1_36");
					smc->setCurrent(new p1_36());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_35");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_35!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p2_1 ***********/

list<string> p2_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p2_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp2_1_3398874");
	return retStr;
}

string p2_1::getCurrentState() { return name; }

list<string> p2_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p2_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_1", NO_ENABLED_GUARDS));
	}
}

bool p2_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp2_1_3398874
void p2_1::V2_outTRp2_1_3398874(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp2_1_3398874 -> Going From p2_1 to p2_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_1 => p2_2");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_1_3398874");
								smc->event_status_msg.push_back(" <!> State Update: p2_1 => p2_2");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_1_3398874"<<std::endl;
							std::cout<<" <!> State Update: p2_1 => p2_2"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_2());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp2_1_3398874
std::vector<int> p2_1::match_V2_outTRp2_1_3398874(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp2_1_3398874");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp2_1_3398874
void p2_1::V2_outTRp2_1_3398874(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp2_1_3398874 -> Going From p2_1 to p2_2"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p2_1 => p2_2");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_1_3398874");
							smc->event_status_msg.push_back(" <!> State Update: p2_1 => p2_2");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_1_3398874"<<std::endl;
						std::cout<<" <!> State Update: p2_1 => p2_2"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p2_2());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p2_1::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_1_3398874");
					smc->event_status_msg.push_back(" <!> State Update: p2_1 => p2_2");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_1_3398874"<<std::endl;
					std::cout<<" <!> State Update: p2_1 => p2_2"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp2_1_3398874();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp2_1_3398874");
					if(smc->m_outTRp2_1_3398874_Handler != nullptr)
					{
						smc->m_outTRp2_1_3398874_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p2_1 => p2_2");
					smc->setCurrent(new p2_2());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_1!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_1 ***********/

list<string> p3_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_1_3398724");
	return retStr;
}

string p3_1::getCurrentState() { return name; }

list<string> p3_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_1", NO_ENABLED_GUARDS));
	}
}

bool p3_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_1_3398724
void p3_1::V2_outTRp3_1_3398724(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_1_3398724 -> Going From p3_1 to p3_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_1 => p3_2");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_1_3398724");
								smc->event_status_msg.push_back(" <!> State Update: p3_1 => p3_2");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_1_3398724"<<std::endl;
							std::cout<<" <!> State Update: p3_1 => p3_2"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_2());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_1_3398724
std::vector<int> p3_1::match_V2_outTRp3_1_3398724(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_1_3398724");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_1_3398724
void p3_1::V2_outTRp3_1_3398724(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_1_3398724 -> Going From p3_1 to p3_2"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_1 => p3_2");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_1_3398724");
							smc->event_status_msg.push_back(" <!> State Update: p3_1 => p3_2");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_1_3398724"<<std::endl;
						std::cout<<" <!> State Update: p3_1 => p3_2"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_2());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_1::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_1_3398724");
					smc->event_status_msg.push_back(" <!> State Update: p3_1 => p3_2");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_1_3398724"<<std::endl;
					std::cout<<" <!> State Update: p3_1 => p3_2"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_1_3398724();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_1_3398724");
					if(smc->m_outTRp3_1_3398724_Handler != nullptr)
					{
						smc->m_outTRp3_1_3398724_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_1 => p3_2");
					smc->setCurrent(new p3_2());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_1!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_24 ***********/

list<string> p1_24::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_24::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_24::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_6_3398778");
	return retStr;
}

string p1_24::getCurrentState() { return name; }

list<string> p1_24::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_24::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_24::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_24"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_24", NO_ENABLED_GUARDS));
	}
}

bool p1_24::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_24::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_24::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_6_3398778
void p1_24::V2_outTRp1_6_3398778(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_6_3398778 -> Going From p1_24 to p1_25"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_24 => p1_25");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_6_3398778");
								smc->event_status_msg.push_back(" <!> State Update: p1_24 => p1_25");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_6_3398778"<<std::endl;
							std::cout<<" <!> State Update: p1_24 => p1_25"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_25());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_24");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_6_3398778
std::vector<int> p1_24::match_V2_outTRp1_6_3398778(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_6_3398778");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_24");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_6_3398778
void p1_24::V2_outTRp1_6_3398778(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_6_3398778 -> Going From p1_24 to p1_25"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_24 => p1_25");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_6_3398778");
							smc->event_status_msg.push_back(" <!> State Update: p1_24 => p1_25");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_6_3398778"<<std::endl;
						std::cout<<" <!> State Update: p1_24 => p1_25"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_25());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_24");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_24::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_6_3398778");
					smc->event_status_msg.push_back(" <!> State Update: p1_24 => p1_25");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_6_3398778"<<std::endl;
					std::cout<<" <!> State Update: p1_24 => p1_25"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_6_3398778();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_6_3398778");
					if(smc->m_outTRp1_6_3398778_Handler != nullptr)
					{
						smc->m_outTRp1_6_3398778_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_24 => p1_25");
					smc->setCurrent(new p1_25());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_24");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_24!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_2 ***********/

list<string> p3_2::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_2::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_2::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_2_3398830");
	return retStr;
}

string p3_2::getCurrentState() { return name; }

list<string> p3_2::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_2::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_2::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_2"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_2", NO_ENABLED_GUARDS));
	}
}

bool p3_2::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_2::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_2::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_2_3398830
void p3_2::V2_outTRp3_2_3398830(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_2_3398830 -> Going From p3_2 to p3_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_2 => p3_3");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_2_3398830");
								smc->event_status_msg.push_back(" <!> State Update: p3_2 => p3_3");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_2_3398830"<<std::endl;
							std::cout<<" <!> State Update: p3_2 => p3_3"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_3());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_2_3398830
std::vector<int> p3_2::match_V2_outTRp3_2_3398830(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_2_3398830");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_2_3398830
void p3_2::V2_outTRp3_2_3398830(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_2_3398830 -> Going From p3_2 to p3_3"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_2 => p3_3");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_2_3398830");
							smc->event_status_msg.push_back(" <!> State Update: p3_2 => p3_3");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_2_3398830"<<std::endl;
						std::cout<<" <!> State Update: p3_2 => p3_3"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_3());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_2::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_2_3398830");
					smc->event_status_msg.push_back(" <!> State Update: p3_2 => p3_3");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_2_3398830"<<std::endl;
					std::cout<<" <!> State Update: p3_2 => p3_3"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_2_3398830();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_2_3398830");
					if(smc->m_outTRp3_2_3398830_Handler != nullptr)
					{
						smc->m_outTRp3_2_3398830_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_2 => p3_3");
					smc->setCurrent(new p3_3());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_2!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_45 ***********/

list<string> p3_45::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_45::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_9_3398751");
	return retStr;
}
		
list<string> p3_45::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_45::getCurrentState() { return name; }

list<string> p3_45::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_45::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_9_3398751
	{
	list_of_enabled_signals.push_back("V2_inTRp3_9_3398751");
	}
	return list_of_enabled_signals;
}

void p3_45::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_9_3398751"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_9_3398751();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_9_3398751( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_9_3398751( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_9_3398751"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_9_3398751" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_9_3398751(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_9_3398751" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_9_3398751( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_9_3398751 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_9_3398751(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_9_3398751(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_9_3398751(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_9_3398751 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_9_3398751 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_9_3398751" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_9_3398751( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_9_3398751 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_45"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_45", NO_ENABLED_GUARDS));
	}
}

bool p3_45::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_45::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_45::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_9_3398751
bool p3_45::isEnabledV2_inTRp3_9_3398751(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_9_3398751
std::vector<int> p3_45::V2_inTRp3_9_3398751(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_9_3398751");
							smc->event_status_msg.push_back(" <!> State Update: p3_45 => p3_46");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_9_3398751"<<std::endl;
							// std::cout<<" <!> State Update: From p3_45 => p3_46"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_45 => p3_46");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_9_3398751 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_45");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_45!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_9_3398751
void p3_45::V2_inTRp3_9_3398751(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_9_3398751");
							smc->event_status_msg.push_back(" <!> State Update: p3_45 => p3_46");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_9_3398751"<<std::endl;
							std::cout<<" <!> State Update: From p3_45 => p3_46"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_45 => p3_46");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_46());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_9_3398751 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_45");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_45!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_9_3398751
void p3_45::V2_inTRp3_9_3398751(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_9_3398751");
				smc->event_status_msg.push_back(" <!> State Update: p3_45 => p3_46");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_9_3398751"<<std::endl;
				std::cout<<" <!> State Update: From p3_45 => p3_46"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_45 => p3_46");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_46());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_9_3398751 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_45");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_45!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_37 ***********/

list<string> p3_37::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_37::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_37::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_34_3398885");
	return retStr;
}

string p3_37::getCurrentState() { return name; }

list<string> p3_37::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_37::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_37::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_37"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_37", NO_ENABLED_GUARDS));
	}
}

bool p3_37::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_37::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_37::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_34_3398885
void p3_37::V2_outTRp3_34_3398885(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_34_3398885 -> Going From p3_37 to p3_38"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_37 => p3_38");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_34_3398885");
								smc->event_status_msg.push_back(" <!> State Update: p3_37 => p3_38");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_34_3398885"<<std::endl;
							std::cout<<" <!> State Update: p3_37 => p3_38"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_38());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_37");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_34_3398885
std::vector<int> p3_37::match_V2_outTRp3_34_3398885(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_34_3398885");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_37");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_34_3398885
void p3_37::V2_outTRp3_34_3398885(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_34_3398885 -> Going From p3_37 to p3_38"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_37 => p3_38");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_34_3398885");
							smc->event_status_msg.push_back(" <!> State Update: p3_37 => p3_38");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_34_3398885"<<std::endl;
						std::cout<<" <!> State Update: p3_37 => p3_38"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_38());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_37");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_37::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_34_3398885");
					smc->event_status_msg.push_back(" <!> State Update: p3_37 => p3_38");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_34_3398885"<<std::endl;
					std::cout<<" <!> State Update: p3_37 => p3_38"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_34_3398885();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_34_3398885");
					if(smc->m_outTRp3_34_3398885_Handler != nullptr)
					{
						smc->m_outTRp3_34_3398885_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_37 => p3_38");
					smc->setCurrent(new p3_38());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_37");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_37!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p2_17 ***********/

list<string> p2_17::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_17::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p2_17::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp2_10_3398821");
	return retStr;
}

string p2_17::getCurrentState() { return name; }

list<string> p2_17::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_17::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p2_17::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_17"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_17", NO_ENABLED_GUARDS));
	}
}

bool p2_17::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_17::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_17::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp2_10_3398821
void p2_17::V2_outTRp2_10_3398821(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp2_10_3398821 -> Going From p2_17 to p2_18"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_17 => p2_18");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_10_3398821");
								smc->event_status_msg.push_back(" <!> State Update: p2_17 => p2_18");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_10_3398821"<<std::endl;
							std::cout<<" <!> State Update: p2_17 => p2_18"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_18());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp2_10_3398821
std::vector<int> p2_17::match_V2_outTRp2_10_3398821(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp2_10_3398821");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp2_10_3398821
void p2_17::V2_outTRp2_10_3398821(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp2_10_3398821 -> Going From p2_17 to p2_18"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p2_17 => p2_18");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_10_3398821");
							smc->event_status_msg.push_back(" <!> State Update: p2_17 => p2_18");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_10_3398821"<<std::endl;
						std::cout<<" <!> State Update: p2_17 => p2_18"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p2_18());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p2_17::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_10_3398821");
					smc->event_status_msg.push_back(" <!> State Update: p2_17 => p2_18");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_10_3398821"<<std::endl;
					std::cout<<" <!> State Update: p2_17 => p2_18"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp2_10_3398821();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp2_10_3398821");
					if(smc->m_outTRp2_10_3398821_Handler != nullptr)
					{
						smc->m_outTRp2_10_3398821_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p2_17 => p2_18");
					smc->setCurrent(new p2_18());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_17!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_56 ***********/

list<string> p3_56::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_56::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_56::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_52_3398881");
	return retStr;
}

string p3_56::getCurrentState() { return name; }

list<string> p3_56::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_56::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_56::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_56"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_56", NO_ENABLED_GUARDS));
	}
}

bool p3_56::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_56::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_56::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_52_3398881
void p3_56::V2_outTRp3_52_3398881(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_52_3398881 -> Going From p3_56 to p3_60"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_56 => p3_60");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_52_3398881");
								smc->event_status_msg.push_back(" <!> State Update: p3_56 => p3_60");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_52_3398881"<<std::endl;
							std::cout<<" <!> State Update: p3_56 => p3_60"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_60());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_56");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_52_3398881
std::vector<int> p3_56::match_V2_outTRp3_52_3398881(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_52_3398881");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_56");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_52_3398881
void p3_56::V2_outTRp3_52_3398881(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_52_3398881 -> Going From p3_56 to p3_60"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_56 => p3_60");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_52_3398881");
							smc->event_status_msg.push_back(" <!> State Update: p3_56 => p3_60");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_52_3398881"<<std::endl;
						std::cout<<" <!> State Update: p3_56 => p3_60"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_60());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_56");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_56::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_52_3398881");
					smc->event_status_msg.push_back(" <!> State Update: p3_56 => p3_60");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_52_3398881"<<std::endl;
					std::cout<<" <!> State Update: p3_56 => p3_60"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_52_3398881();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_52_3398881");
					if(smc->m_outTRp3_52_3398881_Handler != nullptr)
					{
						smc->m_outTRp3_52_3398881_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_56 => p3_60");
					smc->setCurrent(new p3_60());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_56");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_56!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_48 ***********/

list<string> p3_48::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_48::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_5_3398734");
	return retStr;
}
		
list<string> p3_48::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_48::getCurrentState() { return name; }

list<string> p3_48::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_48::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_5_3398734
	{
	list_of_enabled_signals.push_back("V2_inTRp3_5_3398734");
	}
	return list_of_enabled_signals;
}

void p3_48::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_5_3398734"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_5_3398734();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_5_3398734( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_5_3398734( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_5_3398734"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_5_3398734" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_5_3398734(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_5_3398734" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_5_3398734( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_5_3398734 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_5_3398734(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_5_3398734(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_5_3398734(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_5_3398734 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_5_3398734 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_5_3398734" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_5_3398734( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_5_3398734 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_48"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_48", NO_ENABLED_GUARDS));
	}
}

bool p3_48::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_48::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_48::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_5_3398734
bool p3_48::isEnabledV2_inTRp3_5_3398734(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_5_3398734
std::vector<int> p3_48::V2_inTRp3_5_3398734(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_5_3398734");
							smc->event_status_msg.push_back(" <!> State Update: p3_48 => p3_49");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_5_3398734"<<std::endl;
							// std::cout<<" <!> State Update: From p3_48 => p3_49"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_48 => p3_49");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_5_3398734 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_48");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_48!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_5_3398734
void p3_48::V2_inTRp3_5_3398734(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_5_3398734");
							smc->event_status_msg.push_back(" <!> State Update: p3_48 => p3_49");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_5_3398734"<<std::endl;
							std::cout<<" <!> State Update: From p3_48 => p3_49"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_48 => p3_49");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_49());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_5_3398734 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_48");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_48!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_5_3398734
void p3_48::V2_inTRp3_5_3398734(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_5_3398734");
				smc->event_status_msg.push_back(" <!> State Update: p3_48 => p3_49");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_5_3398734"<<std::endl;
				std::cout<<" <!> State Update: From p3_48 => p3_49"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_48 => p3_49");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_49());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_5_3398734 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_48");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_48!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p2_7 ***********/

list<string> p2_7::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_7::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_5_3398826");
	return retStr;
}
		
list<string> p2_7::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_7::getCurrentState() { return name; }

list<string> p2_7::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_7::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_5_3398826
	{
	list_of_enabled_signals.push_back("V2_inTRp2_5_3398826");
	}
	return list_of_enabled_signals;
}

void p2_7::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_5_3398826"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_5_3398826();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_5_3398826( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_5_3398826( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_5_3398826"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_5_3398826" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_5_3398826(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_5_3398826" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_5_3398826( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_5_3398826 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_5_3398826(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_5_3398826(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_5_3398826(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_5_3398826 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_5_3398826 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_5_3398826" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_5_3398826( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_5_3398826 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_7"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_7", NO_ENABLED_GUARDS));
	}
}

bool p2_7::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_7::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_7::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_5_3398826
bool p2_7::isEnabledV2_inTRp2_5_3398826(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_5_3398826
std::vector<int> p2_7::V2_inTRp2_5_3398826(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_5_3398826");
							smc->event_status_msg.push_back(" <!> State Update: p2_7 => p2_8");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_5_3398826"<<std::endl;
							// std::cout<<" <!> State Update: From p2_7 => p2_8"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_7 => p2_8");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_5_3398826 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_7");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_7!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_5_3398826
void p2_7::V2_inTRp2_5_3398826(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_5_3398826");
							smc->event_status_msg.push_back(" <!> State Update: p2_7 => p2_8");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_5_3398826"<<std::endl;
							std::cout<<" <!> State Update: From p2_7 => p2_8"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_7 => p2_8");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_8());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_5_3398826 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_7");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_7!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_5_3398826
void p2_7::V2_inTRp2_5_3398826(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_5_3398826");
				smc->event_status_msg.push_back(" <!> State Update: p2_7 => p2_8");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_5_3398826"<<std::endl;
				std::cout<<" <!> State Update: From p2_7 => p2_8"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_7 => p2_8");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_8());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_5_3398826 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_7");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_7!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_54 ***********/

list<string> p3_54::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_54::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_10_3398741");
	return retStr;
}
		
list<string> p3_54::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_54::getCurrentState() { return name; }

list<string> p3_54::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_54::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_10_3398741
	{
	list_of_enabled_signals.push_back("V2_inTRp3_10_3398741");
	}
	return list_of_enabled_signals;
}

void p3_54::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_10_3398741"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_10_3398741();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_10_3398741( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_10_3398741( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_10_3398741"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_10_3398741" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_10_3398741(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_10_3398741" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_10_3398741( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_10_3398741 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_10_3398741(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_10_3398741(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_10_3398741(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_10_3398741 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_10_3398741 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_10_3398741" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_10_3398741( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_10_3398741 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_54"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_54", NO_ENABLED_GUARDS));
	}
}

bool p3_54::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_54::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_54::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_10_3398741
bool p3_54::isEnabledV2_inTRp3_10_3398741(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_10_3398741
std::vector<int> p3_54::V2_inTRp3_10_3398741(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_10_3398741");
							smc->event_status_msg.push_back(" <!> State Update: p3_54 => p3_55");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_10_3398741"<<std::endl;
							// std::cout<<" <!> State Update: From p3_54 => p3_55"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_54 => p3_55");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_10_3398741 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_54");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_54!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_10_3398741
void p3_54::V2_inTRp3_10_3398741(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_10_3398741");
							smc->event_status_msg.push_back(" <!> State Update: p3_54 => p3_55");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_10_3398741"<<std::endl;
							std::cout<<" <!> State Update: From p3_54 => p3_55"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_54 => p3_55");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_55());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_10_3398741 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_54");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_54!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_10_3398741
void p3_54::V2_inTRp3_10_3398741(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_10_3398741");
				smc->event_status_msg.push_back(" <!> State Update: p3_54 => p3_55");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_10_3398741"<<std::endl;
				std::cout<<" <!> State Update: From p3_54 => p3_55"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_54 => p3_55");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_55());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_10_3398741 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_54");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_54!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_49 ***********/

list<string> p3_49::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_49::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_9_3398747");
	return retStr;
}
		
list<string> p3_49::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_49::getCurrentState() { return name; }

list<string> p3_49::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_49::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_9_3398747
	{
	list_of_enabled_signals.push_back("V2_inTRp3_9_3398747");
	}
	return list_of_enabled_signals;
}

void p3_49::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_9_3398747"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_9_3398747();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_9_3398747( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_9_3398747( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_9_3398747"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_9_3398747" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_9_3398747(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_9_3398747" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_9_3398747( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_9_3398747 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_9_3398747(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_9_3398747(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_9_3398747(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_9_3398747 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_9_3398747 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_9_3398747" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_9_3398747( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_9_3398747 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_49"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_49", NO_ENABLED_GUARDS));
	}
}

bool p3_49::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_49::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_49::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_9_3398747
bool p3_49::isEnabledV2_inTRp3_9_3398747(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_9_3398747
std::vector<int> p3_49::V2_inTRp3_9_3398747(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_9_3398747");
							smc->event_status_msg.push_back(" <!> State Update: p3_49 => p3_50");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_9_3398747"<<std::endl;
							// std::cout<<" <!> State Update: From p3_49 => p3_50"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_49 => p3_50");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_9_3398747 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_49");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_49!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_9_3398747
void p3_49::V2_inTRp3_9_3398747(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_9_3398747");
							smc->event_status_msg.push_back(" <!> State Update: p3_49 => p3_50");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_9_3398747"<<std::endl;
							std::cout<<" <!> State Update: From p3_49 => p3_50"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_49 => p3_50");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_50());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_9_3398747 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_49");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_49!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_9_3398747
void p3_49::V2_inTRp3_9_3398747(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_9_3398747");
				smc->event_status_msg.push_back(" <!> State Update: p3_49 => p3_50");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_9_3398747"<<std::endl;
				std::cout<<" <!> State Update: From p3_49 => p3_50"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_49 => p3_50");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_50());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_9_3398747 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_49");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_49!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_6 ***********/

list<string> p3_6::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_6::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_6::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_6_3398857");
	retStr.push_back("V2_outTRp3_3_3398736");
	return retStr;
}

string p3_6::getCurrentState() { return name; }

list<string> p3_6::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_6::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_6::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_6"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_6", NO_ENABLED_GUARDS));
	}
}

bool p3_6::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_6::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_6::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true ||   true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_6_3398857
void p3_6::V2_outTRp3_6_3398857(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_6_3398857 -> Going From p3_6 to p17_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_6 => p17_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_6_3398857");
								smc->event_status_msg.push_back(" <!> State Update: p3_6 => p17_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_6_3398857"<<std::endl;
							std::cout<<" <!> State Update: p3_6 => p17_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p17_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Deterministic Notification Handler: V2_outTRp3_3_3398736
void p3_6::V2_outTRp3_3_3398736(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_3_3398736 -> Going From p3_6 to p3_7"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_6 => p3_7");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_3_3398736");
								smc->event_status_msg.push_back(" <!> State Update: p3_6 => p3_7");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_3_3398736"<<std::endl;
							std::cout<<" <!> State Update: p3_6 => p3_7"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_7());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_6_3398857
std::vector<int> p3_6::match_V2_outTRp3_6_3398857(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_6_3398857");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Validator: V2_outTRp3_3_3398736
std::vector<int> p3_6::match_V2_outTRp3_3_3398736(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_3_3398736");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_6_3398857
void p3_6::V2_outTRp3_6_3398857(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_6_3398857 -> Going From p3_6 to p17_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_6 => p17_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_6_3398857");
							smc->event_status_msg.push_back(" <!> State Update: p3_6 => p17_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_6_3398857"<<std::endl;
						std::cout<<" <!> State Update: p3_6 => p17_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p17_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Handler: V2_outTRp3_3_3398736
void p3_6::V2_outTRp3_3_3398736(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_3_3398736 -> Going From p3_6 to p3_7"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_6 => p3_7");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_3_3398736");
							smc->event_status_msg.push_back(" <!> State Update: p3_6 => p3_7");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_3_3398736"<<std::endl;
						std::cout<<" <!> State Update: p3_6 => p3_7"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_7());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_6::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true ||   true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %2; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_3_3398736");
					smc->event_status_msg.push_back(" <!> State Update: p3_6 => p3_7");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_3_3398736"<<std::endl;
					std::cout<<" <!> State Update: p3_6 => p3_7"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_3_3398736();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_3_3398736");
					if(smc->m_outTRp3_3_3398736_Handler != nullptr)
					{
						smc->m_outTRp3_3_3398736_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_6 => p3_7");
					smc->setCurrent(new p3_7());
					delete this;
					break;
		case 1:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_6_3398857");
					smc->event_status_msg.push_back(" <!> State Update: p3_6 => p17_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_6_3398857"<<std::endl;
					std::cout<<" <!> State Update: p3_6 => p17_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_6_3398857();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_6_3398857");
					if(smc->m_outTRp3_6_3398857_Handler != nullptr)
					{
						smc->m_outTRp3_6_3398857_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_6 => p17_1");
					smc->setCurrent(new p17_1());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_6!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_27 ***********/

list<string> p3_27::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_27::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_27::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_21_3398836");
	return retStr;
}

string p3_27::getCurrentState() { return name; }

list<string> p3_27::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_27::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_27::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_27"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_27", NO_ENABLED_GUARDS));
	}
}

bool p3_27::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_27::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_27::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_21_3398836
void p3_27::V2_outTRp3_21_3398836(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_21_3398836 -> Going From p3_27 to p3_28"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_27 => p3_28");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_21_3398836");
								smc->event_status_msg.push_back(" <!> State Update: p3_27 => p3_28");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_21_3398836"<<std::endl;
							std::cout<<" <!> State Update: p3_27 => p3_28"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_28());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_27");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_21_3398836
std::vector<int> p3_27::match_V2_outTRp3_21_3398836(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_21_3398836");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_27");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_21_3398836
void p3_27::V2_outTRp3_21_3398836(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_21_3398836 -> Going From p3_27 to p3_28"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_27 => p3_28");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_21_3398836");
							smc->event_status_msg.push_back(" <!> State Update: p3_27 => p3_28");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_21_3398836"<<std::endl;
						std::cout<<" <!> State Update: p3_27 => p3_28"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_28());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_27");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_27::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_21_3398836");
					smc->event_status_msg.push_back(" <!> State Update: p3_27 => p3_28");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_21_3398836"<<std::endl;
					std::cout<<" <!> State Update: p3_27 => p3_28"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_21_3398836();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_21_3398836");
					if(smc->m_outTRp3_21_3398836_Handler != nullptr)
					{
						smc->m_outTRp3_21_3398836_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_27 => p3_28");
					smc->setCurrent(new p3_28());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_27");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_27!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_7 ***********/

list<string> p3_7::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_7::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_7::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_4_3398763");
	return retStr;
}

string p3_7::getCurrentState() { return name; }

list<string> p3_7::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_7::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_7::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_7"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_7", NO_ENABLED_GUARDS));
	}
}

bool p3_7::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_7::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_7::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_4_3398763
void p3_7::V2_outTRp3_4_3398763(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_4_3398763 -> Going From p3_7 to p3_8"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_7 => p3_8");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_4_3398763");
								smc->event_status_msg.push_back(" <!> State Update: p3_7 => p3_8");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_4_3398763"<<std::endl;
							std::cout<<" <!> State Update: p3_7 => p3_8"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_8());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_7");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_4_3398763
std::vector<int> p3_7::match_V2_outTRp3_4_3398763(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_4_3398763");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_7");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_4_3398763
void p3_7::V2_outTRp3_4_3398763(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_4_3398763 -> Going From p3_7 to p3_8"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_7 => p3_8");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_4_3398763");
							smc->event_status_msg.push_back(" <!> State Update: p3_7 => p3_8");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_4_3398763"<<std::endl;
						std::cout<<" <!> State Update: p3_7 => p3_8"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_8());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_7");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_7::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_4_3398763");
					smc->event_status_msg.push_back(" <!> State Update: p3_7 => p3_8");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_4_3398763"<<std::endl;
					std::cout<<" <!> State Update: p3_7 => p3_8"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_4_3398763();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_4_3398763");
					if(smc->m_outTRp3_4_3398763_Handler != nullptr)
					{
						smc->m_outTRp3_4_3398763_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_7 => p3_8");
					smc->setCurrent(new p3_8());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_7");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_7!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_5 ***********/

list<string> p1_5::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_5::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_2_3398783");
	return retStr;
}
		
list<string> p1_5::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_5::getCurrentState() { return name; }

list<string> p1_5::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_5::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_2_3398783
	{
	list_of_enabled_signals.push_back("V2_inTRp1_2_3398783");
	}
	return list_of_enabled_signals;
}

void p1_5::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_2_3398783"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_2_3398783();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_2_3398783( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_2_3398783( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_2_3398783"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_2_3398783" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_2_3398783(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_2_3398783" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_2_3398783( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_2_3398783 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_2_3398783(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_2_3398783(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_2_3398783(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_2_3398783 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_2_3398783 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_2_3398783" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_2_3398783( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_2_3398783 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_5"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_5", NO_ENABLED_GUARDS));
	}
}

bool p1_5::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_5::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_5::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_2_3398783
bool p1_5::isEnabledV2_inTRp1_2_3398783(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_2_3398783
std::vector<int> p1_5::V2_inTRp1_2_3398783(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398783");
							smc->event_status_msg.push_back(" <!> State Update: p1_5 => p1_6");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398783"<<std::endl;
							// std::cout<<" <!> State Update: From p1_5 => p1_6"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_5 => p1_6");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398783 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_5!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_2_3398783
void p1_5::V2_inTRp1_2_3398783(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398783");
							smc->event_status_msg.push_back(" <!> State Update: p1_5 => p1_6");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398783"<<std::endl;
							std::cout<<" <!> State Update: From p1_5 => p1_6"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_5 => p1_6");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_6());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398783 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_5!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_2_3398783
void p1_5::V2_inTRp1_2_3398783(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398783");
				smc->event_status_msg.push_back(" <!> State Update: p1_5 => p1_6");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398783"<<std::endl;
				std::cout<<" <!> State Update: From p1_5 => p1_6"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_5 => p1_6");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_6());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398783 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_5!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p2_16 ***********/

list<string> p2_16::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_16::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_1_3398728");
	return retStr;
}
		
list<string> p2_16::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_16::getCurrentState() { return name; }

list<string> p2_16::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_16::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_1_3398728
	{
	list_of_enabled_signals.push_back("V2_inTRp2_1_3398728");
	}
	return list_of_enabled_signals;
}

void p2_16::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_1_3398728"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_1_3398728();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_1_3398728( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_1_3398728( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_1_3398728"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_1_3398728" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_1_3398728(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_1_3398728" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_1_3398728( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_1_3398728 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_1_3398728(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_1_3398728(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_1_3398728(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_1_3398728 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_1_3398728 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_1_3398728" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_1_3398728( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_1_3398728 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_16"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_16", NO_ENABLED_GUARDS));
	}
}

bool p2_16::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_16::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_16::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_1_3398728
bool p2_16::isEnabledV2_inTRp2_1_3398728(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_1_3398728
std::vector<int> p2_16::V2_inTRp2_1_3398728(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398728");
							smc->event_status_msg.push_back(" <!> State Update: p2_16 => p2_17");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398728"<<std::endl;
							// std::cout<<" <!> State Update: From p2_16 => p2_17"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_16 => p2_17");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398728 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_16!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_1_3398728
void p2_16::V2_inTRp2_1_3398728(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398728");
							smc->event_status_msg.push_back(" <!> State Update: p2_16 => p2_17");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398728"<<std::endl;
							std::cout<<" <!> State Update: From p2_16 => p2_17"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_16 => p2_17");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_17());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398728 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_16!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_1_3398728
void p2_16::V2_inTRp2_1_3398728(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398728");
				smc->event_status_msg.push_back(" <!> State Update: p2_16 => p2_17");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398728"<<std::endl;
				std::cout<<" <!> State Update: From p2_16 => p2_17"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_16 => p2_17");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_17());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398728 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_16!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p2_12 ***********/

list<string> p2_12::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_12::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_8_3398847");
	return retStr;
}
		
list<string> p2_12::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_12::getCurrentState() { return name; }

list<string> p2_12::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_12::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_8_3398847
	{
	list_of_enabled_signals.push_back("V2_inTRp2_8_3398847");
	}
	return list_of_enabled_signals;
}

void p2_12::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_8_3398847"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_8_3398847();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_8_3398847( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_8_3398847( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_8_3398847"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_8_3398847" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_8_3398847(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_8_3398847" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_8_3398847( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_8_3398847 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_8_3398847(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_8_3398847(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_8_3398847(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_8_3398847 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_8_3398847 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_8_3398847" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_8_3398847( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_8_3398847 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_12"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_12", NO_ENABLED_GUARDS));
	}
}

bool p2_12::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_12::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_12::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_8_3398847
bool p2_12::isEnabledV2_inTRp2_8_3398847(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_8_3398847
std::vector<int> p2_12::V2_inTRp2_8_3398847(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_8_3398847");
							smc->event_status_msg.push_back(" <!> State Update: p2_12 => p2_13");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_8_3398847"<<std::endl;
							// std::cout<<" <!> State Update: From p2_12 => p2_13"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_12 => p2_13");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_8_3398847 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_12");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_12!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_8_3398847
void p2_12::V2_inTRp2_8_3398847(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_8_3398847");
							smc->event_status_msg.push_back(" <!> State Update: p2_12 => p2_13");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_8_3398847"<<std::endl;
							std::cout<<" <!> State Update: From p2_12 => p2_13"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_12 => p2_13");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_13());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_8_3398847 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_12");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_12!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_8_3398847
void p2_12::V2_inTRp2_8_3398847(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_8_3398847");
				smc->event_status_msg.push_back(" <!> State Update: p2_12 => p2_13");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_8_3398847"<<std::endl;
				std::cout<<" <!> State Update: From p2_12 => p2_13"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_12 => p2_13");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_13());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_8_3398847 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_12");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_12!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_55 ***********/

list<string> p3_55::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_55::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_4_3398729");
	retStr.push_back("V2_inTRp3_26_3398774");
	return retStr;
}
		
list<string> p3_55::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_55::getCurrentState() { return name; }

list<string> p3_55::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_55::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_4_3398729
	{
	list_of_enabled_signals.push_back("V2_inTRp3_4_3398729");
	}
	// Signal Name: V2_inTRp3_26_3398774
	{
	list_of_enabled_signals.push_back("V2_inTRp3_26_3398774");
	}
	return list_of_enabled_signals;
}

void p3_55::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_4_3398729"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_4_3398729();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_4_3398729( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_4_3398729( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		if(!(*it).compare("V2_inTRp3_26_3398774"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_26_3398774();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_26_3398774( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_26_3398774( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_4_3398729"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_4_3398729" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_4_3398729(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_4_3398729" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_4_3398729( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_4_3398729 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_4_3398729(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_4_3398729(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_4_3398729(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_4_3398729 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_4_3398729 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_4_3398729" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_4_3398729( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_4_3398729 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		if(!(*it).compare("V2_inTRp3_26_3398774"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_26_3398774" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_26_3398774(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_26_3398774" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_26_3398774( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_26_3398774 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_26_3398774(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_26_3398774(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_26_3398774(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_26_3398774 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_26_3398774 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_26_3398774" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_26_3398774( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_26_3398774 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_55"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_55", NO_ENABLED_GUARDS));
	}
}

bool p3_55::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_55::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_55::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_4_3398729
bool p3_55::isEnabledV2_inTRp3_4_3398729(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Enabling Test for Signal: V2_inTRp3_26_3398774
bool p3_55::isEnabledV2_inTRp3_26_3398774(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_4_3398729
std::vector<int> p3_55::V2_inTRp3_4_3398729(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_4_3398729");
							smc->event_status_msg.push_back(" <!> State Update: p3_55 => p3_56");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_4_3398729"<<std::endl;
							// std::cout<<" <!> State Update: From p3_55 => p3_56"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_55 => p3_56");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_4_3398729 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Signal Context NI Validator: V2_inTRp3_26_3398774
std::vector<int> p3_55::V2_inTRp3_26_3398774(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_26_3398774");
							smc->event_status_msg.push_back(" <!> State Update: p3_55 => p7_1");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_26_3398774"<<std::endl;
							// std::cout<<" <!> State Update: From p3_55 => p7_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_55 => p7_1");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_26_3398774 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_4_3398729
void p3_55::V2_inTRp3_4_3398729(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_4_3398729");
							smc->event_status_msg.push_back(" <!> State Update: p3_55 => p3_56");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_4_3398729"<<std::endl;
							std::cout<<" <!> State Update: From p3_55 => p3_56"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_55 => p3_56");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_56());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_4_3398729 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Deterministic Signal Handler: V2_inTRp3_26_3398774
void p3_55::V2_inTRp3_26_3398774(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_26_3398774");
							smc->event_status_msg.push_back(" <!> State Update: p3_55 => p7_1");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_26_3398774"<<std::endl;
							std::cout<<" <!> State Update: From p3_55 => p7_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_55 => p7_1");
							smc->setTextColor("ANY");
							smc->setCurrent(new p7_1());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_26_3398774 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_4_3398729
void p3_55::V2_inTRp3_4_3398729(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_4_3398729");
				smc->event_status_msg.push_back(" <!> State Update: p3_55 => p3_56");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_4_3398729"<<std::endl;
				std::cout<<" <!> State Update: From p3_55 => p3_56"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_55 => p3_56");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_56());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_4_3398729 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_26_3398774
void p3_55::V2_inTRp3_26_3398774(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_26_3398774");
				smc->event_status_msg.push_back(" <!> State Update: p3_55 => p7_1");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_26_3398774"<<std::endl;
				std::cout<<" <!> State Update: From p3_55 => p7_1"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_55 => p7_1");
				smc->setTextColor("ANY");
				smc->setCurrent(new p7_1());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_26_3398774 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_55!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_13 ***********/

list<string> p1_13::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_13::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_10_3398849");
	return retStr;
}
		
list<string> p1_13::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_13::getCurrentState() { return name; }

list<string> p1_13::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_13::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_10_3398849
	{
	list_of_enabled_signals.push_back("V2_inTRp1_10_3398849");
	}
	return list_of_enabled_signals;
}

void p1_13::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_10_3398849"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_10_3398849();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_10_3398849( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_10_3398849( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_10_3398849"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_10_3398849" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_10_3398849(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_10_3398849" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_10_3398849( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_10_3398849 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_10_3398849(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_10_3398849(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_10_3398849(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_10_3398849 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_10_3398849 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_10_3398849" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_10_3398849( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_10_3398849 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_13"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_13", NO_ENABLED_GUARDS));
	}
}

bool p1_13::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_13::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_13::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_10_3398849
bool p1_13::isEnabledV2_inTRp1_10_3398849(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_10_3398849
std::vector<int> p1_13::V2_inTRp1_10_3398849(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_10_3398849");
							smc->event_status_msg.push_back(" <!> State Update: p1_13 => p1_14");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_10_3398849"<<std::endl;
							// std::cout<<" <!> State Update: From p1_13 => p1_14"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_13 => p1_14");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_10_3398849 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_13!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_10_3398849
void p1_13::V2_inTRp1_10_3398849(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_10_3398849");
							smc->event_status_msg.push_back(" <!> State Update: p1_13 => p1_14");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_10_3398849"<<std::endl;
							std::cout<<" <!> State Update: From p1_13 => p1_14"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_13 => p1_14");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_14());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_10_3398849 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_13!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_10_3398849
void p1_13::V2_inTRp1_10_3398849(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_10_3398849");
				smc->event_status_msg.push_back(" <!> State Update: p1_13 => p1_14");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_10_3398849"<<std::endl;
				std::cout<<" <!> State Update: From p1_13 => p1_14"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_13 => p1_14");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_14());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_10_3398849 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_13!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p4_1 ***********/

list<string> p4_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p4_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp4_1_3398876");
	retStr.push_back("V2_inTRp4_1_3398838");
	return retStr;
}
		
list<string> p4_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p4_1::getCurrentState() { return name; }

list<string> p4_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p4_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp4_1_3398876
	{
	list_of_enabled_signals.push_back("V2_inTRp4_1_3398876");
	}
	// Signal Name: V2_inTRp4_1_3398838
	{
	list_of_enabled_signals.push_back("V2_inTRp4_1_3398838");
	}
	return list_of_enabled_signals;
}

void p4_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp4_1_3398876"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp4_1_3398876();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp4_1_3398876( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp4_1_3398876( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		if(!(*it).compare("V2_inTRp4_1_3398838"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp4_1_3398838();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp4_1_3398838( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp4_1_3398838( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp4_1_3398876"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp4_1_3398876" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp4_1_3398876(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp4_1_3398876" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp4_1_3398876( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp4_1_3398876 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp4_1_3398876(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp4_1_3398876(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp4_1_3398876(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp4_1_3398876 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp4_1_3398876 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp4_1_3398876" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp4_1_3398876( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp4_1_3398876 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		if(!(*it).compare("V2_inTRp4_1_3398838"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp4_1_3398838" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp4_1_3398838(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp4_1_3398838" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp4_1_3398838( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp4_1_3398838 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp4_1_3398838(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp4_1_3398838(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp4_1_3398838(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp4_1_3398838 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp4_1_3398838 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp4_1_3398838" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp4_1_3398838( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp4_1_3398838 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p4_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p4_1", NO_ENABLED_GUARDS));
	}
}

bool p4_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p4_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p4_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp4_1_3398876
bool p4_1::isEnabledV2_inTRp4_1_3398876(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Enabling Test for Signal: V2_inTRp4_1_3398838
bool p4_1::isEnabledV2_inTRp4_1_3398838(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp4_1_3398876
std::vector<int> p4_1::V2_inTRp4_1_3398876(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp4_1_3398876");
							smc->event_status_msg.push_back(" <!> State Update: p4_1 => p19_1");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp4_1_3398876"<<std::endl;
							// std::cout<<" <!> State Update: From p4_1 => p19_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p4_1 => p19_1");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp4_1_3398876 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Signal Context NI Validator: V2_inTRp4_1_3398838
std::vector<int> p4_1::V2_inTRp4_1_3398838(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp4_1_3398838");
							smc->event_status_msg.push_back(" <!> State Update: p4_1 => p4_2");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp4_1_3398838"<<std::endl;
							// std::cout<<" <!> State Update: From p4_1 => p4_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p4_1 => p4_2");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp4_1_3398838 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp4_1_3398876
void p4_1::V2_inTRp4_1_3398876(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp4_1_3398876");
							smc->event_status_msg.push_back(" <!> State Update: p4_1 => p19_1");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp4_1_3398876"<<std::endl;
							std::cout<<" <!> State Update: From p4_1 => p19_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p4_1 => p19_1");
							smc->setTextColor("ANY");
							smc->setCurrent(new p19_1());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp4_1_3398876 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Deterministic Signal Handler: V2_inTRp4_1_3398838
void p4_1::V2_inTRp4_1_3398838(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp4_1_3398838");
							smc->event_status_msg.push_back(" <!> State Update: p4_1 => p4_2");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp4_1_3398838"<<std::endl;
							std::cout<<" <!> State Update: From p4_1 => p4_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p4_1 => p4_2");
							smc->setTextColor("ANY");
							smc->setCurrent(new p4_2());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp4_1_3398838 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp4_1_3398876
void p4_1::V2_inTRp4_1_3398876(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp4_1_3398876");
				smc->event_status_msg.push_back(" <!> State Update: p4_1 => p19_1");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp4_1_3398876"<<std::endl;
				std::cout<<" <!> State Update: From p4_1 => p19_1"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p4_1 => p19_1");
				smc->setTextColor("ANY");
				smc->setCurrent(new p19_1());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp4_1_3398876 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp4_1_3398838
void p4_1::V2_inTRp4_1_3398838(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp4_1_3398838");
				smc->event_status_msg.push_back(" <!> State Update: p4_1 => p4_2");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp4_1_3398838"<<std::endl;
				std::cout<<" <!> State Update: From p4_1 => p4_2"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p4_1 => p4_2");
				smc->setTextColor("ANY");
				smc->setCurrent(new p4_2());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp4_1_3398838 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_1!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p5_1 ***********/

list<string> p5_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p5_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp5_1_3398776");
	return retStr;
}
		
list<string> p5_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p5_1::getCurrentState() { return name; }

list<string> p5_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p5_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp5_1_3398776
	{
	list_of_enabled_signals.push_back("V2_inTRp5_1_3398776");
	}
	return list_of_enabled_signals;
}

void p5_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp5_1_3398776"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp5_1_3398776();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp5_1_3398776( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp5_1_3398776( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp5_1_3398776"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp5_1_3398776" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp5_1_3398776(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp5_1_3398776" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp5_1_3398776( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp5_1_3398776 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp5_1_3398776(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp5_1_3398776(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp5_1_3398776(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp5_1_3398776 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp5_1_3398776 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp5_1_3398776" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp5_1_3398776( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp5_1_3398776 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p5_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p5_1", NO_ENABLED_GUARDS));
	}
}

bool p5_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p5_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p5_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp5_1_3398776
bool p5_1::isEnabledV2_inTRp5_1_3398776(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp5_1_3398776
std::vector<int> p5_1::V2_inTRp5_1_3398776(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp5_1_3398776");
							smc->event_status_msg.push_back(" <!> State Update: p5_1 => p5_2");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp5_1_3398776"<<std::endl;
							// std::cout<<" <!> State Update: From p5_1 => p5_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p5_1 => p5_2");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp5_1_3398776 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_1!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp5_1_3398776
void p5_1::V2_inTRp5_1_3398776(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp5_1_3398776");
							smc->event_status_msg.push_back(" <!> State Update: p5_1 => p5_2");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp5_1_3398776"<<std::endl;
							std::cout<<" <!> State Update: From p5_1 => p5_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p5_1 => p5_2");
							smc->setTextColor("ANY");
							smc->setCurrent(new p5_2());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp5_1_3398776 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp5_1_3398776
void p5_1::V2_inTRp5_1_3398776(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp5_1_3398776");
				smc->event_status_msg.push_back(" <!> State Update: p5_1 => p5_2");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp5_1_3398776"<<std::endl;
				std::cout<<" <!> State Update: From p5_1 => p5_2"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p5_1 => p5_2");
				smc->setTextColor("ANY");
				smc->setCurrent(new p5_2());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp5_1_3398776 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_1!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_26 ***********/

list<string> p1_26::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_26::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_5_3398755");
	return retStr;
}
		
list<string> p1_26::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_26::getCurrentState() { return name; }

list<string> p1_26::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_26::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_5_3398755
	{
	list_of_enabled_signals.push_back("V2_inTRp1_5_3398755");
	}
	return list_of_enabled_signals;
}

void p1_26::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_5_3398755"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_5_3398755();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_5_3398755( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_5_3398755( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_5_3398755"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_5_3398755" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_5_3398755(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_5_3398755" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_5_3398755( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_5_3398755 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_5_3398755(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_5_3398755(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_5_3398755(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_5_3398755 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_5_3398755 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_5_3398755" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_5_3398755( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_5_3398755 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_26"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_26", NO_ENABLED_GUARDS));
	}
}

bool p1_26::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_26::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_26::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_5_3398755
bool p1_26::isEnabledV2_inTRp1_5_3398755(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_5_3398755
std::vector<int> p1_26::V2_inTRp1_5_3398755(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_5_3398755");
							smc->event_status_msg.push_back(" <!> State Update: p1_26 => p1_27");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_5_3398755"<<std::endl;
							// std::cout<<" <!> State Update: From p1_26 => p1_27"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_26 => p1_27");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_5_3398755 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_26");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_26!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_5_3398755
void p1_26::V2_inTRp1_5_3398755(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_5_3398755");
							smc->event_status_msg.push_back(" <!> State Update: p1_26 => p1_27");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_5_3398755"<<std::endl;
							std::cout<<" <!> State Update: From p1_26 => p1_27"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_26 => p1_27");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_27());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_5_3398755 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_26");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_26!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_5_3398755
void p1_26::V2_inTRp1_5_3398755(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_5_3398755");
				smc->event_status_msg.push_back(" <!> State Update: p1_26 => p1_27");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_5_3398755"<<std::endl;
				std::cout<<" <!> State Update: From p1_26 => p1_27"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_26 => p1_27");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_27());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_5_3398755 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_26");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_26!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_51 ***********/

list<string> p3_51::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_51::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_51::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_40_3398853");
	retStr.push_back("V2_outTRp3_29_3398799");
	retStr.push_back("V2_outTRp3_40_3398855");
	return retStr;
}

string p3_51::getCurrentState() { return name; }

list<string> p3_51::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_51::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_51::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_51"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_51", NO_ENABLED_GUARDS));
	}
}

bool p3_51::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_51::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_51::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true ||   true ||   true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_40_3398853
void p3_51::V2_outTRp3_40_3398853(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_40_3398853 -> Going From p3_51 to p15_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_51 => p15_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_40_3398853");
								smc->event_status_msg.push_back(" <!> State Update: p3_51 => p15_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_40_3398853"<<std::endl;
							std::cout<<" <!> State Update: p3_51 => p15_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p15_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_51");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Deterministic Notification Handler: V2_outTRp3_29_3398799
void p3_51::V2_outTRp3_29_3398799(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_29_3398799 -> Going From p3_51 to p3_52"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_51 => p3_52");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_29_3398799");
								smc->event_status_msg.push_back(" <!> State Update: p3_51 => p3_52");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_29_3398799"<<std::endl;
							std::cout<<" <!> State Update: p3_51 => p3_52"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_52());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_51");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Deterministic Notification Handler: V2_outTRp3_40_3398855
void p3_51::V2_outTRp3_40_3398855(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_40_3398855 -> Going From p3_51 to p16_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_51 => p16_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_40_3398855");
								smc->event_status_msg.push_back(" <!> State Update: p3_51 => p16_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_40_3398855"<<std::endl;
							std::cout<<" <!> State Update: p3_51 => p16_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p16_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_51");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_40_3398853
std::vector<int> p3_51::match_V2_outTRp3_40_3398853(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_40_3398853");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_51");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Validator: V2_outTRp3_29_3398799
std::vector<int> p3_51::match_V2_outTRp3_29_3398799(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_29_3398799");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_51");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Validator: V2_outTRp3_40_3398855
std::vector<int> p3_51::match_V2_outTRp3_40_3398855(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_40_3398855");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_51");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_40_3398853
void p3_51::V2_outTRp3_40_3398853(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_40_3398853 -> Going From p3_51 to p15_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_51 => p15_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_40_3398853");
							smc->event_status_msg.push_back(" <!> State Update: p3_51 => p15_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_40_3398853"<<std::endl;
						std::cout<<" <!> State Update: p3_51 => p15_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p15_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_51");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Handler: V2_outTRp3_29_3398799
void p3_51::V2_outTRp3_29_3398799(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_29_3398799 -> Going From p3_51 to p3_52"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_51 => p3_52");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_29_3398799");
							smc->event_status_msg.push_back(" <!> State Update: p3_51 => p3_52");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_29_3398799"<<std::endl;
						std::cout<<" <!> State Update: p3_51 => p3_52"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_52());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_51");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Handler: V2_outTRp3_40_3398855
void p3_51::V2_outTRp3_40_3398855(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_40_3398855 -> Going From p3_51 to p16_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_51 => p16_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_40_3398855");
							smc->event_status_msg.push_back(" <!> State Update: p3_51 => p16_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_40_3398855"<<std::endl;
						std::cout<<" <!> State Update: p3_51 => p16_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p16_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_51");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_51::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true ||   true ||   true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %3; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_29_3398799");
					smc->event_status_msg.push_back(" <!> State Update: p3_51 => p3_52");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_29_3398799"<<std::endl;
					std::cout<<" <!> State Update: p3_51 => p3_52"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_29_3398799();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_29_3398799");
					if(smc->m_outTRp3_29_3398799_Handler != nullptr)
					{
						smc->m_outTRp3_29_3398799_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_51 => p3_52");
					smc->setCurrent(new p3_52());
					delete this;
					break;
		case 1:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_40_3398853");
					smc->event_status_msg.push_back(" <!> State Update: p3_51 => p15_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_40_3398853"<<std::endl;
					std::cout<<" <!> State Update: p3_51 => p15_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_40_3398853();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_40_3398853");
					if(smc->m_outTRp3_40_3398853_Handler != nullptr)
					{
						smc->m_outTRp3_40_3398853_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_51 => p15_1");
					smc->setCurrent(new p15_1());
					delete this;
					break;
		case 2:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_40_3398855");
					smc->event_status_msg.push_back(" <!> State Update: p3_51 => p16_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_40_3398855"<<std::endl;
					std::cout<<" <!> State Update: p3_51 => p16_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_40_3398855();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_40_3398855");
					if(smc->m_outTRp3_40_3398855_Handler != nullptr)
					{
						smc->m_outTRp3_40_3398855_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_51 => p16_1");
					smc->setCurrent(new p16_1());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_51");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_51!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_50 ***********/

list<string> p3_50::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_50::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_50::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_10_3398748");
	return retStr;
}

string p3_50::getCurrentState() { return name; }

list<string> p3_50::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_50::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_50::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_50"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_50", NO_ENABLED_GUARDS));
	}
}

bool p3_50::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_50::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_50::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_10_3398748
void p3_50::V2_outTRp3_10_3398748(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_10_3398748 -> Going From p3_50 to p3_51"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_50 => p3_51");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_10_3398748");
								smc->event_status_msg.push_back(" <!> State Update: p3_50 => p3_51");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_10_3398748"<<std::endl;
							std::cout<<" <!> State Update: p3_50 => p3_51"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_51());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_50");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_10_3398748
std::vector<int> p3_50::match_V2_outTRp3_10_3398748(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_10_3398748");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_50");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_10_3398748
void p3_50::V2_outTRp3_10_3398748(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_10_3398748 -> Going From p3_50 to p3_51"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_50 => p3_51");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_10_3398748");
							smc->event_status_msg.push_back(" <!> State Update: p3_50 => p3_51");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_10_3398748"<<std::endl;
						std::cout<<" <!> State Update: p3_50 => p3_51"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_51());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_50");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_50::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_10_3398748");
					smc->event_status_msg.push_back(" <!> State Update: p3_50 => p3_51");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_10_3398748"<<std::endl;
					std::cout<<" <!> State Update: p3_50 => p3_51"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_10_3398748();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_10_3398748");
					if(smc->m_outTRp3_10_3398748_Handler != nullptr)
					{
						smc->m_outTRp3_10_3398748_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_50 => p3_51");
					smc->setCurrent(new p3_51());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_50");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_50!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_35 ***********/

list<string> p3_35::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_35::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_18_3398798");
	return retStr;
}
		
list<string> p3_35::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_35::getCurrentState() { return name; }

list<string> p3_35::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_35::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_18_3398798
	{
	list_of_enabled_signals.push_back("V2_inTRp3_18_3398798");
	}
	return list_of_enabled_signals;
}

void p3_35::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_18_3398798"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_18_3398798();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_18_3398798( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_18_3398798( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_18_3398798"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_18_3398798" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_18_3398798(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_18_3398798" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_18_3398798( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_18_3398798 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_18_3398798(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_18_3398798(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_18_3398798(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_18_3398798 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_18_3398798 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_18_3398798" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_18_3398798( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_18_3398798 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_35"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_35", NO_ENABLED_GUARDS));
	}
}

bool p3_35::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_35::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_35::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_18_3398798
bool p3_35::isEnabledV2_inTRp3_18_3398798(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_18_3398798
std::vector<int> p3_35::V2_inTRp3_18_3398798(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_18_3398798");
							smc->event_status_msg.push_back(" <!> State Update: p3_35 => p3_36");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_18_3398798"<<std::endl;
							// std::cout<<" <!> State Update: From p3_35 => p3_36"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_35 => p3_36");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_18_3398798 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_35");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_35!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_18_3398798
void p3_35::V2_inTRp3_18_3398798(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_18_3398798");
							smc->event_status_msg.push_back(" <!> State Update: p3_35 => p3_36");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_18_3398798"<<std::endl;
							std::cout<<" <!> State Update: From p3_35 => p3_36"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_35 => p3_36");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_36());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_18_3398798 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_35");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_35!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_18_3398798
void p3_35::V2_inTRp3_18_3398798(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_18_3398798");
				smc->event_status_msg.push_back(" <!> State Update: p3_35 => p3_36");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_18_3398798"<<std::endl;
				std::cout<<" <!> State Update: From p3_35 => p3_36"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_35 => p3_36");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_36());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_18_3398798 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_35");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_35!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_9 ***********/

list<string> p3_9::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_9::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_5_3398760");
	return retStr;
}
		
list<string> p3_9::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_9::getCurrentState() { return name; }

list<string> p3_9::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_9::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_5_3398760
	{
	list_of_enabled_signals.push_back("V2_inTRp3_5_3398760");
	}
	return list_of_enabled_signals;
}

void p3_9::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_5_3398760"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_5_3398760();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_5_3398760( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_5_3398760( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_5_3398760"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_5_3398760" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_5_3398760(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_5_3398760" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_5_3398760( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_5_3398760 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_5_3398760(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_5_3398760(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_5_3398760(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_5_3398760 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_5_3398760 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_5_3398760" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_5_3398760( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_5_3398760 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_9"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_9", NO_ENABLED_GUARDS));
	}
}

bool p3_9::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_9::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_9::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_5_3398760
bool p3_9::isEnabledV2_inTRp3_5_3398760(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_5_3398760
std::vector<int> p3_9::V2_inTRp3_5_3398760(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_5_3398760");
							smc->event_status_msg.push_back(" <!> State Update: p3_9 => p3_10");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_5_3398760"<<std::endl;
							// std::cout<<" <!> State Update: From p3_9 => p3_10"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_9 => p3_10");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_5_3398760 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_9!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_5_3398760
void p3_9::V2_inTRp3_5_3398760(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_5_3398760");
							smc->event_status_msg.push_back(" <!> State Update: p3_9 => p3_10");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_5_3398760"<<std::endl;
							std::cout<<" <!> State Update: From p3_9 => p3_10"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_9 => p3_10");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_10());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_5_3398760 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_9!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_5_3398760
void p3_9::V2_inTRp3_5_3398760(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_5_3398760");
				smc->event_status_msg.push_back(" <!> State Update: p3_9 => p3_10");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_5_3398760"<<std::endl;
				std::cout<<" <!> State Update: From p3_9 => p3_10"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_9 => p3_10");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_10());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_5_3398760 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_9!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_46 ***********/

list<string> p3_46::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_46::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_46::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_41_3398883");
	return retStr;
}

string p3_46::getCurrentState() { return name; }

list<string> p3_46::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_46::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_46::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_46"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_46", NO_ENABLED_GUARDS));
	}
}

bool p3_46::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_46::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_46::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_41_3398883
void p3_46::V2_outTRp3_41_3398883(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_41_3398883 -> Going From p3_46 to p3_47"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_46 => p3_47");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_41_3398883");
								smc->event_status_msg.push_back(" <!> State Update: p3_46 => p3_47");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_41_3398883"<<std::endl;
							std::cout<<" <!> State Update: p3_46 => p3_47"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_47());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_46");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_41_3398883
std::vector<int> p3_46::match_V2_outTRp3_41_3398883(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_41_3398883");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_46");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_41_3398883
void p3_46::V2_outTRp3_41_3398883(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_41_3398883 -> Going From p3_46 to p3_47"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_46 => p3_47");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_41_3398883");
							smc->event_status_msg.push_back(" <!> State Update: p3_46 => p3_47");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_41_3398883"<<std::endl;
						std::cout<<" <!> State Update: p3_46 => p3_47"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_47());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_46");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_46::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_41_3398883");
					smc->event_status_msg.push_back(" <!> State Update: p3_46 => p3_47");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_41_3398883"<<std::endl;
					std::cout<<" <!> State Update: p3_46 => p3_47"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_41_3398883();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_41_3398883");
					if(smc->m_outTRp3_41_3398883_Handler != nullptr)
					{
						smc->m_outTRp3_41_3398883_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_46 => p3_47");
					smc->setCurrent(new p3_47());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_46");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_46!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_42 ***********/

list<string> p3_42::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_42::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_42::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_29_3398835");
	return retStr;
}

string p3_42::getCurrentState() { return name; }

list<string> p3_42::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_42::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_42::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_42"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_42", NO_ENABLED_GUARDS));
	}
}

bool p3_42::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_42::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_42::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_29_3398835
void p3_42::V2_outTRp3_29_3398835(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_29_3398835 -> Going From p3_42 to p3_43"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_42 => p3_43");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_29_3398835");
								smc->event_status_msg.push_back(" <!> State Update: p3_42 => p3_43");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_29_3398835"<<std::endl;
							std::cout<<" <!> State Update: p3_42 => p3_43"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_43());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_42");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_29_3398835
std::vector<int> p3_42::match_V2_outTRp3_29_3398835(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_29_3398835");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_42");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_29_3398835
void p3_42::V2_outTRp3_29_3398835(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_29_3398835 -> Going From p3_42 to p3_43"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_42 => p3_43");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_29_3398835");
							smc->event_status_msg.push_back(" <!> State Update: p3_42 => p3_43");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_29_3398835"<<std::endl;
						std::cout<<" <!> State Update: p3_42 => p3_43"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_43());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_42");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_42::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_29_3398835");
					smc->event_status_msg.push_back(" <!> State Update: p3_42 => p3_43");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_29_3398835"<<std::endl;
					std::cout<<" <!> State Update: p3_42 => p3_43"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_29_3398835();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_29_3398835");
					if(smc->m_outTRp3_29_3398835_Handler != nullptr)
					{
						smc->m_outTRp3_29_3398835_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_42 => p3_43");
					smc->setCurrent(new p3_43());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_42");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_42!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p2_5 ***********/

list<string> p2_5::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_5::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_3_3398781");
	return retStr;
}
		
list<string> p2_5::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_5::getCurrentState() { return name; }

list<string> p2_5::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_5::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_3_3398781
	{
	list_of_enabled_signals.push_back("V2_inTRp2_3_3398781");
	}
	return list_of_enabled_signals;
}

void p2_5::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_3_3398781"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_3_3398781();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_3_3398781( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_3_3398781( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_3_3398781"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_3_3398781" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_3_3398781(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_3_3398781" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_3_3398781( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_3_3398781 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_3_3398781(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_3_3398781(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_3_3398781(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_3_3398781 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_3_3398781 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_3_3398781" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_3_3398781( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_3_3398781 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_5"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_5", NO_ENABLED_GUARDS));
	}
}

bool p2_5::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_5::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_5::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_3_3398781
bool p2_5::isEnabledV2_inTRp2_3_3398781(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_3_3398781
std::vector<int> p2_5::V2_inTRp2_3_3398781(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_3_3398781");
							smc->event_status_msg.push_back(" <!> State Update: p2_5 => p2_6");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_3_3398781"<<std::endl;
							// std::cout<<" <!> State Update: From p2_5 => p2_6"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_5 => p2_6");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_3_3398781 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_5!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_3_3398781
void p2_5::V2_inTRp2_3_3398781(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_3_3398781");
							smc->event_status_msg.push_back(" <!> State Update: p2_5 => p2_6");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_3_3398781"<<std::endl;
							std::cout<<" <!> State Update: From p2_5 => p2_6"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_5 => p2_6");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_6());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_3_3398781 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_5!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_3_3398781
void p2_5::V2_inTRp2_3_3398781(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_3_3398781");
				smc->event_status_msg.push_back(" <!> State Update: p2_5 => p2_6");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_3_3398781"<<std::endl;
				std::cout<<" <!> State Update: From p2_5 => p2_6"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_5 => p2_6");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_6());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_3_3398781 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_5!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p2_11 ***********/

list<string> p2_11::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_11::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_2_3398739");
	return retStr;
}
		
list<string> p2_11::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_11::getCurrentState() { return name; }

list<string> p2_11::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_11::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_2_3398739
	{
	list_of_enabled_signals.push_back("V2_inTRp2_2_3398739");
	}
	return list_of_enabled_signals;
}

void p2_11::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_2_3398739"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_2_3398739();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_2_3398739( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_2_3398739( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_2_3398739"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_2_3398739" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_2_3398739(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_2_3398739" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_2_3398739( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_2_3398739 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_2_3398739(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_2_3398739(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_2_3398739(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_2_3398739 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_2_3398739 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_2_3398739" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_2_3398739( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_2_3398739 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_11"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_11", NO_ENABLED_GUARDS));
	}
}

bool p2_11::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_11::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_11::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_2_3398739
bool p2_11::isEnabledV2_inTRp2_2_3398739(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_2_3398739
std::vector<int> p2_11::V2_inTRp2_2_3398739(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_2_3398739");
							smc->event_status_msg.push_back(" <!> State Update: p2_11 => p2_12");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_2_3398739"<<std::endl;
							// std::cout<<" <!> State Update: From p2_11 => p2_12"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_11 => p2_12");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_2_3398739 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_11!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_2_3398739
void p2_11::V2_inTRp2_2_3398739(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_2_3398739");
							smc->event_status_msg.push_back(" <!> State Update: p2_11 => p2_12");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_2_3398739"<<std::endl;
							std::cout<<" <!> State Update: From p2_11 => p2_12"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_11 => p2_12");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_12());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_2_3398739 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_11!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_2_3398739
void p2_11::V2_inTRp2_2_3398739(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_2_3398739");
				smc->event_status_msg.push_back(" <!> State Update: p2_11 => p2_12");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_2_3398739"<<std::endl;
				std::cout<<" <!> State Update: From p2_11 => p2_12"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_11 => p2_12");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_12());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_2_3398739 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_11!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_31 ***********/

list<string> p1_31::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_31::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_31::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_21_3398832");
	return retStr;
}

string p1_31::getCurrentState() { return name; }

list<string> p1_31::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_31::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_31::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_31"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_31", NO_ENABLED_GUARDS));
	}
}

bool p1_31::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_31::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_31::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_21_3398832
void p1_31::V2_outTRp1_21_3398832(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_21_3398832 -> Going From p1_31 to p1_32"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_31 => p1_32");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_21_3398832");
								smc->event_status_msg.push_back(" <!> State Update: p1_31 => p1_32");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_21_3398832"<<std::endl;
							std::cout<<" <!> State Update: p1_31 => p1_32"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_32());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_31");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_21_3398832
std::vector<int> p1_31::match_V2_outTRp1_21_3398832(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_21_3398832");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_31");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_21_3398832
void p1_31::V2_outTRp1_21_3398832(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_21_3398832 -> Going From p1_31 to p1_32"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_31 => p1_32");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_21_3398832");
							smc->event_status_msg.push_back(" <!> State Update: p1_31 => p1_32");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_21_3398832"<<std::endl;
						std::cout<<" <!> State Update: p1_31 => p1_32"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_32());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_31");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_31::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_21_3398832");
					smc->event_status_msg.push_back(" <!> State Update: p1_31 => p1_32");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_21_3398832"<<std::endl;
					std::cout<<" <!> State Update: p1_31 => p1_32"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_21_3398832();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_21_3398832");
					if(smc->m_outTRp1_21_3398832_Handler != nullptr)
					{
						smc->m_outTRp1_21_3398832_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_31 => p1_32");
					smc->setCurrent(new p1_32());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_31");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_31!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_27 ***********/

list<string> p1_27::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_27::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_24_3398861");
	return retStr;
}
		
list<string> p1_27::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_27::getCurrentState() { return name; }

list<string> p1_27::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_27::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_24_3398861
	{
	list_of_enabled_signals.push_back("V2_inTRp1_24_3398861");
	}
	return list_of_enabled_signals;
}

void p1_27::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_24_3398861"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_24_3398861();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_24_3398861( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_24_3398861( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_24_3398861"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_24_3398861" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_24_3398861(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_24_3398861" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_24_3398861( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_24_3398861 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_24_3398861(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_24_3398861(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_24_3398861(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_24_3398861 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_24_3398861 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_24_3398861" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_24_3398861( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_24_3398861 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_27"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_27", NO_ENABLED_GUARDS));
	}
}

bool p1_27::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_27::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_27::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_24_3398861
bool p1_27::isEnabledV2_inTRp1_24_3398861(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_24_3398861
std::vector<int> p1_27::V2_inTRp1_24_3398861(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_24_3398861");
							smc->event_status_msg.push_back(" <!> State Update: p1_27 => p1_28");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_24_3398861"<<std::endl;
							// std::cout<<" <!> State Update: From p1_27 => p1_28"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_27 => p1_28");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_24_3398861 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_27");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_27!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_24_3398861
void p1_27::V2_inTRp1_24_3398861(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_24_3398861");
							smc->event_status_msg.push_back(" <!> State Update: p1_27 => p1_28");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_24_3398861"<<std::endl;
							std::cout<<" <!> State Update: From p1_27 => p1_28"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_27 => p1_28");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_28());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_24_3398861 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_27");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_27!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_24_3398861
void p1_27::V2_inTRp1_24_3398861(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_24_3398861");
				smc->event_status_msg.push_back(" <!> State Update: p1_27 => p1_28");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_24_3398861"<<std::endl;
				std::cout<<" <!> State Update: From p1_27 => p1_28"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_27 => p1_28");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_28());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_24_3398861 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_27");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_27!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p2_4 ***********/

list<string> p2_4::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_4::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_1_3398753");
	return retStr;
}
		
list<string> p2_4::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_4::getCurrentState() { return name; }

list<string> p2_4::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_4::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_1_3398753
	{
	list_of_enabled_signals.push_back("V2_inTRp2_1_3398753");
	}
	return list_of_enabled_signals;
}

void p2_4::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_1_3398753"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_1_3398753();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_1_3398753( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_1_3398753( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_1_3398753"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_1_3398753" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_1_3398753(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_1_3398753" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_1_3398753( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_1_3398753 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_1_3398753(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_1_3398753(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_1_3398753(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_1_3398753 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_1_3398753 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_1_3398753" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_1_3398753( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_1_3398753 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_4"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_4", NO_ENABLED_GUARDS));
	}
}

bool p2_4::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_4::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_4::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_1_3398753
bool p2_4::isEnabledV2_inTRp2_1_3398753(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_1_3398753
std::vector<int> p2_4::V2_inTRp2_1_3398753(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398753");
							smc->event_status_msg.push_back(" <!> State Update: p2_4 => p2_5");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398753"<<std::endl;
							// std::cout<<" <!> State Update: From p2_4 => p2_5"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_4 => p2_5");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398753 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_4!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_1_3398753
void p2_4::V2_inTRp2_1_3398753(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398753");
							smc->event_status_msg.push_back(" <!> State Update: p2_4 => p2_5");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398753"<<std::endl;
							std::cout<<" <!> State Update: From p2_4 => p2_5"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_4 => p2_5");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_5());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398753 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_4!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_1_3398753
void p2_4::V2_inTRp2_1_3398753(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398753");
				smc->event_status_msg.push_back(" <!> State Update: p2_4 => p2_5");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398753"<<std::endl;
				std::cout<<" <!> State Update: From p2_4 => p2_5"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_4 => p2_5");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_5());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398753 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_4!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_20 ***********/

list<string> p1_20::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_20::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_9_3398808");
	return retStr;
}
		
list<string> p1_20::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_20::getCurrentState() { return name; }

list<string> p1_20::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_20::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_9_3398808
	{
	list_of_enabled_signals.push_back("V2_inTRp1_9_3398808");
	}
	return list_of_enabled_signals;
}

void p1_20::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_9_3398808"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_9_3398808();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_9_3398808( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_9_3398808( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_9_3398808"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_9_3398808" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_9_3398808(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_9_3398808" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_9_3398808( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_9_3398808 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_9_3398808(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_9_3398808(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_9_3398808(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_9_3398808 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_9_3398808 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_9_3398808" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_9_3398808( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_9_3398808 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_20"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_20", NO_ENABLED_GUARDS));
	}
}

bool p1_20::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_20::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_20::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_9_3398808
bool p1_20::isEnabledV2_inTRp1_9_3398808(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_9_3398808
std::vector<int> p1_20::V2_inTRp1_9_3398808(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_9_3398808");
							smc->event_status_msg.push_back(" <!> State Update: p1_20 => p1_21");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_9_3398808"<<std::endl;
							// std::cout<<" <!> State Update: From p1_20 => p1_21"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_20 => p1_21");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_9_3398808 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_20");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_20!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_9_3398808
void p1_20::V2_inTRp1_9_3398808(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_9_3398808");
							smc->event_status_msg.push_back(" <!> State Update: p1_20 => p1_21");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_9_3398808"<<std::endl;
							std::cout<<" <!> State Update: From p1_20 => p1_21"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_20 => p1_21");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_21());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_9_3398808 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_20");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_20!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_9_3398808
void p1_20::V2_inTRp1_9_3398808(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_9_3398808");
				smc->event_status_msg.push_back(" <!> State Update: p1_20 => p1_21");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_9_3398808"<<std::endl;
				std::cout<<" <!> State Update: From p1_20 => p1_21"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_20 => p1_21");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_21());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_9_3398808 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_20");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_20!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_15 ***********/

list<string> p1_15::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_15::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_15::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_9_3398815");
	return retStr;
}

string p1_15::getCurrentState() { return name; }

list<string> p1_15::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_15::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_15::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_15"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_15", NO_ENABLED_GUARDS));
	}
}

bool p1_15::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_15::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_15::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_9_3398815
void p1_15::V2_outTRp1_9_3398815(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_9_3398815 -> Going From p1_15 to p1_16"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_15 => p1_16");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_9_3398815");
								smc->event_status_msg.push_back(" <!> State Update: p1_15 => p1_16");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_9_3398815"<<std::endl;
							std::cout<<" <!> State Update: p1_15 => p1_16"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_16());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_9_3398815
std::vector<int> p1_15::match_V2_outTRp1_9_3398815(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_9_3398815");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_9_3398815
void p1_15::V2_outTRp1_9_3398815(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_9_3398815 -> Going From p1_15 to p1_16"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_15 => p1_16");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_9_3398815");
							smc->event_status_msg.push_back(" <!> State Update: p1_15 => p1_16");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_9_3398815"<<std::endl;
						std::cout<<" <!> State Update: p1_15 => p1_16"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_16());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_15::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_9_3398815");
					smc->event_status_msg.push_back(" <!> State Update: p1_15 => p1_16");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_9_3398815"<<std::endl;
					std::cout<<" <!> State Update: p1_15 => p1_16"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_9_3398815();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_9_3398815");
					if(smc->m_outTRp1_9_3398815_Handler != nullptr)
					{
						smc->m_outTRp1_9_3398815_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_15 => p1_16");
					smc->setCurrent(new p1_16());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_15!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_14 ***********/

list<string> p3_14::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_14::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_14::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_13_3398852");
	return retStr;
}

string p3_14::getCurrentState() { return name; }

list<string> p3_14::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_14::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_14::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_14"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_14", NO_ENABLED_GUARDS));
	}
}

bool p3_14::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_14::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_14::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_13_3398852
void p3_14::V2_outTRp3_13_3398852(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_13_3398852 -> Going From p3_14 to p3_15"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_14 => p3_15");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_13_3398852");
								smc->event_status_msg.push_back(" <!> State Update: p3_14 => p3_15");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_13_3398852"<<std::endl;
							std::cout<<" <!> State Update: p3_14 => p3_15"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_15());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_13_3398852
std::vector<int> p3_14::match_V2_outTRp3_13_3398852(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_13_3398852");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_13_3398852
void p3_14::V2_outTRp3_13_3398852(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_13_3398852 -> Going From p3_14 to p3_15"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_14 => p3_15");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_13_3398852");
							smc->event_status_msg.push_back(" <!> State Update: p3_14 => p3_15");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_13_3398852"<<std::endl;
						std::cout<<" <!> State Update: p3_14 => p3_15"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_15());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_14::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_13_3398852");
					smc->event_status_msg.push_back(" <!> State Update: p3_14 => p3_15");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_13_3398852"<<std::endl;
					std::cout<<" <!> State Update: p3_14 => p3_15"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_13_3398852();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_13_3398852");
					if(smc->m_outTRp3_13_3398852_Handler != nullptr)
					{
						smc->m_outTRp3_13_3398852_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_14 => p3_15");
					smc->setCurrent(new p3_15());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_14!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_10 ***********/

list<string> p3_10::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_10::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_10::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_10_3398867");
	return retStr;
}

string p3_10::getCurrentState() { return name; }

list<string> p3_10::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_10::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_10::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_10"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_10", NO_ENABLED_GUARDS));
	}
}

bool p3_10::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_10::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_10::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_10_3398867
void p3_10::V2_outTRp3_10_3398867(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_10_3398867 -> Going From p3_10 to p3_11"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_10 => p3_11");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_10_3398867");
								smc->event_status_msg.push_back(" <!> State Update: p3_10 => p3_11");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_10_3398867"<<std::endl;
							std::cout<<" <!> State Update: p3_10 => p3_11"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_11());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_10_3398867
std::vector<int> p3_10::match_V2_outTRp3_10_3398867(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_10_3398867");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_10_3398867
void p3_10::V2_outTRp3_10_3398867(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_10_3398867 -> Going From p3_10 to p3_11"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_10 => p3_11");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_10_3398867");
							smc->event_status_msg.push_back(" <!> State Update: p3_10 => p3_11");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_10_3398867"<<std::endl;
						std::cout<<" <!> State Update: p3_10 => p3_11"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_11());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_10::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_10_3398867");
					smc->event_status_msg.push_back(" <!> State Update: p3_10 => p3_11");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_10_3398867"<<std::endl;
					std::cout<<" <!> State Update: p3_10 => p3_11"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_10_3398867();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_10_3398867");
					if(smc->m_outTRp3_10_3398867_Handler != nullptr)
					{
						smc->m_outTRp3_10_3398867_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_10 => p3_11");
					smc->setCurrent(new p3_11());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_10!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p2_15 ***********/

list<string> p2_15::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_15::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p2_15::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp2_3_3398740");
	return retStr;
}

string p2_15::getCurrentState() { return name; }

list<string> p2_15::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_15::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p2_15::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_15"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_15", NO_ENABLED_GUARDS));
	}
}

bool p2_15::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_15::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_15::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp2_3_3398740
void p2_15::V2_outTRp2_3_3398740(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp2_3_3398740 -> Going From p2_15 to p2_16"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_15 => p2_16");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_3_3398740");
								smc->event_status_msg.push_back(" <!> State Update: p2_15 => p2_16");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_3_3398740"<<std::endl;
							std::cout<<" <!> State Update: p2_15 => p2_16"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_16());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp2_3_3398740
std::vector<int> p2_15::match_V2_outTRp2_3_3398740(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp2_3_3398740");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp2_3_3398740
void p2_15::V2_outTRp2_3_3398740(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp2_3_3398740 -> Going From p2_15 to p2_16"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p2_15 => p2_16");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_3_3398740");
							smc->event_status_msg.push_back(" <!> State Update: p2_15 => p2_16");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_3_3398740"<<std::endl;
						std::cout<<" <!> State Update: p2_15 => p2_16"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p2_16());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p2_15::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_3_3398740");
					smc->event_status_msg.push_back(" <!> State Update: p2_15 => p2_16");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_3_3398740"<<std::endl;
					std::cout<<" <!> State Update: p2_15 => p2_16"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp2_3_3398740();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp2_3_3398740");
					if(smc->m_outTRp2_3_3398740_Handler != nullptr)
					{
						smc->m_outTRp2_3_3398740_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p2_15 => p2_16");
					smc->setCurrent(new p2_16());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_15!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_8 ***********/

list<string> p3_8::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_8::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_4_3398750");
	return retStr;
}
		
list<string> p3_8::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_8::getCurrentState() { return name; }

list<string> p3_8::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_8::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_4_3398750
	{
	list_of_enabled_signals.push_back("V2_inTRp3_4_3398750");
	}
	return list_of_enabled_signals;
}

void p3_8::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_4_3398750"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_4_3398750();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_4_3398750( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_4_3398750( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_4_3398750"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_4_3398750" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_4_3398750(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_4_3398750" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_4_3398750( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_4_3398750 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_4_3398750(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_4_3398750(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_4_3398750(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_4_3398750 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_4_3398750 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_4_3398750" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_4_3398750( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_4_3398750 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_8"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_8", NO_ENABLED_GUARDS));
	}
}

bool p3_8::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_8::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_8::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_4_3398750
bool p3_8::isEnabledV2_inTRp3_4_3398750(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_4_3398750
std::vector<int> p3_8::V2_inTRp3_4_3398750(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_4_3398750");
							smc->event_status_msg.push_back(" <!> State Update: p3_8 => p3_9");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_4_3398750"<<std::endl;
							// std::cout<<" <!> State Update: From p3_8 => p3_9"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_8 => p3_9");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_4_3398750 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_8");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_8!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_4_3398750
void p3_8::V2_inTRp3_4_3398750(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_4_3398750");
							smc->event_status_msg.push_back(" <!> State Update: p3_8 => p3_9");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_4_3398750"<<std::endl;
							std::cout<<" <!> State Update: From p3_8 => p3_9"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_8 => p3_9");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_9());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_4_3398750 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_8");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_8!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_4_3398750
void p3_8::V2_inTRp3_4_3398750(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_4_3398750");
				smc->event_status_msg.push_back(" <!> State Update: p3_8 => p3_9");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_4_3398750"<<std::endl;
				std::cout<<" <!> State Update: From p3_8 => p3_9"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_8 => p3_9");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_9());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_4_3398750 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_8");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_8!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_40 ***********/

list<string> p3_40::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_40::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_40::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_36_3398884");
	return retStr;
}

string p3_40::getCurrentState() { return name; }

list<string> p3_40::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_40::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_40::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_40"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_40", NO_ENABLED_GUARDS));
	}
}

bool p3_40::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_40::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_40::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_36_3398884
void p3_40::V2_outTRp3_36_3398884(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_36_3398884 -> Going From p3_40 to p3_41"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_40 => p3_41");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_36_3398884");
								smc->event_status_msg.push_back(" <!> State Update: p3_40 => p3_41");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_36_3398884"<<std::endl;
							std::cout<<" <!> State Update: p3_40 => p3_41"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_41());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_40");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_36_3398884
std::vector<int> p3_40::match_V2_outTRp3_36_3398884(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_36_3398884");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_40");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_36_3398884
void p3_40::V2_outTRp3_36_3398884(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_36_3398884 -> Going From p3_40 to p3_41"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_40 => p3_41");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_36_3398884");
							smc->event_status_msg.push_back(" <!> State Update: p3_40 => p3_41");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_36_3398884"<<std::endl;
						std::cout<<" <!> State Update: p3_40 => p3_41"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_41());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_40");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_40::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_36_3398884");
					smc->event_status_msg.push_back(" <!> State Update: p3_40 => p3_41");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_36_3398884"<<std::endl;
					std::cout<<" <!> State Update: p3_40 => p3_41"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_36_3398884();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_36_3398884");
					if(smc->m_outTRp3_36_3398884_Handler != nullptr)
					{
						smc->m_outTRp3_36_3398884_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_40 => p3_41");
					smc->setCurrent(new p3_41());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_40");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_40!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_39 ***********/

list<string> p3_39::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_39::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_12_3398765");
	return retStr;
}
		
list<string> p3_39::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_39::getCurrentState() { return name; }

list<string> p3_39::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_39::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_12_3398765
	{
	list_of_enabled_signals.push_back("V2_inTRp3_12_3398765");
	}
	return list_of_enabled_signals;
}

void p3_39::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_12_3398765"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_12_3398765();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_12_3398765( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_12_3398765( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_12_3398765"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_12_3398765" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_12_3398765(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_12_3398765" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_12_3398765( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_12_3398765 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_12_3398765(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_12_3398765(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_12_3398765(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_12_3398765 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_12_3398765 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_12_3398765" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_12_3398765( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_12_3398765 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_39"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_39", NO_ENABLED_GUARDS));
	}
}

bool p3_39::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_39::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_39::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_12_3398765
bool p3_39::isEnabledV2_inTRp3_12_3398765(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_12_3398765
std::vector<int> p3_39::V2_inTRp3_12_3398765(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_12_3398765");
							smc->event_status_msg.push_back(" <!> State Update: p3_39 => p3_40");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_12_3398765"<<std::endl;
							// std::cout<<" <!> State Update: From p3_39 => p3_40"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_39 => p3_40");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_12_3398765 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_39");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_39!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_12_3398765
void p3_39::V2_inTRp3_12_3398765(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_12_3398765");
							smc->event_status_msg.push_back(" <!> State Update: p3_39 => p3_40");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_12_3398765"<<std::endl;
							std::cout<<" <!> State Update: From p3_39 => p3_40"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_39 => p3_40");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_40());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_12_3398765 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_39");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_39!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_12_3398765
void p3_39::V2_inTRp3_12_3398765(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_12_3398765");
				smc->event_status_msg.push_back(" <!> State Update: p3_39 => p3_40");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_12_3398765"<<std::endl;
				std::cout<<" <!> State Update: From p3_39 => p3_40"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_39 => p3_40");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_40());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_12_3398765 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_39");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_39!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_17 ***********/

list<string> p3_17::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_17::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_9_3398768");
	return retStr;
}
		
list<string> p3_17::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_17::getCurrentState() { return name; }

list<string> p3_17::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_17::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_9_3398768
	{
	list_of_enabled_signals.push_back("V2_inTRp3_9_3398768");
	}
	return list_of_enabled_signals;
}

void p3_17::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_9_3398768"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_9_3398768();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_9_3398768( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_9_3398768( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_9_3398768"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_9_3398768" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_9_3398768(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_9_3398768" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_9_3398768( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_9_3398768 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_9_3398768(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_9_3398768(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_9_3398768(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_9_3398768 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_9_3398768 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_9_3398768" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_9_3398768( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_9_3398768 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_17"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_17", NO_ENABLED_GUARDS));
	}
}

bool p3_17::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_17::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_17::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_9_3398768
bool p3_17::isEnabledV2_inTRp3_9_3398768(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_9_3398768
std::vector<int> p3_17::V2_inTRp3_9_3398768(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_9_3398768");
							smc->event_status_msg.push_back(" <!> State Update: p3_17 => p3_18");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_9_3398768"<<std::endl;
							// std::cout<<" <!> State Update: From p3_17 => p3_18"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_17 => p3_18");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_9_3398768 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_17!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_9_3398768
void p3_17::V2_inTRp3_9_3398768(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_9_3398768");
							smc->event_status_msg.push_back(" <!> State Update: p3_17 => p3_18");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_9_3398768"<<std::endl;
							std::cout<<" <!> State Update: From p3_17 => p3_18"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_17 => p3_18");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_18());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_9_3398768 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_17!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_9_3398768
void p3_17::V2_inTRp3_9_3398768(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_9_3398768");
				smc->event_status_msg.push_back(" <!> State Update: p3_17 => p3_18");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_9_3398768"<<std::endl;
				std::cout<<" <!> State Update: From p3_17 => p3_18"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_17 => p3_18");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_18());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_9_3398768 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_17!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_30 ***********/

list<string> p1_30::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_30::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_30::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_6_3398756");
	return retStr;
}

string p1_30::getCurrentState() { return name; }

list<string> p1_30::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_30::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_30::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_30"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_30", NO_ENABLED_GUARDS));
	}
}

bool p1_30::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_30::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_30::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_6_3398756
void p1_30::V2_outTRp1_6_3398756(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_6_3398756 -> Going From p1_30 to p1_31"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_30 => p1_31");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_6_3398756");
								smc->event_status_msg.push_back(" <!> State Update: p1_30 => p1_31");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_6_3398756"<<std::endl;
							std::cout<<" <!> State Update: p1_30 => p1_31"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_31());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_30");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_6_3398756
std::vector<int> p1_30::match_V2_outTRp1_6_3398756(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_6_3398756");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_30");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_6_3398756
void p1_30::V2_outTRp1_6_3398756(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_6_3398756 -> Going From p1_30 to p1_31"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_30 => p1_31");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_6_3398756");
							smc->event_status_msg.push_back(" <!> State Update: p1_30 => p1_31");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_6_3398756"<<std::endl;
						std::cout<<" <!> State Update: p1_30 => p1_31"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_31());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_30");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_30::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_6_3398756");
					smc->event_status_msg.push_back(" <!> State Update: p1_30 => p1_31");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_6_3398756"<<std::endl;
					std::cout<<" <!> State Update: p1_30 => p1_31"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_6_3398756();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_6_3398756");
					if(smc->m_outTRp1_6_3398756_Handler != nullptr)
					{
						smc->m_outTRp1_6_3398756_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_30 => p1_31");
					smc->setCurrent(new p1_31());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_30");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_30!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_18 ***********/

list<string> p3_18::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_18::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_18::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_18_3398888");
	return retStr;
}

string p3_18::getCurrentState() { return name; }

list<string> p3_18::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_18::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_18::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_18"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_18", NO_ENABLED_GUARDS));
	}
}

bool p3_18::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_18::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_18::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_18_3398888
void p3_18::V2_outTRp3_18_3398888(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_18_3398888 -> Going From p3_18 to p3_19"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_18 => p3_19");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_18_3398888");
								smc->event_status_msg.push_back(" <!> State Update: p3_18 => p3_19");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_18_3398888"<<std::endl;
							std::cout<<" <!> State Update: p3_18 => p3_19"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_19());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_18");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_18_3398888
std::vector<int> p3_18::match_V2_outTRp3_18_3398888(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_18_3398888");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_18");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_18_3398888
void p3_18::V2_outTRp3_18_3398888(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_18_3398888 -> Going From p3_18 to p3_19"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_18 => p3_19");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_18_3398888");
							smc->event_status_msg.push_back(" <!> State Update: p3_18 => p3_19");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_18_3398888"<<std::endl;
						std::cout<<" <!> State Update: p3_18 => p3_19"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_19());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_18");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_18::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_18_3398888");
					smc->event_status_msg.push_back(" <!> State Update: p3_18 => p3_19");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_18_3398888"<<std::endl;
					std::cout<<" <!> State Update: p3_18 => p3_19"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_18_3398888();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_18_3398888");
					if(smc->m_outTRp3_18_3398888_Handler != nullptr)
					{
						smc->m_outTRp3_18_3398888_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_18 => p3_19");
					smc->setCurrent(new p3_19());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_18");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_18!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_33 ***********/

list<string> p1_33::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_33::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_14_3398785");
	return retStr;
}
		
list<string> p1_33::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_33::getCurrentState() { return name; }

list<string> p1_33::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_33::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_14_3398785
	{
	list_of_enabled_signals.push_back("V2_inTRp1_14_3398785");
	}
	return list_of_enabled_signals;
}

void p1_33::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_14_3398785"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_14_3398785();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_14_3398785( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_14_3398785( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_14_3398785"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_14_3398785" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_14_3398785(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_14_3398785" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_14_3398785( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_14_3398785 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_14_3398785(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_14_3398785(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_14_3398785(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_14_3398785 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_14_3398785 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_14_3398785" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_14_3398785( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_14_3398785 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_33"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_33", NO_ENABLED_GUARDS));
	}
}

bool p1_33::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_33::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_33::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_14_3398785
bool p1_33::isEnabledV2_inTRp1_14_3398785(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_14_3398785
std::vector<int> p1_33::V2_inTRp1_14_3398785(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_14_3398785");
							smc->event_status_msg.push_back(" <!> State Update: p1_33 => p1_34");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_14_3398785"<<std::endl;
							// std::cout<<" <!> State Update: From p1_33 => p1_34"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_33 => p1_34");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_14_3398785 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_33");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_33!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_14_3398785
void p1_33::V2_inTRp1_14_3398785(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_14_3398785");
							smc->event_status_msg.push_back(" <!> State Update: p1_33 => p1_34");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_14_3398785"<<std::endl;
							std::cout<<" <!> State Update: From p1_33 => p1_34"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_33 => p1_34");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_34());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_14_3398785 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_33");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_33!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_14_3398785
void p1_33::V2_inTRp1_14_3398785(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_14_3398785");
				smc->event_status_msg.push_back(" <!> State Update: p1_33 => p1_34");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_14_3398785"<<std::endl;
				std::cout<<" <!> State Update: From p1_33 => p1_34"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_33 => p1_34");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_34());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_14_3398785 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_33");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_33!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_32 ***********/

list<string> p3_32::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_32::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_27_3398865");
	return retStr;
}
		
list<string> p3_32::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_32::getCurrentState() { return name; }

list<string> p3_32::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_32::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_27_3398865
	{
	list_of_enabled_signals.push_back("V2_inTRp3_27_3398865");
	}
	return list_of_enabled_signals;
}

void p3_32::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_27_3398865"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_27_3398865();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_27_3398865( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_27_3398865( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_27_3398865"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_27_3398865" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_27_3398865(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_27_3398865" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_27_3398865( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_27_3398865 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_27_3398865(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_27_3398865(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_27_3398865(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_27_3398865 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_27_3398865 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_27_3398865" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_27_3398865( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_27_3398865 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_32"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_32", NO_ENABLED_GUARDS));
	}
}

bool p3_32::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_32::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_32::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_27_3398865
bool p3_32::isEnabledV2_inTRp3_27_3398865(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_27_3398865
std::vector<int> p3_32::V2_inTRp3_27_3398865(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_27_3398865");
							smc->event_status_msg.push_back(" <!> State Update: p3_32 => p3_33");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_27_3398865"<<std::endl;
							// std::cout<<" <!> State Update: From p3_32 => p3_33"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_32 => p3_33");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_27_3398865 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_32");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_32!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_27_3398865
void p3_32::V2_inTRp3_27_3398865(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_27_3398865");
							smc->event_status_msg.push_back(" <!> State Update: p3_32 => p3_33");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_27_3398865"<<std::endl;
							std::cout<<" <!> State Update: From p3_32 => p3_33"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_32 => p3_33");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_33());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_27_3398865 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_32");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_32!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_27_3398865
void p3_32::V2_inTRp3_27_3398865(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_27_3398865");
				smc->event_status_msg.push_back(" <!> State Update: p3_32 => p3_33");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_27_3398865"<<std::endl;
				std::cout<<" <!> State Update: From p3_32 => p3_33"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_32 => p3_33");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_33());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_27_3398865 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_32");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_32!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_29 ***********/

list<string> p3_29::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_29::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_28_3398878");
	return retStr;
}
		
list<string> p3_29::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_29::getCurrentState() { return name; }

list<string> p3_29::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_29::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_28_3398878
	{
	list_of_enabled_signals.push_back("V2_inTRp3_28_3398878");
	}
	return list_of_enabled_signals;
}

void p3_29::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_28_3398878"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_28_3398878();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_28_3398878( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_28_3398878( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_28_3398878"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_28_3398878" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_28_3398878(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_28_3398878" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_28_3398878( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_28_3398878 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_28_3398878(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_28_3398878(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_28_3398878(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_28_3398878 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_28_3398878 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_28_3398878" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_28_3398878( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_28_3398878 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_29"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_29", NO_ENABLED_GUARDS));
	}
}

bool p3_29::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_29::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_29::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_28_3398878
bool p3_29::isEnabledV2_inTRp3_28_3398878(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_28_3398878
std::vector<int> p3_29::V2_inTRp3_28_3398878(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_28_3398878");
							smc->event_status_msg.push_back(" <!> State Update: p3_29 => p3_30");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_28_3398878"<<std::endl;
							// std::cout<<" <!> State Update: From p3_29 => p3_30"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_29 => p3_30");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_28_3398878 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_29");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_29!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_28_3398878
void p3_29::V2_inTRp3_28_3398878(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_28_3398878");
							smc->event_status_msg.push_back(" <!> State Update: p3_29 => p3_30");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_28_3398878"<<std::endl;
							std::cout<<" <!> State Update: From p3_29 => p3_30"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_29 => p3_30");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_30());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_28_3398878 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_29");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_29!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_28_3398878
void p3_29::V2_inTRp3_28_3398878(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_28_3398878");
				smc->event_status_msg.push_back(" <!> State Update: p3_29 => p3_30");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_28_3398878"<<std::endl;
				std::cout<<" <!> State Update: From p3_29 => p3_30"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_29 => p3_30");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_30());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_28_3398878 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_29");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_29!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p6_1 ***********/

list<string> p6_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p6_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p6_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp6_1_3398773");
	return retStr;
}

string p6_1::getCurrentState() { return name; }

list<string> p6_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p6_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p6_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p6_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p6_1", NO_ENABLED_GUARDS));
	}
}

bool p6_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p6_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p6_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp6_1_3398773
void p6_1::V2_outTRp6_1_3398773(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp6_1_3398773 -> Going From p6_1 to p2_7"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p6_1 => p2_7");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp6_1_3398773");
								smc->event_status_msg.push_back(" <!> State Update: p6_1 => p2_7");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp6_1_3398773"<<std::endl;
							std::cout<<" <!> State Update: p6_1 => p2_7"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_7());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p6_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp6_1_3398773
std::vector<int> p6_1::match_V2_outTRp6_1_3398773(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp6_1_3398773");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p6_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp6_1_3398773
void p6_1::V2_outTRp6_1_3398773(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp6_1_3398773 -> Going From p6_1 to p2_7"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p6_1 => p2_7");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp6_1_3398773");
							smc->event_status_msg.push_back(" <!> State Update: p6_1 => p2_7");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp6_1_3398773"<<std::endl;
						std::cout<<" <!> State Update: p6_1 => p2_7"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p2_7());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p6_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p6_1::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp6_1_3398773");
					smc->event_status_msg.push_back(" <!> State Update: p6_1 => p2_7");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp6_1_3398773"<<std::endl;
					std::cout<<" <!> State Update: p6_1 => p2_7"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp6_1_3398773();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp6_1_3398773");
					if(smc->m_outTRp6_1_3398773_Handler != nullptr)
					{
						smc->m_outTRp6_1_3398773_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p6_1 => p2_7");
					smc->setCurrent(new p2_7());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p6_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p6_1!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p7_1 ***********/

list<string> p7_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p7_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p7_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp7_1_3398775");
	return retStr;
}

string p7_1::getCurrentState() { return name; }

list<string> p7_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p7_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p7_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p7_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p7_1", NO_ENABLED_GUARDS));
	}
}

bool p7_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p7_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p7_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp7_1_3398775
void p7_1::V2_outTRp7_1_3398775(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp7_1_3398775 -> Going From p7_1 to p3_55"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p7_1 => p3_55");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp7_1_3398775");
								smc->event_status_msg.push_back(" <!> State Update: p7_1 => p3_55");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp7_1_3398775"<<std::endl;
							std::cout<<" <!> State Update: p7_1 => p3_55"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_55());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p7_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp7_1_3398775
std::vector<int> p7_1::match_V2_outTRp7_1_3398775(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp7_1_3398775");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p7_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp7_1_3398775
void p7_1::V2_outTRp7_1_3398775(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp7_1_3398775 -> Going From p7_1 to p3_55"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p7_1 => p3_55");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp7_1_3398775");
							smc->event_status_msg.push_back(" <!> State Update: p7_1 => p3_55");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp7_1_3398775"<<std::endl;
						std::cout<<" <!> State Update: p7_1 => p3_55"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_55());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p7_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p7_1::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp7_1_3398775");
					smc->event_status_msg.push_back(" <!> State Update: p7_1 => p3_55");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp7_1_3398775"<<std::endl;
					std::cout<<" <!> State Update: p7_1 => p3_55"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp7_1_3398775();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp7_1_3398775");
					if(smc->m_outTRp7_1_3398775_Handler != nullptr)
					{
						smc->m_outTRp7_1_3398775_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p7_1 => p3_55");
					smc->setCurrent(new p3_55());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p7_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p7_1!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p5_3 ***********/

list<string> p5_3::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p5_3::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp5_3_3398807");
	return retStr;
}
		
list<string> p5_3::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p5_3::getCurrentState() { return name; }

list<string> p5_3::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p5_3::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp5_3_3398807
	{
	list_of_enabled_signals.push_back("V2_inTRp5_3_3398807");
	}
	return list_of_enabled_signals;
}

void p5_3::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp5_3_3398807"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp5_3_3398807();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp5_3_3398807( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp5_3_3398807( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp5_3_3398807"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp5_3_3398807" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp5_3_3398807(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp5_3_3398807" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp5_3_3398807( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp5_3_3398807 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp5_3_3398807(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp5_3_3398807(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp5_3_3398807(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp5_3_3398807 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp5_3_3398807 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp5_3_3398807" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp5_3_3398807( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp5_3_3398807 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p5_3"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p5_3", NO_ENABLED_GUARDS));
	}
}

bool p5_3::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p5_3::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p5_3::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp5_3_3398807
bool p5_3::isEnabledV2_inTRp5_3_3398807(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp5_3_3398807
std::vector<int> p5_3::V2_inTRp5_3_3398807(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp5_3_3398807");
							smc->event_status_msg.push_back(" <!> State Update: p5_3 => p5_4");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp5_3_3398807"<<std::endl;
							// std::cout<<" <!> State Update: From p5_3 => p5_4"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p5_3 => p5_4");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp5_3_3398807 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_3!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp5_3_3398807
void p5_3::V2_inTRp5_3_3398807(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp5_3_3398807");
							smc->event_status_msg.push_back(" <!> State Update: p5_3 => p5_4");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp5_3_3398807"<<std::endl;
							std::cout<<" <!> State Update: From p5_3 => p5_4"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p5_3 => p5_4");
							smc->setTextColor("ANY");
							smc->setCurrent(new p5_4());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp5_3_3398807 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_3!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp5_3_3398807
void p5_3::V2_inTRp5_3_3398807(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp5_3_3398807");
				smc->event_status_msg.push_back(" <!> State Update: p5_3 => p5_4");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp5_3_3398807"<<std::endl;
				std::cout<<" <!> State Update: From p5_3 => p5_4"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p5_3 => p5_4");
				smc->setTextColor("ANY");
				smc->setCurrent(new p5_4());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp5_3_3398807 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p5_3!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p5_2 ***********/

list<string> p5_2::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p5_2::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p5_2::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp5_2_3398777");
	return retStr;
}

string p5_2::getCurrentState() { return name; }

list<string> p5_2::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p5_2::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p5_2::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p5_2"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p5_2", NO_ENABLED_GUARDS));
	}
}

bool p5_2::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p5_2::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p5_2::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp5_2_3398777
void p5_2::V2_outTRp5_2_3398777(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp5_2_3398777 -> Going From p5_2 to p5_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p5_2 => p5_3");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_2_3398777");
								smc->event_status_msg.push_back(" <!> State Update: p5_2 => p5_3");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_2_3398777"<<std::endl;
							std::cout<<" <!> State Update: p5_2 => p5_3"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p5_3());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp5_2_3398777
std::vector<int> p5_2::match_V2_outTRp5_2_3398777(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp5_2_3398777");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp5_2_3398777
void p5_2::V2_outTRp5_2_3398777(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp5_2_3398777 -> Going From p5_2 to p5_3"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p5_2 => p5_3");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_2_3398777");
							smc->event_status_msg.push_back(" <!> State Update: p5_2 => p5_3");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_2_3398777"<<std::endl;
						std::cout<<" <!> State Update: p5_2 => p5_3"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p5_3());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p5_2::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_2_3398777");
					smc->event_status_msg.push_back(" <!> State Update: p5_2 => p5_3");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_2_3398777"<<std::endl;
					std::cout<<" <!> State Update: p5_2 => p5_3"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp5_2_3398777();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp5_2_3398777");
					if(smc->m_outTRp5_2_3398777_Handler != nullptr)
					{
						smc->m_outTRp5_2_3398777_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p5_2 => p5_3");
					smc->setCurrent(new p5_3());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p5_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p5_2!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_25 ***********/

list<string> p1_25::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_25::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_4_3398746");
	return retStr;
}
		
list<string> p1_25::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_25::getCurrentState() { return name; }

list<string> p1_25::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_25::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_4_3398746
	{
	list_of_enabled_signals.push_back("V2_inTRp1_4_3398746");
	}
	return list_of_enabled_signals;
}

void p1_25::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_4_3398746"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_4_3398746();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_4_3398746( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_4_3398746( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_4_3398746"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_4_3398746" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_4_3398746(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_4_3398746" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_4_3398746( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_4_3398746 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_4_3398746(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_4_3398746(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_4_3398746(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_4_3398746 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_4_3398746 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_4_3398746" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_4_3398746( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_4_3398746 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_25"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_25", NO_ENABLED_GUARDS));
	}
}

bool p1_25::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_25::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_25::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_4_3398746
bool p1_25::isEnabledV2_inTRp1_4_3398746(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_4_3398746
std::vector<int> p1_25::V2_inTRp1_4_3398746(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_4_3398746");
							smc->event_status_msg.push_back(" <!> State Update: p1_25 => p1_26");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_4_3398746"<<std::endl;
							// std::cout<<" <!> State Update: From p1_25 => p1_26"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_25 => p1_26");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_4_3398746 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_25");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_25!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_4_3398746
void p1_25::V2_inTRp1_4_3398746(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_4_3398746");
							smc->event_status_msg.push_back(" <!> State Update: p1_25 => p1_26");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_4_3398746"<<std::endl;
							std::cout<<" <!> State Update: From p1_25 => p1_26"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_25 => p1_26");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_26());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_4_3398746 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_25");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_25!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_4_3398746
void p1_25::V2_inTRp1_4_3398746(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_4_3398746");
				smc->event_status_msg.push_back(" <!> State Update: p1_25 => p1_26");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_4_3398746"<<std::endl;
				std::cout<<" <!> State Update: From p1_25 => p1_26"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_25 => p1_26");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_26());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_4_3398746 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_25");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_25!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_13 ***********/

list<string> p3_13::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_13::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_13::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_6_3398761");
	return retStr;
}

string p3_13::getCurrentState() { return name; }

list<string> p3_13::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_13::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_13::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_13"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_13", NO_ENABLED_GUARDS));
	}
}

bool p3_13::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_13::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_13::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_6_3398761
void p3_13::V2_outTRp3_6_3398761(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_6_3398761 -> Going From p3_13 to p3_14"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_13 => p3_14");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_6_3398761");
								smc->event_status_msg.push_back(" <!> State Update: p3_13 => p3_14");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_6_3398761"<<std::endl;
							std::cout<<" <!> State Update: p3_13 => p3_14"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_14());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_6_3398761
std::vector<int> p3_13::match_V2_outTRp3_6_3398761(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_6_3398761");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_6_3398761
void p3_13::V2_outTRp3_6_3398761(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_6_3398761 -> Going From p3_13 to p3_14"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_13 => p3_14");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_6_3398761");
							smc->event_status_msg.push_back(" <!> State Update: p3_13 => p3_14");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_6_3398761"<<std::endl;
						std::cout<<" <!> State Update: p3_13 => p3_14"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_14());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_13::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_6_3398761");
					smc->event_status_msg.push_back(" <!> State Update: p3_13 => p3_14");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_6_3398761"<<std::endl;
					std::cout<<" <!> State Update: p3_13 => p3_14"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_6_3398761();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_6_3398761");
					if(smc->m_outTRp3_6_3398761_Handler != nullptr)
					{
						smc->m_outTRp3_6_3398761_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_13 => p3_14");
					smc->setCurrent(new p3_14());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_13!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p2_6 ***********/

list<string> p2_6::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_6::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_1_3398732");
	return retStr;
}
		
list<string> p2_6::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_6::getCurrentState() { return name; }

list<string> p2_6::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_6::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_1_3398732
	{
	list_of_enabled_signals.push_back("V2_inTRp2_1_3398732");
	}
	return list_of_enabled_signals;
}

void p2_6::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_1_3398732"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_1_3398732();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_1_3398732( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_1_3398732( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_1_3398732"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_1_3398732" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_1_3398732(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_1_3398732" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_1_3398732( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_1_3398732 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_1_3398732(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_1_3398732(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_1_3398732(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_1_3398732 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_1_3398732 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_1_3398732" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_1_3398732( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_1_3398732 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_6"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_6", NO_ENABLED_GUARDS));
	}
}

bool p2_6::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_6::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_6::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_1_3398732
bool p2_6::isEnabledV2_inTRp2_1_3398732(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_1_3398732
std::vector<int> p2_6::V2_inTRp2_1_3398732(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398732");
							smc->event_status_msg.push_back(" <!> State Update: p2_6 => p2_7");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398732"<<std::endl;
							// std::cout<<" <!> State Update: From p2_6 => p2_7"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_6 => p2_7");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398732 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_6!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_1_3398732
void p2_6::V2_inTRp2_1_3398732(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398732");
							smc->event_status_msg.push_back(" <!> State Update: p2_6 => p2_7");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398732"<<std::endl;
							std::cout<<" <!> State Update: From p2_6 => p2_7"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_6 => p2_7");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_7());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398732 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_6!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_1_3398732
void p2_6::V2_inTRp2_1_3398732(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398732");
				smc->event_status_msg.push_back(" <!> State Update: p2_6 => p2_7");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398732"<<std::endl;
				std::cout<<" <!> State Update: From p2_6 => p2_7"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_6 => p2_7");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_7());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398732 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_6!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_45 ***********/

list<string> p1_45::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_45::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_45::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_4_3398725");
	return retStr;
}

string p1_45::getCurrentState() { return name; }

list<string> p1_45::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_45::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_45::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_45"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_45", NO_ENABLED_GUARDS));
	}
}

bool p1_45::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_45::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_45::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_4_3398725
void p1_45::V2_outTRp1_4_3398725(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_4_3398725 -> Going From p1_45 to p1_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_45 => p1_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_4_3398725");
								smc->event_status_msg.push_back(" <!> State Update: p1_45 => p1_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_4_3398725"<<std::endl;
							std::cout<<" <!> State Update: p1_45 => p1_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_45");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_4_3398725
std::vector<int> p1_45::match_V2_outTRp1_4_3398725(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_4_3398725");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_45");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_4_3398725
void p1_45::V2_outTRp1_4_3398725(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_4_3398725 -> Going From p1_45 to p1_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_45 => p1_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_4_3398725");
							smc->event_status_msg.push_back(" <!> State Update: p1_45 => p1_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_4_3398725"<<std::endl;
						std::cout<<" <!> State Update: p1_45 => p1_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_45");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_45::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_4_3398725");
					smc->event_status_msg.push_back(" <!> State Update: p1_45 => p1_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_4_3398725"<<std::endl;
					std::cout<<" <!> State Update: p1_45 => p1_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_4_3398725();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_4_3398725");
					if(smc->m_outTRp1_4_3398725_Handler != nullptr)
					{
						smc->m_outTRp1_4_3398725_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_45 => p1_1");
					smc->setCurrent(new p1_1());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_45");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_45!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_10 ***********/

list<string> p1_10::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_10::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_10::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_10_3398879");
	return retStr;
}

string p1_10::getCurrentState() { return name; }

list<string> p1_10::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_10::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_10::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_10"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_10", NO_ENABLED_GUARDS));
	}
}

bool p1_10::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_10::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_10::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_10_3398879
void p1_10::V2_outTRp1_10_3398879(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_10_3398879 -> Going From p1_10 to p1_11"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_10 => p1_11");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_10_3398879");
								smc->event_status_msg.push_back(" <!> State Update: p1_10 => p1_11");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_10_3398879"<<std::endl;
							std::cout<<" <!> State Update: p1_10 => p1_11"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_11());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_10_3398879
std::vector<int> p1_10::match_V2_outTRp1_10_3398879(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_10_3398879");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_10_3398879
void p1_10::V2_outTRp1_10_3398879(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_10_3398879 -> Going From p1_10 to p1_11"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_10 => p1_11");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_10_3398879");
							smc->event_status_msg.push_back(" <!> State Update: p1_10 => p1_11");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_10_3398879"<<std::endl;
						std::cout<<" <!> State Update: p1_10 => p1_11"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_11());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_10::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_10_3398879");
					smc->event_status_msg.push_back(" <!> State Update: p1_10 => p1_11");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_10_3398879"<<std::endl;
					std::cout<<" <!> State Update: p1_10 => p1_11"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_10_3398879();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_10_3398879");
					if(smc->m_outTRp1_10_3398879_Handler != nullptr)
					{
						smc->m_outTRp1_10_3398879_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_10 => p1_11");
					smc->setCurrent(new p1_11());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_10!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_6 ***********/

list<string> p1_6::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_6::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_6::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_5_3398844");
	return retStr;
}

string p1_6::getCurrentState() { return name; }

list<string> p1_6::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_6::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_6::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_6"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_6", NO_ENABLED_GUARDS));
	}
}

bool p1_6::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_6::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_6::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_5_3398844
void p1_6::V2_outTRp1_5_3398844(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_5_3398844 -> Going From p1_6 to p1_7"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_6 => p1_7");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_5_3398844");
								smc->event_status_msg.push_back(" <!> State Update: p1_6 => p1_7");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_5_3398844"<<std::endl;
							std::cout<<" <!> State Update: p1_6 => p1_7"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_7());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_5_3398844
std::vector<int> p1_6::match_V2_outTRp1_5_3398844(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_5_3398844");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_5_3398844
void p1_6::V2_outTRp1_5_3398844(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_5_3398844 -> Going From p1_6 to p1_7"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_6 => p1_7");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_5_3398844");
							smc->event_status_msg.push_back(" <!> State Update: p1_6 => p1_7");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_5_3398844"<<std::endl;
						std::cout<<" <!> State Update: p1_6 => p1_7"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_7());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_6::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_5_3398844");
					smc->event_status_msg.push_back(" <!> State Update: p1_6 => p1_7");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_5_3398844"<<std::endl;
					std::cout<<" <!> State Update: p1_6 => p1_7"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_5_3398844();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_5_3398844");
					if(smc->m_outTRp1_5_3398844_Handler != nullptr)
					{
						smc->m_outTRp1_5_3398844_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_6 => p1_7");
					smc->setCurrent(new p1_7());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_6!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_34 ***********/

list<string> p1_34::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_34::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_34::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_1_3398719");
	retStr.push_back("V2_outTRp1_1_3398720");
	return retStr;
}

string p1_34::getCurrentState() { return name; }

list<string> p1_34::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_34::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_34::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_34"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_34", NO_ENABLED_GUARDS));
	}
}

bool p1_34::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_34::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_34::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true ||   true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_1_3398719
void p1_34::V2_outTRp1_1_3398719(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_1_3398719 -> Going From p1_34 to p2_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_34 => p2_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398719");
								smc->event_status_msg.push_back(" <!> State Update: p1_34 => p2_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398719"<<std::endl;
							std::cout<<" <!> State Update: p1_34 => p2_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_34");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Deterministic Notification Handler: V2_outTRp1_1_3398720
void p1_34::V2_outTRp1_1_3398720(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_1_3398720 -> Going From p1_34 to p3_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_34 => p3_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398720");
								smc->event_status_msg.push_back(" <!> State Update: p1_34 => p3_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398720"<<std::endl;
							std::cout<<" <!> State Update: p1_34 => p3_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_34");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_1_3398719
std::vector<int> p1_34::match_V2_outTRp1_1_3398719(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_1_3398719");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_34");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Validator: V2_outTRp1_1_3398720
std::vector<int> p1_34::match_V2_outTRp1_1_3398720(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_1_3398720");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_34");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_1_3398719
void p1_34::V2_outTRp1_1_3398719(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_1_3398719 -> Going From p1_34 to p2_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_34 => p2_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398719");
							smc->event_status_msg.push_back(" <!> State Update: p1_34 => p2_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398719"<<std::endl;
						std::cout<<" <!> State Update: p1_34 => p2_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p2_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_34");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Handler: V2_outTRp1_1_3398720
void p1_34::V2_outTRp1_1_3398720(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_1_3398720 -> Going From p1_34 to p3_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_34 => p3_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398720");
							smc->event_status_msg.push_back(" <!> State Update: p1_34 => p3_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398720"<<std::endl;
						std::cout<<" <!> State Update: p1_34 => p3_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_34");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_34::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true ||   true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %2; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398719");
					smc->event_status_msg.push_back(" <!> State Update: p1_34 => p2_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398719"<<std::endl;
					std::cout<<" <!> State Update: p1_34 => p2_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_1_3398719();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_1_3398719");
					if(smc->m_outTRp1_1_3398719_Handler != nullptr)
					{
						smc->m_outTRp1_1_3398719_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_34 => p2_1");
					smc->setCurrent(new p2_1());
					delete this;
					break;
		case 1:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398720");
					smc->event_status_msg.push_back(" <!> State Update: p1_34 => p3_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398720"<<std::endl;
					std::cout<<" <!> State Update: p1_34 => p3_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_1_3398720();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_1_3398720");
					if(smc->m_outTRp1_1_3398720_Handler != nullptr)
					{
						smc->m_outTRp1_1_3398720_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_34 => p3_1");
					smc->setCurrent(new p3_1());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_34");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_34!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_20 ***********/

list<string> p3_20::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_20::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_20::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_13_3398802");
	return retStr;
}

string p3_20::getCurrentState() { return name; }

list<string> p3_20::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_20::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_20::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_20"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_20", NO_ENABLED_GUARDS));
	}
}

bool p3_20::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_20::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_20::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_13_3398802
void p3_20::V2_outTRp3_13_3398802(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_13_3398802 -> Going From p3_20 to p3_21"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_20 => p3_21");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_13_3398802");
								smc->event_status_msg.push_back(" <!> State Update: p3_20 => p3_21");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_13_3398802"<<std::endl;
							std::cout<<" <!> State Update: p3_20 => p3_21"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_21());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_20");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_13_3398802
std::vector<int> p3_20::match_V2_outTRp3_13_3398802(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_13_3398802");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_20");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_13_3398802
void p3_20::V2_outTRp3_13_3398802(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_13_3398802 -> Going From p3_20 to p3_21"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_20 => p3_21");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_13_3398802");
							smc->event_status_msg.push_back(" <!> State Update: p3_20 => p3_21");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_13_3398802"<<std::endl;
						std::cout<<" <!> State Update: p3_20 => p3_21"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_21());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_20");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_20::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_13_3398802");
					smc->event_status_msg.push_back(" <!> State Update: p3_20 => p3_21");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_13_3398802"<<std::endl;
					std::cout<<" <!> State Update: p3_20 => p3_21"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_13_3398802();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_13_3398802");
					if(smc->m_outTRp3_13_3398802_Handler != nullptr)
					{
						smc->m_outTRp3_13_3398802_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_20 => p3_21");
					smc->setCurrent(new p3_21());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_20");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_20!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p8_1 ***********/

list<string> p8_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p8_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p8_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp8_1_3398788");
	return retStr;
}

string p8_1::getCurrentState() { return name; }

list<string> p8_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p8_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p8_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p8_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p8_1", NO_ENABLED_GUARDS));
	}
}

bool p8_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p8_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p8_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp8_1_3398788
void p8_1::V2_outTRp8_1_3398788(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp8_1_3398788 -> Going From p8_1 to p3_20"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p8_1 => p3_20");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp8_1_3398788");
								smc->event_status_msg.push_back(" <!> State Update: p8_1 => p3_20");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp8_1_3398788"<<std::endl;
							std::cout<<" <!> State Update: p8_1 => p3_20"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_20());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p8_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp8_1_3398788
std::vector<int> p8_1::match_V2_outTRp8_1_3398788(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp8_1_3398788");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p8_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp8_1_3398788
void p8_1::V2_outTRp8_1_3398788(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp8_1_3398788 -> Going From p8_1 to p3_20"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p8_1 => p3_20");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp8_1_3398788");
							smc->event_status_msg.push_back(" <!> State Update: p8_1 => p3_20");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp8_1_3398788"<<std::endl;
						std::cout<<" <!> State Update: p8_1 => p3_20"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_20());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p8_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p8_1::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp8_1_3398788");
					smc->event_status_msg.push_back(" <!> State Update: p8_1 => p3_20");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp8_1_3398788"<<std::endl;
					std::cout<<" <!> State Update: p8_1 => p3_20"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp8_1_3398788();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp8_1_3398788");
					if(smc->m_outTRp8_1_3398788_Handler != nullptr)
					{
						smc->m_outTRp8_1_3398788_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p8_1 => p3_20");
					smc->setCurrent(new p3_20());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p8_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p8_1!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p9_1 ***********/

list<string> p9_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p9_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p9_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp9_1_3398829");
	retStr.push_back("V2_outTRp9_1_3398870");
	return retStr;
}

string p9_1::getCurrentState() { return name; }

list<string> p9_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p9_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p9_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p9_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p9_1", NO_ENABLED_GUARDS));
	}
}

bool p9_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p9_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p9_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true ||   true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp9_1_3398829
void p9_1::V2_outTRp9_1_3398829(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp9_1_3398829 -> Going From p9_1 to p9_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p9_1 => p9_2");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_1_3398829");
								smc->event_status_msg.push_back(" <!> State Update: p9_1 => p9_2");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_1_3398829"<<std::endl;
							std::cout<<" <!> State Update: p9_1 => p9_2"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p9_2());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Deterministic Notification Handler: V2_outTRp9_1_3398870
void p9_1::V2_outTRp9_1_3398870(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp9_1_3398870 -> Going From p9_1 to p18_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p9_1 => p18_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_1_3398870");
								smc->event_status_msg.push_back(" <!> State Update: p9_1 => p18_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_1_3398870"<<std::endl;
							std::cout<<" <!> State Update: p9_1 => p18_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p18_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp9_1_3398829
std::vector<int> p9_1::match_V2_outTRp9_1_3398829(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp9_1_3398829");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Validator: V2_outTRp9_1_3398870
std::vector<int> p9_1::match_V2_outTRp9_1_3398870(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp9_1_3398870");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp9_1_3398829
void p9_1::V2_outTRp9_1_3398829(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp9_1_3398829 -> Going From p9_1 to p9_2"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p9_1 => p9_2");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_1_3398829");
							smc->event_status_msg.push_back(" <!> State Update: p9_1 => p9_2");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_1_3398829"<<std::endl;
						std::cout<<" <!> State Update: p9_1 => p9_2"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p9_2());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Handler: V2_outTRp9_1_3398870
void p9_1::V2_outTRp9_1_3398870(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp9_1_3398870 -> Going From p9_1 to p18_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p9_1 => p18_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_1_3398870");
							smc->event_status_msg.push_back(" <!> State Update: p9_1 => p18_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_1_3398870"<<std::endl;
						std::cout<<" <!> State Update: p9_1 => p18_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p18_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p9_1::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true ||   true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %2; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_1_3398829");
					smc->event_status_msg.push_back(" <!> State Update: p9_1 => p9_2");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_1_3398829"<<std::endl;
					std::cout<<" <!> State Update: p9_1 => p9_2"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp9_1_3398829();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp9_1_3398829");
					if(smc->m_outTRp9_1_3398829_Handler != nullptr)
					{
						smc->m_outTRp9_1_3398829_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p9_1 => p9_2");
					smc->setCurrent(new p9_2());
					delete this;
					break;
		case 1:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_1_3398870");
					smc->event_status_msg.push_back(" <!> State Update: p9_1 => p18_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_1_3398870"<<std::endl;
					std::cout<<" <!> State Update: p9_1 => p18_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp9_1_3398870();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp9_1_3398870");
					if(smc->m_outTRp9_1_3398870_Handler != nullptr)
					{
						smc->m_outTRp9_1_3398870_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p9_1 => p18_1");
					smc->setCurrent(new p18_1());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p9_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p9_1!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_41 ***********/

list<string> p1_41::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_41::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_32_3398834");
	return retStr;
}
		
list<string> p1_41::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_41::getCurrentState() { return name; }

list<string> p1_41::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_41::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_32_3398834
	{
	list_of_enabled_signals.push_back("V2_inTRp1_32_3398834");
	}
	return list_of_enabled_signals;
}

void p1_41::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_32_3398834"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_32_3398834();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_32_3398834( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_32_3398834( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_32_3398834"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_32_3398834" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_32_3398834(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_32_3398834" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_32_3398834( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_32_3398834 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_32_3398834(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_32_3398834(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_32_3398834(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_32_3398834 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_32_3398834 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_32_3398834" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_32_3398834( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_32_3398834 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_41"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_41", NO_ENABLED_GUARDS));
	}
}

bool p1_41::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_41::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_41::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_32_3398834
bool p1_41::isEnabledV2_inTRp1_32_3398834(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_32_3398834
std::vector<int> p1_41::V2_inTRp1_32_3398834(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_32_3398834");
							smc->event_status_msg.push_back(" <!> State Update: p1_41 => p1_42");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_32_3398834"<<std::endl;
							// std::cout<<" <!> State Update: From p1_41 => p1_42"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_41 => p1_42");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_32_3398834 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_41");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_41!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_32_3398834
void p1_41::V2_inTRp1_32_3398834(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_32_3398834");
							smc->event_status_msg.push_back(" <!> State Update: p1_41 => p1_42");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_32_3398834"<<std::endl;
							std::cout<<" <!> State Update: From p1_41 => p1_42"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_41 => p1_42");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_42());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_32_3398834 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_41");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_41!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_32_3398834
void p1_41::V2_inTRp1_32_3398834(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_32_3398834");
				smc->event_status_msg.push_back(" <!> State Update: p1_41 => p1_42");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_32_3398834"<<std::endl;
				std::cout<<" <!> State Update: From p1_41 => p1_42"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_41 => p1_42");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_42());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_32_3398834 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_41");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_41!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_37 ***********/

list<string> p1_37::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_37::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_37::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_25_3398820");
	return retStr;
}

string p1_37::getCurrentState() { return name; }

list<string> p1_37::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_37::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_37::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_37"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_37", NO_ENABLED_GUARDS));
	}
}

bool p1_37::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_37::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_37::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_25_3398820
void p1_37::V2_outTRp1_25_3398820(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_25_3398820 -> Going From p1_37 to p1_38"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_37 => p1_38");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_25_3398820");
								smc->event_status_msg.push_back(" <!> State Update: p1_37 => p1_38");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_25_3398820"<<std::endl;
							std::cout<<" <!> State Update: p1_37 => p1_38"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_38());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_37");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_25_3398820
std::vector<int> p1_37::match_V2_outTRp1_25_3398820(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_25_3398820");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_37");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_25_3398820
void p1_37::V2_outTRp1_25_3398820(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_25_3398820 -> Going From p1_37 to p1_38"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_37 => p1_38");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_25_3398820");
							smc->event_status_msg.push_back(" <!> State Update: p1_37 => p1_38");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_25_3398820"<<std::endl;
						std::cout<<" <!> State Update: p1_37 => p1_38"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_38());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_37");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_37::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_25_3398820");
					smc->event_status_msg.push_back(" <!> State Update: p1_37 => p1_38");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_25_3398820"<<std::endl;
					std::cout<<" <!> State Update: p1_37 => p1_38"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_25_3398820();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_25_3398820");
					if(smc->m_outTRp1_25_3398820_Handler != nullptr)
					{
						smc->m_outTRp1_25_3398820_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_37 => p1_38");
					smc->setCurrent(new p1_38());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_37");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_37!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_25 ***********/

list<string> p3_25::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_25::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_17_3398814");
	return retStr;
}
		
list<string> p3_25::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_25::getCurrentState() { return name; }

list<string> p3_25::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_25::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_17_3398814
	{
	list_of_enabled_signals.push_back("V2_inTRp3_17_3398814");
	}
	return list_of_enabled_signals;
}

void p3_25::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_17_3398814"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_17_3398814();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_17_3398814( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_17_3398814( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_17_3398814"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_17_3398814" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_17_3398814(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_17_3398814" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_17_3398814( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_17_3398814 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_17_3398814(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_17_3398814(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_17_3398814(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_17_3398814 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_17_3398814 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_17_3398814" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_17_3398814( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_17_3398814 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_25"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_25", NO_ENABLED_GUARDS));
	}
}

bool p3_25::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_25::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_25::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_17_3398814
bool p3_25::isEnabledV2_inTRp3_17_3398814(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_17_3398814
std::vector<int> p3_25::V2_inTRp3_17_3398814(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_17_3398814");
							smc->event_status_msg.push_back(" <!> State Update: p3_25 => p3_26");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_17_3398814"<<std::endl;
							// std::cout<<" <!> State Update: From p3_25 => p3_26"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_25 => p3_26");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_17_3398814 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_25");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_25!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_17_3398814
void p3_25::V2_inTRp3_17_3398814(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_17_3398814");
							smc->event_status_msg.push_back(" <!> State Update: p3_25 => p3_26");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_17_3398814"<<std::endl;
							std::cout<<" <!> State Update: From p3_25 => p3_26"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_25 => p3_26");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_26());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_17_3398814 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_25");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_25!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_17_3398814
void p3_25::V2_inTRp3_17_3398814(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_17_3398814");
				smc->event_status_msg.push_back(" <!> State Update: p3_25 => p3_26");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_17_3398814"<<std::endl;
				std::cout<<" <!> State Update: From p3_25 => p3_26"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_25 => p3_26");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_26());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_17_3398814 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_25");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_25!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_23 ***********/

list<string> p1_23::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_23::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_1_3398723");
	return retStr;
}
		
list<string> p1_23::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_23::getCurrentState() { return name; }

list<string> p1_23::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_23::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_1_3398723
	{
	list_of_enabled_signals.push_back("V2_inTRp1_1_3398723");
	}
	return list_of_enabled_signals;
}

void p1_23::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_1_3398723"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_1_3398723();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_1_3398723( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_1_3398723( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_1_3398723"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_1_3398723" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_1_3398723(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_1_3398723" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_1_3398723( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_1_3398723 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_1_3398723(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_1_3398723(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_1_3398723(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_1_3398723 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_1_3398723 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_1_3398723" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_1_3398723( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_1_3398723 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_23"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_23", NO_ENABLED_GUARDS));
	}
}

bool p1_23::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_23::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_23::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_1_3398723
bool p1_23::isEnabledV2_inTRp1_1_3398723(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_1_3398723
std::vector<int> p1_23::V2_inTRp1_1_3398723(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_1_3398723");
							smc->event_status_msg.push_back(" <!> State Update: p1_23 => p1_24");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_1_3398723"<<std::endl;
							// std::cout<<" <!> State Update: From p1_23 => p1_24"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_23 => p1_24");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_1_3398723 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_23");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_23!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_1_3398723
void p1_23::V2_inTRp1_1_3398723(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_1_3398723");
							smc->event_status_msg.push_back(" <!> State Update: p1_23 => p1_24");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_1_3398723"<<std::endl;
							std::cout<<" <!> State Update: From p1_23 => p1_24"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_23 => p1_24");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_24());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_1_3398723 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_23");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_23!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_1_3398723
void p1_23::V2_inTRp1_1_3398723(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_1_3398723");
				smc->event_status_msg.push_back(" <!> State Update: p1_23 => p1_24");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_1_3398723"<<std::endl;
				std::cout<<" <!> State Update: From p1_23 => p1_24"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_23 => p1_24");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_24());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_1_3398723 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_23");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_23!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p10_1 ***********/

list<string> p10_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p10_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp10_1_3398805");
	return retStr;
}
		
list<string> p10_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p10_1::getCurrentState() { return name; }

list<string> p10_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p10_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp10_1_3398805
	{
	list_of_enabled_signals.push_back("V2_inTRp10_1_3398805");
	}
	return list_of_enabled_signals;
}

void p10_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp10_1_3398805"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp10_1_3398805();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp10_1_3398805( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp10_1_3398805( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp10_1_3398805"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp10_1_3398805" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp10_1_3398805(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp10_1_3398805" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp10_1_3398805( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp10_1_3398805 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp10_1_3398805(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp10_1_3398805(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp10_1_3398805(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp10_1_3398805 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp10_1_3398805 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp10_1_3398805" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp10_1_3398805( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp10_1_3398805 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p10_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p10_1", NO_ENABLED_GUARDS));
	}
}

bool p10_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p10_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p10_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp10_1_3398805
bool p10_1::isEnabledV2_inTRp10_1_3398805(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp10_1_3398805
std::vector<int> p10_1::V2_inTRp10_1_3398805(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp10_1_3398805");
							smc->event_status_msg.push_back(" <!> State Update: p10_1 => p10_2");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp10_1_3398805"<<std::endl;
							// std::cout<<" <!> State Update: From p10_1 => p10_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p10_1 => p10_2");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp10_1_3398805 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_1!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp10_1_3398805
void p10_1::V2_inTRp10_1_3398805(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp10_1_3398805");
							smc->event_status_msg.push_back(" <!> State Update: p10_1 => p10_2");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp10_1_3398805"<<std::endl;
							std::cout<<" <!> State Update: From p10_1 => p10_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p10_1 => p10_2");
							smc->setTextColor("ANY");
							smc->setCurrent(new p10_2());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp10_1_3398805 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp10_1_3398805
void p10_1::V2_inTRp10_1_3398805(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp10_1_3398805");
				smc->event_status_msg.push_back(" <!> State Update: p10_1 => p10_2");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp10_1_3398805"<<std::endl;
				std::cout<<" <!> State Update: From p10_1 => p10_2"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p10_1 => p10_2");
				smc->setTextColor("ANY");
				smc->setCurrent(new p10_2());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp10_1_3398805 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_1!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p11_1 ***********/

list<string> p11_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p11_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p11_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp11_1_3398824");
	return retStr;
}

string p11_1::getCurrentState() { return name; }

list<string> p11_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p11_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p11_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p11_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p11_1", NO_ENABLED_GUARDS));
	}
}

bool p11_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p11_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p11_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp11_1_3398824
void p11_1::V2_outTRp11_1_3398824(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp11_1_3398824 -> Going From p11_1 to p11_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p11_1 => p11_2");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp11_1_3398824");
								smc->event_status_msg.push_back(" <!> State Update: p11_1 => p11_2");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp11_1_3398824"<<std::endl;
							std::cout<<" <!> State Update: p11_1 => p11_2"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p11_2());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p11_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp11_1_3398824
std::vector<int> p11_1::match_V2_outTRp11_1_3398824(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp11_1_3398824");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p11_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp11_1_3398824
void p11_1::V2_outTRp11_1_3398824(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp11_1_3398824 -> Going From p11_1 to p11_2"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p11_1 => p11_2");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp11_1_3398824");
							smc->event_status_msg.push_back(" <!> State Update: p11_1 => p11_2");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp11_1_3398824"<<std::endl;
						std::cout<<" <!> State Update: p11_1 => p11_2"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p11_2());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p11_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p11_1::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp11_1_3398824");
					smc->event_status_msg.push_back(" <!> State Update: p11_1 => p11_2");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp11_1_3398824"<<std::endl;
					std::cout<<" <!> State Update: p11_1 => p11_2"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp11_1_3398824();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp11_1_3398824");
					if(smc->m_outTRp11_1_3398824_Handler != nullptr)
					{
						smc->m_outTRp11_1_3398824_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p11_1 => p11_2");
					smc->setCurrent(new p11_2());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p11_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p11_1!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_12 ***********/

list<string> p1_12::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_12::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_2_3398742");
	retStr.push_back("V2_inTRp1_2_3398743");
	return retStr;
}
		
list<string> p1_12::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_12::getCurrentState() { return name; }

list<string> p1_12::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_12::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_2_3398742
	{
	list_of_enabled_signals.push_back("V2_inTRp1_2_3398742");
	}
	// Signal Name: V2_inTRp1_2_3398743
	{
	list_of_enabled_signals.push_back("V2_inTRp1_2_3398743");
	}
	return list_of_enabled_signals;
}

void p1_12::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_2_3398742"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_2_3398742();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_2_3398742( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_2_3398742( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		if(!(*it).compare("V2_inTRp1_2_3398743"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_2_3398743();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_2_3398743( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_2_3398743( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_2_3398742"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_2_3398742" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_2_3398742(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_2_3398742" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_2_3398742( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_2_3398742 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_2_3398742(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_2_3398742(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_2_3398742(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_2_3398742 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_2_3398742 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_2_3398742" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_2_3398742( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_2_3398742 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		if(!(*it).compare("V2_inTRp1_2_3398743"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_2_3398743" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_2_3398743(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_2_3398743" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_2_3398743( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_2_3398743 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_2_3398743(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_2_3398743(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_2_3398743(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_2_3398743 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_2_3398743 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_2_3398743" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_2_3398743( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_2_3398743 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_12"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_12", NO_ENABLED_GUARDS));
	}
}

bool p1_12::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_12::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_12::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_2_3398742
bool p1_12::isEnabledV2_inTRp1_2_3398742(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Enabling Test for Signal: V2_inTRp1_2_3398743
bool p1_12::isEnabledV2_inTRp1_2_3398743(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_2_3398742
std::vector<int> p1_12::V2_inTRp1_2_3398742(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398742");
							smc->event_status_msg.push_back(" <!> State Update: p1_12 => p4_1");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398742"<<std::endl;
							// std::cout<<" <!> State Update: From p1_12 => p4_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_12 => p4_1");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398742 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Signal Context NI Validator: V2_inTRp1_2_3398743
std::vector<int> p1_12::V2_inTRp1_2_3398743(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398743");
							smc->event_status_msg.push_back(" <!> State Update: p1_12 => p5_1");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398743"<<std::endl;
							// std::cout<<" <!> State Update: From p1_12 => p5_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_12 => p5_1");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398743 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_2_3398742
void p1_12::V2_inTRp1_2_3398742(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398742");
							smc->event_status_msg.push_back(" <!> State Update: p1_12 => p4_1");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398742"<<std::endl;
							std::cout<<" <!> State Update: From p1_12 => p4_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_12 => p4_1");
							smc->setTextColor("ANY");
							smc->setCurrent(new p4_1());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398742 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Deterministic Signal Handler: V2_inTRp1_2_3398743
void p1_12::V2_inTRp1_2_3398743(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398743");
							smc->event_status_msg.push_back(" <!> State Update: p1_12 => p5_1");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398743"<<std::endl;
							std::cout<<" <!> State Update: From p1_12 => p5_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_12 => p5_1");
							smc->setTextColor("ANY");
							smc->setCurrent(new p5_1());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398743 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_2_3398742
void p1_12::V2_inTRp1_2_3398742(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398742");
				smc->event_status_msg.push_back(" <!> State Update: p1_12 => p4_1");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398742"<<std::endl;
				std::cout<<" <!> State Update: From p1_12 => p4_1"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_12 => p4_1");
				smc->setTextColor("ANY");
				smc->setCurrent(new p4_1());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398742 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_2_3398743
void p1_12::V2_inTRp1_2_3398743(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398743");
				smc->event_status_msg.push_back(" <!> State Update: p1_12 => p5_1");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398743"<<std::endl;
				std::cout<<" <!> State Update: From p1_12 => p5_1"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_12 => p5_1");
				smc->setTextColor("ANY");
				smc->setCurrent(new p5_1());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398743 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_12!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_36 ***********/

list<string> p3_36::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_36::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_2_3398726");
	return retStr;
}
		
list<string> p3_36::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_36::getCurrentState() { return name; }

list<string> p3_36::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_36::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_2_3398726
	{
	list_of_enabled_signals.push_back("V2_inTRp3_2_3398726");
	}
	return list_of_enabled_signals;
}

void p3_36::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_2_3398726"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_2_3398726();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_2_3398726( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_2_3398726( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_2_3398726"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_2_3398726" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_2_3398726(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_2_3398726" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_2_3398726( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_2_3398726 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_2_3398726(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_2_3398726(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_2_3398726(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_2_3398726 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_2_3398726 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_2_3398726" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_2_3398726( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_2_3398726 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_36"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_36", NO_ENABLED_GUARDS));
	}
}

bool p3_36::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_36::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_36::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_2_3398726
bool p3_36::isEnabledV2_inTRp3_2_3398726(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_2_3398726
std::vector<int> p3_36::V2_inTRp3_2_3398726(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_2_3398726");
							smc->event_status_msg.push_back(" <!> State Update: p3_36 => p3_37");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_2_3398726"<<std::endl;
							// std::cout<<" <!> State Update: From p3_36 => p3_37"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_36 => p3_37");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_2_3398726 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_36");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_36!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_2_3398726
void p3_36::V2_inTRp3_2_3398726(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_2_3398726");
							smc->event_status_msg.push_back(" <!> State Update: p3_36 => p3_37");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_2_3398726"<<std::endl;
							std::cout<<" <!> State Update: From p3_36 => p3_37"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_36 => p3_37");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_37());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_2_3398726 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_36");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_36!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_2_3398726
void p3_36::V2_inTRp3_2_3398726(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_2_3398726");
				smc->event_status_msg.push_back(" <!> State Update: p3_36 => p3_37");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_2_3398726"<<std::endl;
				std::cout<<" <!> State Update: From p3_36 => p3_37"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_36 => p3_37");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_37());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_2_3398726 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_36");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_36!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_52 ***********/

list<string> p3_52::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_52::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_52::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_32_3398806");
	return retStr;
}

string p3_52::getCurrentState() { return name; }

list<string> p3_52::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_52::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_52::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_52"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_52", NO_ENABLED_GUARDS));
	}
}

bool p3_52::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_52::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_52::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_32_3398806
void p3_52::V2_outTRp3_32_3398806(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_32_3398806 -> Going From p3_52 to p3_53"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_52 => p3_53");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_32_3398806");
								smc->event_status_msg.push_back(" <!> State Update: p3_52 => p3_53");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_32_3398806"<<std::endl;
							std::cout<<" <!> State Update: p3_52 => p3_53"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_53());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_52");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_32_3398806
std::vector<int> p3_52::match_V2_outTRp3_32_3398806(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_32_3398806");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_52");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_32_3398806
void p3_52::V2_outTRp3_32_3398806(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_32_3398806 -> Going From p3_52 to p3_53"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_52 => p3_53");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_32_3398806");
							smc->event_status_msg.push_back(" <!> State Update: p3_52 => p3_53");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_32_3398806"<<std::endl;
						std::cout<<" <!> State Update: p3_52 => p3_53"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_53());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_52");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_52::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_32_3398806");
					smc->event_status_msg.push_back(" <!> State Update: p3_52 => p3_53");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_32_3398806"<<std::endl;
					std::cout<<" <!> State Update: p3_52 => p3_53"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_32_3398806();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_32_3398806");
					if(smc->m_outTRp3_32_3398806_Handler != nullptr)
					{
						smc->m_outTRp3_32_3398806_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_52 => p3_53");
					smc->setCurrent(new p3_53());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_52");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_52!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p9_4 ***********/

list<string> p9_4::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p9_4::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p9_4::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp9_3_3398810");
	return retStr;
}

string p9_4::getCurrentState() { return name; }

list<string> p9_4::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p9_4::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p9_4::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p9_4"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p9_4", NO_ENABLED_GUARDS));
	}
}

bool p9_4::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p9_4::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p9_4::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp9_3_3398810
void p9_4::V2_outTRp9_3_3398810(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp9_3_3398810 -> Going From p9_4 to p9_5"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p9_4 => p9_5");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_3_3398810");
								smc->event_status_msg.push_back(" <!> State Update: p9_4 => p9_5");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_3_3398810"<<std::endl;
							std::cout<<" <!> State Update: p9_4 => p9_5"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p9_5());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp9_3_3398810
std::vector<int> p9_4::match_V2_outTRp9_3_3398810(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp9_3_3398810");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp9_3_3398810
void p9_4::V2_outTRp9_3_3398810(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp9_3_3398810 -> Going From p9_4 to p9_5"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p9_4 => p9_5");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_3_3398810");
							smc->event_status_msg.push_back(" <!> State Update: p9_4 => p9_5");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_3_3398810"<<std::endl;
						std::cout<<" <!> State Update: p9_4 => p9_5"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p9_5());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p9_4::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_3_3398810");
					smc->event_status_msg.push_back(" <!> State Update: p9_4 => p9_5");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_3_3398810"<<std::endl;
					std::cout<<" <!> State Update: p9_4 => p9_5"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp9_3_3398810();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp9_3_3398810");
					if(smc->m_outTRp9_3_3398810_Handler != nullptr)
					{
						smc->m_outTRp9_3_3398810_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p9_4 => p9_5");
					smc->setCurrent(new p9_5());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p9_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p9_4!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p9_3 ***********/

list<string> p9_3::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p9_3::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p9_3::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp9_2_3398801");
	return retStr;
}

string p9_3::getCurrentState() { return name; }

list<string> p9_3::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p9_3::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p9_3::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p9_3"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p9_3", NO_ENABLED_GUARDS));
	}
}

bool p9_3::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p9_3::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p9_3::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp9_2_3398801
void p9_3::V2_outTRp9_2_3398801(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp9_2_3398801 -> Going From p9_3 to p9_4"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p9_3 => p9_4");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_2_3398801");
								smc->event_status_msg.push_back(" <!> State Update: p9_3 => p9_4");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_2_3398801"<<std::endl;
							std::cout<<" <!> State Update: p9_3 => p9_4"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p9_4());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp9_2_3398801
std::vector<int> p9_3::match_V2_outTRp9_2_3398801(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp9_2_3398801");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp9_2_3398801
void p9_3::V2_outTRp9_2_3398801(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp9_2_3398801 -> Going From p9_3 to p9_4"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p9_3 => p9_4");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_2_3398801");
							smc->event_status_msg.push_back(" <!> State Update: p9_3 => p9_4");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_2_3398801"<<std::endl;
						std::cout<<" <!> State Update: p9_3 => p9_4"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p9_4());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p9_3::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_2_3398801");
					smc->event_status_msg.push_back(" <!> State Update: p9_3 => p9_4");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_2_3398801"<<std::endl;
					std::cout<<" <!> State Update: p9_3 => p9_4"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp9_2_3398801();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp9_2_3398801");
					if(smc->m_outTRp9_2_3398801_Handler != nullptr)
					{
						smc->m_outTRp9_2_3398801_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p9_3 => p9_4");
					smc->setCurrent(new p9_4());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p9_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p9_3!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_23 ***********/

list<string> p3_23::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_23::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_22_3398872");
	return retStr;
}
		
list<string> p3_23::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_23::getCurrentState() { return name; }

list<string> p3_23::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_23::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_22_3398872
	{
	list_of_enabled_signals.push_back("V2_inTRp3_22_3398872");
	}
	return list_of_enabled_signals;
}

void p3_23::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_22_3398872"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_22_3398872();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_22_3398872( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_22_3398872( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_22_3398872"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_22_3398872" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_22_3398872(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_22_3398872" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_22_3398872( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_22_3398872 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_22_3398872(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_22_3398872(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_22_3398872(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_22_3398872 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_22_3398872 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_22_3398872" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_22_3398872( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_22_3398872 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_23"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_23", NO_ENABLED_GUARDS));
	}
}

bool p3_23::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_23::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_23::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_22_3398872
bool p3_23::isEnabledV2_inTRp3_22_3398872(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_22_3398872
std::vector<int> p3_23::V2_inTRp3_22_3398872(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_22_3398872");
							smc->event_status_msg.push_back(" <!> State Update: p3_23 => p3_24");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_22_3398872"<<std::endl;
							// std::cout<<" <!> State Update: From p3_23 => p3_24"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_23 => p3_24");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_22_3398872 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_23");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_23!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_22_3398872
void p3_23::V2_inTRp3_22_3398872(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_22_3398872");
							smc->event_status_msg.push_back(" <!> State Update: p3_23 => p3_24");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_22_3398872"<<std::endl;
							std::cout<<" <!> State Update: From p3_23 => p3_24"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_23 => p3_24");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_24());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_22_3398872 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_23");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_23!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_22_3398872
void p3_23::V2_inTRp3_22_3398872(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_22_3398872");
				smc->event_status_msg.push_back(" <!> State Update: p3_23 => p3_24");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_22_3398872"<<std::endl;
				std::cout<<" <!> State Update: From p3_23 => p3_24"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_23 => p3_24");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_24());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_22_3398872 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_23");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_23!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_21 ***********/

list<string> p3_21::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_21::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_15_3398827");
	return retStr;
}
		
list<string> p3_21::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_21::getCurrentState() { return name; }

list<string> p3_21::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_21::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_15_3398827
	{
	list_of_enabled_signals.push_back("V2_inTRp3_15_3398827");
	}
	return list_of_enabled_signals;
}

void p3_21::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_15_3398827"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_15_3398827();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_15_3398827( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_15_3398827( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_15_3398827"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_15_3398827" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_15_3398827(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_15_3398827" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_15_3398827( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_15_3398827 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_15_3398827(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_15_3398827(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_15_3398827(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_15_3398827 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_15_3398827 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_15_3398827" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_15_3398827( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_15_3398827 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_21"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_21", NO_ENABLED_GUARDS));
	}
}

bool p3_21::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_21::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_21::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_15_3398827
bool p3_21::isEnabledV2_inTRp3_15_3398827(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_15_3398827
std::vector<int> p3_21::V2_inTRp3_15_3398827(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_15_3398827");
							smc->event_status_msg.push_back(" <!> State Update: p3_21 => p3_22");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_15_3398827"<<std::endl;
							// std::cout<<" <!> State Update: From p3_21 => p3_22"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_21 => p3_22");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_15_3398827 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_21");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_21!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_15_3398827
void p3_21::V2_inTRp3_15_3398827(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_15_3398827");
							smc->event_status_msg.push_back(" <!> State Update: p3_21 => p3_22");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_15_3398827"<<std::endl;
							std::cout<<" <!> State Update: From p3_21 => p3_22"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_21 => p3_22");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_22());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_15_3398827 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_21");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_21!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_15_3398827
void p3_21::V2_inTRp3_15_3398827(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_15_3398827");
				smc->event_status_msg.push_back(" <!> State Update: p3_21 => p3_22");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_15_3398827"<<std::endl;
				std::cout<<" <!> State Update: From p3_21 => p3_22"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_21 => p3_22");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_22());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_15_3398827 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_21");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_21!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_18 ***********/

list<string> p1_18::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_18::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_15_3398859");
	return retStr;
}
		
list<string> p1_18::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_18::getCurrentState() { return name; }

list<string> p1_18::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_18::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_15_3398859
	{
	list_of_enabled_signals.push_back("V2_inTRp1_15_3398859");
	}
	return list_of_enabled_signals;
}

void p1_18::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_15_3398859"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_15_3398859();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_15_3398859( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_15_3398859( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_15_3398859"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_15_3398859" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_15_3398859(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_15_3398859" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_15_3398859( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_15_3398859 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_15_3398859(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_15_3398859(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_15_3398859(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_15_3398859 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_15_3398859 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_15_3398859" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_15_3398859( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_15_3398859 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_18"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_18", NO_ENABLED_GUARDS));
	}
}

bool p1_18::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_18::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_18::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_15_3398859
bool p1_18::isEnabledV2_inTRp1_15_3398859(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_15_3398859
std::vector<int> p1_18::V2_inTRp1_15_3398859(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_15_3398859");
							smc->event_status_msg.push_back(" <!> State Update: p1_18 => p1_19");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_15_3398859"<<std::endl;
							// std::cout<<" <!> State Update: From p1_18 => p1_19"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_18 => p1_19");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_15_3398859 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_18");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_18!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_15_3398859
void p1_18::V2_inTRp1_15_3398859(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_15_3398859");
							smc->event_status_msg.push_back(" <!> State Update: p1_18 => p1_19");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_15_3398859"<<std::endl;
							std::cout<<" <!> State Update: From p1_18 => p1_19"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_18 => p1_19");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_19());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_15_3398859 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_18");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_18!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_15_3398859
void p1_18::V2_inTRp1_15_3398859(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_15_3398859");
				smc->event_status_msg.push_back(" <!> State Update: p1_18 => p1_19");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_15_3398859"<<std::endl;
				std::cout<<" <!> State Update: From p1_18 => p1_19"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_18 => p1_19");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_19());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_15_3398859 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_18");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_18!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p10_2 ***********/

list<string> p10_2::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p10_2::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp10_1_3398795");
	return retStr;
}
		
list<string> p10_2::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p10_2::getCurrentState() { return name; }

list<string> p10_2::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p10_2::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp10_1_3398795
	{
	list_of_enabled_signals.push_back("V2_inTRp10_1_3398795");
	}
	return list_of_enabled_signals;
}

void p10_2::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp10_1_3398795"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp10_1_3398795();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp10_1_3398795( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp10_1_3398795( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp10_1_3398795"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp10_1_3398795" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp10_1_3398795(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp10_1_3398795" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp10_1_3398795( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp10_1_3398795 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp10_1_3398795(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp10_1_3398795(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp10_1_3398795(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp10_1_3398795 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp10_1_3398795 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp10_1_3398795" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp10_1_3398795( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp10_1_3398795 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p10_2"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p10_2", NO_ENABLED_GUARDS));
	}
}

bool p10_2::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p10_2::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p10_2::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp10_1_3398795
bool p10_2::isEnabledV2_inTRp10_1_3398795(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp10_1_3398795
std::vector<int> p10_2::V2_inTRp10_1_3398795(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp10_1_3398795");
							smc->event_status_msg.push_back(" <!> State Update: p10_2 => p1_23");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp10_1_3398795"<<std::endl;
							// std::cout<<" <!> State Update: From p10_2 => p1_23"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p10_2 => p1_23");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp10_1_3398795 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_2!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp10_1_3398795
void p10_2::V2_inTRp10_1_3398795(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp10_1_3398795");
							smc->event_status_msg.push_back(" <!> State Update: p10_2 => p1_23");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp10_1_3398795"<<std::endl;
							std::cout<<" <!> State Update: From p10_2 => p1_23"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p10_2 => p1_23");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_23());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp10_1_3398795 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_2!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp10_1_3398795
void p10_2::V2_inTRp10_1_3398795(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp10_1_3398795");
				smc->event_status_msg.push_back(" <!> State Update: p10_2 => p1_23");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp10_1_3398795"<<std::endl;
				std::cout<<" <!> State Update: From p10_2 => p1_23"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p10_2 => p1_23");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_23());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp10_1_3398795 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p10_2!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_53 ***********/

list<string> p3_53::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_53::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_53::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_5_3398733");
	return retStr;
}

string p3_53::getCurrentState() { return name; }

list<string> p3_53::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_53::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_53::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_53"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_53", NO_ENABLED_GUARDS));
	}
}

bool p3_53::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_53::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_53::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_5_3398733
void p3_53::V2_outTRp3_5_3398733(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_5_3398733 -> Going From p3_53 to p3_54"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_53 => p3_54");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_5_3398733");
								smc->event_status_msg.push_back(" <!> State Update: p3_53 => p3_54");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_5_3398733"<<std::endl;
							std::cout<<" <!> State Update: p3_53 => p3_54"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_54());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_53");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_5_3398733
std::vector<int> p3_53::match_V2_outTRp3_5_3398733(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_5_3398733");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_53");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_5_3398733
void p3_53::V2_outTRp3_5_3398733(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_5_3398733 -> Going From p3_53 to p3_54"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_53 => p3_54");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_5_3398733");
							smc->event_status_msg.push_back(" <!> State Update: p3_53 => p3_54");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_5_3398733"<<std::endl;
						std::cout<<" <!> State Update: p3_53 => p3_54"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_54());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_53");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_53::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_5_3398733");
					smc->event_status_msg.push_back(" <!> State Update: p3_53 => p3_54");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_5_3398733"<<std::endl;
					std::cout<<" <!> State Update: p3_53 => p3_54"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_5_3398733();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_5_3398733");
					if(smc->m_outTRp3_5_3398733_Handler != nullptr)
					{
						smc->m_outTRp3_5_3398733_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_53 => p3_54");
					smc->setCurrent(new p3_54());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_53");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_53!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p5_4 ***********/

list<string> p5_4::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p5_4::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p5_4::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp5_4_3398817");
	retStr.push_back("V2_outTRp5_4_3398816");
	return retStr;
}

string p5_4::getCurrentState() { return name; }

list<string> p5_4::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p5_4::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p5_4::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p5_4"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p5_4", NO_ENABLED_GUARDS));
	}
}

bool p5_4::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p5_4::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p5_4::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true ||   true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp5_4_3398817
void p5_4::V2_outTRp5_4_3398817(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp5_4_3398817 -> Going From p5_4 to p13_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p5_4 => p13_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_4_3398817");
								smc->event_status_msg.push_back(" <!> State Update: p5_4 => p13_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_4_3398817"<<std::endl;
							std::cout<<" <!> State Update: p5_4 => p13_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p13_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Deterministic Notification Handler: V2_outTRp5_4_3398816
void p5_4::V2_outTRp5_4_3398816(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp5_4_3398816 -> Going From p5_4 to p12_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p5_4 => p12_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_4_3398816");
								smc->event_status_msg.push_back(" <!> State Update: p5_4 => p12_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_4_3398816"<<std::endl;
							std::cout<<" <!> State Update: p5_4 => p12_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p12_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp5_4_3398817
std::vector<int> p5_4::match_V2_outTRp5_4_3398817(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp5_4_3398817");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Validator: V2_outTRp5_4_3398816
std::vector<int> p5_4::match_V2_outTRp5_4_3398816(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp5_4_3398816");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp5_4_3398817
void p5_4::V2_outTRp5_4_3398817(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp5_4_3398817 -> Going From p5_4 to p13_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p5_4 => p13_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_4_3398817");
							smc->event_status_msg.push_back(" <!> State Update: p5_4 => p13_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_4_3398817"<<std::endl;
						std::cout<<" <!> State Update: p5_4 => p13_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p13_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Handler: V2_outTRp5_4_3398816
void p5_4::V2_outTRp5_4_3398816(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp5_4_3398816 -> Going From p5_4 to p12_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p5_4 => p12_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_4_3398816");
							smc->event_status_msg.push_back(" <!> State Update: p5_4 => p12_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_4_3398816"<<std::endl;
						std::cout<<" <!> State Update: p5_4 => p12_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p12_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p5_4::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true ||   true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %2; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_4_3398816");
					smc->event_status_msg.push_back(" <!> State Update: p5_4 => p12_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_4_3398816"<<std::endl;
					std::cout<<" <!> State Update: p5_4 => p12_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp5_4_3398816();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp5_4_3398816");
					if(smc->m_outTRp5_4_3398816_Handler != nullptr)
					{
						smc->m_outTRp5_4_3398816_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p5_4 => p12_1");
					smc->setCurrent(new p12_1());
					delete this;
					break;
		case 1:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_4_3398817");
					smc->event_status_msg.push_back(" <!> State Update: p5_4 => p13_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_4_3398817"<<std::endl;
					std::cout<<" <!> State Update: p5_4 => p13_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp5_4_3398817();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp5_4_3398817");
					if(smc->m_outTRp5_4_3398817_Handler != nullptr)
					{
						smc->m_outTRp5_4_3398817_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p5_4 => p13_1");
					smc->setCurrent(new p13_1());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p5_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p5_4!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_21 ***********/

list<string> p1_21::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_21::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_14_3398833");
	return retStr;
}
		
list<string> p1_21::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_21::getCurrentState() { return name; }

list<string> p1_21::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_21::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_14_3398833
	{
	list_of_enabled_signals.push_back("V2_inTRp1_14_3398833");
	}
	return list_of_enabled_signals;
}

void p1_21::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_14_3398833"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_14_3398833();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_14_3398833( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_14_3398833( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_14_3398833"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_14_3398833" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_14_3398833(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_14_3398833" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_14_3398833( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_14_3398833 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_14_3398833(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_14_3398833(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_14_3398833(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_14_3398833 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_14_3398833 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_14_3398833" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_14_3398833( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_14_3398833 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_21"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_21", NO_ENABLED_GUARDS));
	}
}

bool p1_21::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_21::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_21::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_14_3398833
bool p1_21::isEnabledV2_inTRp1_14_3398833(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_14_3398833
std::vector<int> p1_21::V2_inTRp1_14_3398833(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_14_3398833");
							smc->event_status_msg.push_back(" <!> State Update: p1_21 => p1_22");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_14_3398833"<<std::endl;
							// std::cout<<" <!> State Update: From p1_21 => p1_22"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_21 => p1_22");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_14_3398833 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_21");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_21!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_14_3398833
void p1_21::V2_inTRp1_14_3398833(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_14_3398833");
							smc->event_status_msg.push_back(" <!> State Update: p1_21 => p1_22");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_14_3398833"<<std::endl;
							std::cout<<" <!> State Update: From p1_21 => p1_22"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_21 => p1_22");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_22());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_14_3398833 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_21");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_21!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_14_3398833
void p1_21::V2_inTRp1_14_3398833(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_14_3398833");
				smc->event_status_msg.push_back(" <!> State Update: p1_21 => p1_22");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_14_3398833"<<std::endl;
				std::cout<<" <!> State Update: From p1_21 => p1_22"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_21 => p1_22");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_22());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_14_3398833 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_21");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_21!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_36 ***********/

list<string> p1_36::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_36::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_16_3398790");
	return retStr;
}
		
list<string> p1_36::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_36::getCurrentState() { return name; }

list<string> p1_36::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_36::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_16_3398790
	{
	list_of_enabled_signals.push_back("V2_inTRp1_16_3398790");
	}
	return list_of_enabled_signals;
}

void p1_36::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_16_3398790"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_16_3398790();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_16_3398790( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_16_3398790( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_16_3398790"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_16_3398790" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_16_3398790(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_16_3398790" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_16_3398790( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_16_3398790 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_16_3398790(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_16_3398790(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_16_3398790(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_16_3398790 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_16_3398790 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_16_3398790" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_16_3398790( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_16_3398790 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_36"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_36", NO_ENABLED_GUARDS));
	}
}

bool p1_36::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_36::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_36::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_16_3398790
bool p1_36::isEnabledV2_inTRp1_16_3398790(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_16_3398790
std::vector<int> p1_36::V2_inTRp1_16_3398790(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_16_3398790");
							smc->event_status_msg.push_back(" <!> State Update: p1_36 => p1_37");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_16_3398790"<<std::endl;
							// std::cout<<" <!> State Update: From p1_36 => p1_37"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_36 => p1_37");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_16_3398790 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_36");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_36!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_16_3398790
void p1_36::V2_inTRp1_16_3398790(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_16_3398790");
							smc->event_status_msg.push_back(" <!> State Update: p1_36 => p1_37");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_16_3398790"<<std::endl;
							std::cout<<" <!> State Update: From p1_36 => p1_37"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_36 => p1_37");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_37());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_16_3398790 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_36");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_36!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_16_3398790
void p1_36::V2_inTRp1_16_3398790(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_16_3398790");
				smc->event_status_msg.push_back(" <!> State Update: p1_36 => p1_37");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_16_3398790"<<std::endl;
				std::cout<<" <!> State Update: From p1_36 => p1_37"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_36 => p1_37");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_37());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_16_3398790 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_36");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_36!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p9_5 ***********/

list<string> p9_5::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p9_5::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p9_5::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp9_5_3398831");
	return retStr;
}

string p9_5::getCurrentState() { return name; }

list<string> p9_5::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p9_5::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p9_5::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p9_5"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p9_5", NO_ENABLED_GUARDS));
	}
}

bool p9_5::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p9_5::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p9_5::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp9_5_3398831
void p9_5::V2_outTRp9_5_3398831(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp9_5_3398831 -> Going From p9_5 to p9_6"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p9_5 => p9_6");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_5_3398831");
								smc->event_status_msg.push_back(" <!> State Update: p9_5 => p9_6");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_5_3398831"<<std::endl;
							std::cout<<" <!> State Update: p9_5 => p9_6"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p9_6());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp9_5_3398831
std::vector<int> p9_5::match_V2_outTRp9_5_3398831(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp9_5_3398831");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp9_5_3398831
void p9_5::V2_outTRp9_5_3398831(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp9_5_3398831 -> Going From p9_5 to p9_6"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p9_5 => p9_6");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_5_3398831");
							smc->event_status_msg.push_back(" <!> State Update: p9_5 => p9_6");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_5_3398831"<<std::endl;
						std::cout<<" <!> State Update: p9_5 => p9_6"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p9_6());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p9_5::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_5_3398831");
					smc->event_status_msg.push_back(" <!> State Update: p9_5 => p9_6");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_5_3398831"<<std::endl;
					std::cout<<" <!> State Update: p9_5 => p9_6"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp9_5_3398831();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp9_5_3398831");
					if(smc->m_outTRp9_5_3398831_Handler != nullptr)
					{
						smc->m_outTRp9_5_3398831_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p9_5 => p9_6");
					smc->setCurrent(new p9_6());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p9_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p9_5!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_3 ***********/

list<string> p1_3::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_3::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_3::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_3_3398866");
	return retStr;
}

string p1_3::getCurrentState() { return name; }

list<string> p1_3::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_3::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_3::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_3"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_3", NO_ENABLED_GUARDS));
	}
}

bool p1_3::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_3::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_3::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_3_3398866
void p1_3::V2_outTRp1_3_3398866(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_3_3398866 -> Going From p1_3 to p1_4"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_3 => p1_4");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_3_3398866");
								smc->event_status_msg.push_back(" <!> State Update: p1_3 => p1_4");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_3_3398866"<<std::endl;
							std::cout<<" <!> State Update: p1_3 => p1_4"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_4());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_3_3398866
std::vector<int> p1_3::match_V2_outTRp1_3_3398866(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_3_3398866");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_3_3398866
void p1_3::V2_outTRp1_3_3398866(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_3_3398866 -> Going From p1_3 to p1_4"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_3 => p1_4");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_3_3398866");
							smc->event_status_msg.push_back(" <!> State Update: p1_3 => p1_4");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_3_3398866"<<std::endl;
						std::cout<<" <!> State Update: p1_3 => p1_4"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_4());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_3::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_3_3398866");
					smc->event_status_msg.push_back(" <!> State Update: p1_3 => p1_4");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_3_3398866"<<std::endl;
					std::cout<<" <!> State Update: p1_3 => p1_4"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_3_3398866();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_3_3398866");
					if(smc->m_outTRp1_3_3398866_Handler != nullptr)
					{
						smc->m_outTRp1_3_3398866_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_3 => p1_4");
					smc->setCurrent(new p1_4());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_3!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_2 ***********/

list<string> p1_2::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_2::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_2_3398812");
	return retStr;
}
		
list<string> p1_2::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_2::getCurrentState() { return name; }

list<string> p1_2::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_2::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_2_3398812
	{
	list_of_enabled_signals.push_back("V2_inTRp1_2_3398812");
	}
	return list_of_enabled_signals;
}

void p1_2::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_2_3398812"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_2_3398812();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_2_3398812( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_2_3398812( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_2_3398812"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_2_3398812" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_2_3398812(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_2_3398812" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_2_3398812( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_2_3398812 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_2_3398812(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_2_3398812(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_2_3398812(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_2_3398812 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_2_3398812 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_2_3398812" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_2_3398812( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_2_3398812 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_2"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_2", NO_ENABLED_GUARDS));
	}
}

bool p1_2::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_2::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_2::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_2_3398812
bool p1_2::isEnabledV2_inTRp1_2_3398812(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_2_3398812
std::vector<int> p1_2::V2_inTRp1_2_3398812(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398812");
							smc->event_status_msg.push_back(" <!> State Update: p1_2 => p1_3");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398812"<<std::endl;
							// std::cout<<" <!> State Update: From p1_2 => p1_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_2 => p1_3");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398812 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_2!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_2_3398812
void p1_2::V2_inTRp1_2_3398812(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398812");
							smc->event_status_msg.push_back(" <!> State Update: p1_2 => p1_3");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398812"<<std::endl;
							std::cout<<" <!> State Update: From p1_2 => p1_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_2 => p1_3");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_3());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398812 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_2!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_2_3398812
void p1_2::V2_inTRp1_2_3398812(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_2_3398812");
				smc->event_status_msg.push_back(" <!> State Update: p1_2 => p1_3");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_2_3398812"<<std::endl;
				std::cout<<" <!> State Update: From p1_2 => p1_3"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_2 => p1_3");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_3());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_2_3398812 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_2!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_16 ***********/

list<string> p3_16::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_16::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_16::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_8_3398766");
	return retStr;
}

string p3_16::getCurrentState() { return name; }

list<string> p3_16::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_16::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_16::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_16"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_16", NO_ENABLED_GUARDS));
	}
}

bool p3_16::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_16::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_16::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_8_3398766
void p3_16::V2_outTRp3_8_3398766(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_8_3398766 -> Going From p3_16 to p3_17"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_16 => p3_17");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_8_3398766");
								smc->event_status_msg.push_back(" <!> State Update: p3_16 => p3_17");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_8_3398766"<<std::endl;
							std::cout<<" <!> State Update: p3_16 => p3_17"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_17());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_8_3398766
std::vector<int> p3_16::match_V2_outTRp3_8_3398766(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_8_3398766");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_8_3398766
void p3_16::V2_outTRp3_8_3398766(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_8_3398766 -> Going From p3_16 to p3_17"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_16 => p3_17");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_8_3398766");
							smc->event_status_msg.push_back(" <!> State Update: p3_16 => p3_17");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_8_3398766"<<std::endl;
						std::cout<<" <!> State Update: p3_16 => p3_17"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_17());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_16::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_8_3398766");
					smc->event_status_msg.push_back(" <!> State Update: p3_16 => p3_17");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_8_3398766"<<std::endl;
					std::cout<<" <!> State Update: p3_16 => p3_17"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_8_3398766();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_8_3398766");
					if(smc->m_outTRp3_8_3398766_Handler != nullptr)
					{
						smc->m_outTRp3_8_3398766_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_16 => p3_17");
					smc->setCurrent(new p3_17());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_16!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_26 ***********/

list<string> p3_26::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_26::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_4_3398737");
	return retStr;
}
		
list<string> p3_26::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_26::getCurrentState() { return name; }

list<string> p3_26::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_26::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_4_3398737
	{
	list_of_enabled_signals.push_back("V2_inTRp3_4_3398737");
	}
	return list_of_enabled_signals;
}

void p3_26::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_4_3398737"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_4_3398737();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_4_3398737( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_4_3398737( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_4_3398737"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_4_3398737" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_4_3398737(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_4_3398737" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_4_3398737( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_4_3398737 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_4_3398737(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_4_3398737(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_4_3398737(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_4_3398737 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_4_3398737 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_4_3398737" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_4_3398737( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_4_3398737 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_26"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_26", NO_ENABLED_GUARDS));
	}
}

bool p3_26::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_26::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_26::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_4_3398737
bool p3_26::isEnabledV2_inTRp3_4_3398737(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_4_3398737
std::vector<int> p3_26::V2_inTRp3_4_3398737(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_4_3398737");
							smc->event_status_msg.push_back(" <!> State Update: p3_26 => p3_27");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_4_3398737"<<std::endl;
							// std::cout<<" <!> State Update: From p3_26 => p3_27"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_26 => p3_27");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_4_3398737 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_26");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_26!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_4_3398737
void p3_26::V2_inTRp3_4_3398737(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_4_3398737");
							smc->event_status_msg.push_back(" <!> State Update: p3_26 => p3_27");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_4_3398737"<<std::endl;
							std::cout<<" <!> State Update: From p3_26 => p3_27"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_26 => p3_27");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_27());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_4_3398737 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_26");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_26!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_4_3398737
void p3_26::V2_inTRp3_4_3398737(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_4_3398737");
				smc->event_status_msg.push_back(" <!> State Update: p3_26 => p3_27");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_4_3398737"<<std::endl;
				std::cout<<" <!> State Update: From p3_26 => p3_27"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_26 => p3_27");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_27());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_4_3398737 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_26");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_26!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_16 ***********/

list<string> p1_16::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_16::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_16::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_12_3398846");
	return retStr;
}

string p1_16::getCurrentState() { return name; }

list<string> p1_16::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_16::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_16::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_16"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_16", NO_ENABLED_GUARDS));
	}
}

bool p1_16::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_16::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_16::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_12_3398846
void p1_16::V2_outTRp1_12_3398846(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_12_3398846 -> Going From p1_16 to p1_17"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_16 => p1_17");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_12_3398846");
								smc->event_status_msg.push_back(" <!> State Update: p1_16 => p1_17");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_12_3398846"<<std::endl;
							std::cout<<" <!> State Update: p1_16 => p1_17"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_17());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_12_3398846
std::vector<int> p1_16::match_V2_outTRp1_12_3398846(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_12_3398846");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_12_3398846
void p1_16::V2_outTRp1_12_3398846(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_12_3398846 -> Going From p1_16 to p1_17"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_16 => p1_17");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_12_3398846");
							smc->event_status_msg.push_back(" <!> State Update: p1_16 => p1_17");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_12_3398846"<<std::endl;
						std::cout<<" <!> State Update: p1_16 => p1_17"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_17());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_16::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_12_3398846");
					smc->event_status_msg.push_back(" <!> State Update: p1_16 => p1_17");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_12_3398846"<<std::endl;
					std::cout<<" <!> State Update: p1_16 => p1_17"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_12_3398846();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_12_3398846");
					if(smc->m_outTRp1_12_3398846_Handler != nullptr)
					{
						smc->m_outTRp1_12_3398846_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_16 => p1_17");
					smc->setCurrent(new p1_17());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_16");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_16!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p5_5 ***********/

list<string> p5_5::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p5_5::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p5_5::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp5_1_3398745");
	return retStr;
}

string p5_5::getCurrentState() { return name; }

list<string> p5_5::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p5_5::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p5_5::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p5_5"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p5_5", NO_ENABLED_GUARDS));
	}
}

bool p5_5::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p5_5::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p5_5::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp5_1_3398745
void p5_5::V2_outTRp5_1_3398745(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp5_1_3398745 -> Going From p5_5 to p1_13"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p5_5 => p1_13");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_1_3398745");
								smc->event_status_msg.push_back(" <!> State Update: p5_5 => p1_13");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_1_3398745"<<std::endl;
							std::cout<<" <!> State Update: p5_5 => p1_13"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_13());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp5_1_3398745
std::vector<int> p5_5::match_V2_outTRp5_1_3398745(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp5_1_3398745");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp5_1_3398745
void p5_5::V2_outTRp5_1_3398745(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp5_1_3398745 -> Going From p5_5 to p1_13"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p5_5 => p1_13");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_1_3398745");
							smc->event_status_msg.push_back(" <!> State Update: p5_5 => p1_13");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_1_3398745"<<std::endl;
						std::cout<<" <!> State Update: p5_5 => p1_13"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_13());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p5_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p5_5::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp5_1_3398745");
					smc->event_status_msg.push_back(" <!> State Update: p5_5 => p1_13");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp5_1_3398745"<<std::endl;
					std::cout<<" <!> State Update: p5_5 => p1_13"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp5_1_3398745();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp5_1_3398745");
					if(smc->m_outTRp5_1_3398745_Handler != nullptr)
					{
						smc->m_outTRp5_1_3398745_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p5_5 => p1_13");
					smc->setCurrent(new p1_13());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p5_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p5_5!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p12_1 ***********/

list<string> p12_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p12_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp12_1_3398818");
	return retStr;
}
		
list<string> p12_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p12_1::getCurrentState() { return name; }

list<string> p12_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p12_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp12_1_3398818
	{
	list_of_enabled_signals.push_back("V2_inTRp12_1_3398818");
	}
	return list_of_enabled_signals;
}

void p12_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp12_1_3398818"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp12_1_3398818();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp12_1_3398818( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp12_1_3398818( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp12_1_3398818"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp12_1_3398818" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp12_1_3398818(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp12_1_3398818" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp12_1_3398818( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp12_1_3398818 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp12_1_3398818(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp12_1_3398818(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp12_1_3398818(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp12_1_3398818 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp12_1_3398818 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp12_1_3398818" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp12_1_3398818( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp12_1_3398818 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p12_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p12_1", NO_ENABLED_GUARDS));
	}
}

bool p12_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p12_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p12_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp12_1_3398818
bool p12_1::isEnabledV2_inTRp12_1_3398818(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp12_1_3398818
std::vector<int> p12_1::V2_inTRp12_1_3398818(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp12_1_3398818");
							smc->event_status_msg.push_back(" <!> State Update: p12_1 => p5_5");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp12_1_3398818"<<std::endl;
							// std::cout<<" <!> State Update: From p12_1 => p5_5"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p12_1 => p5_5");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp12_1_3398818 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p12_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p12_1!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp12_1_3398818
void p12_1::V2_inTRp12_1_3398818(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp12_1_3398818");
							smc->event_status_msg.push_back(" <!> State Update: p12_1 => p5_5");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp12_1_3398818"<<std::endl;
							std::cout<<" <!> State Update: From p12_1 => p5_5"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p12_1 => p5_5");
							smc->setTextColor("ANY");
							smc->setCurrent(new p5_5());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp12_1_3398818 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p12_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p12_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp12_1_3398818
void p12_1::V2_inTRp12_1_3398818(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp12_1_3398818");
				smc->event_status_msg.push_back(" <!> State Update: p12_1 => p5_5");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp12_1_3398818"<<std::endl;
				std::cout<<" <!> State Update: From p12_1 => p5_5"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p12_1 => p5_5");
				smc->setTextColor("ANY");
				smc->setCurrent(new p5_5());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp12_1_3398818 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p12_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p12_1!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p13_1 ***********/

list<string> p13_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p13_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp13_1_3398819");
	return retStr;
}
		
list<string> p13_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p13_1::getCurrentState() { return name; }

list<string> p13_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p13_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp13_1_3398819
	{
	list_of_enabled_signals.push_back("V2_inTRp13_1_3398819");
	}
	return list_of_enabled_signals;
}

void p13_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp13_1_3398819"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp13_1_3398819();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp13_1_3398819( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp13_1_3398819( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp13_1_3398819"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp13_1_3398819" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp13_1_3398819(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp13_1_3398819" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp13_1_3398819( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp13_1_3398819 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp13_1_3398819(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp13_1_3398819(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp13_1_3398819(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp13_1_3398819 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp13_1_3398819 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp13_1_3398819" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp13_1_3398819( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp13_1_3398819 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p13_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p13_1", NO_ENABLED_GUARDS));
	}
}

bool p13_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p13_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p13_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp13_1_3398819
bool p13_1::isEnabledV2_inTRp13_1_3398819(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp13_1_3398819
std::vector<int> p13_1::V2_inTRp13_1_3398819(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp13_1_3398819");
							smc->event_status_msg.push_back(" <!> State Update: p13_1 => p5_5");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp13_1_3398819"<<std::endl;
							// std::cout<<" <!> State Update: From p13_1 => p5_5"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p13_1 => p5_5");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp13_1_3398819 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p13_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p13_1!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp13_1_3398819
void p13_1::V2_inTRp13_1_3398819(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp13_1_3398819");
							smc->event_status_msg.push_back(" <!> State Update: p13_1 => p5_5");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp13_1_3398819"<<std::endl;
							std::cout<<" <!> State Update: From p13_1 => p5_5"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p13_1 => p5_5");
							smc->setTextColor("ANY");
							smc->setCurrent(new p5_5());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp13_1_3398819 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p13_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p13_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp13_1_3398819
void p13_1::V2_inTRp13_1_3398819(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp13_1_3398819");
				smc->event_status_msg.push_back(" <!> State Update: p13_1 => p5_5");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp13_1_3398819"<<std::endl;
				std::cout<<" <!> State Update: From p13_1 => p5_5"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p13_1 => p5_5");
				smc->setTextColor("ANY");
				smc->setCurrent(new p5_5());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp13_1_3398819 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p13_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p13_1!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_38 ***********/

list<string> p1_38::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_38::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_38::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_26_3398822");
	return retStr;
}

string p1_38::getCurrentState() { return name; }

list<string> p1_38::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_38::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_38::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_38"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_38", NO_ENABLED_GUARDS));
	}
}

bool p1_38::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_38::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_38::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_26_3398822
void p1_38::V2_outTRp1_26_3398822(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_26_3398822 -> Going From p1_38 to p1_39"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_38 => p1_39");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_26_3398822");
								smc->event_status_msg.push_back(" <!> State Update: p1_38 => p1_39");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_26_3398822"<<std::endl;
							std::cout<<" <!> State Update: p1_38 => p1_39"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_39());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_38");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_26_3398822
std::vector<int> p1_38::match_V2_outTRp1_26_3398822(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_26_3398822");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_38");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_26_3398822
void p1_38::V2_outTRp1_26_3398822(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_26_3398822 -> Going From p1_38 to p1_39"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_38 => p1_39");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_26_3398822");
							smc->event_status_msg.push_back(" <!> State Update: p1_38 => p1_39");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_26_3398822"<<std::endl;
						std::cout<<" <!> State Update: p1_38 => p1_39"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_39());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_38");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_38::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_26_3398822");
					smc->event_status_msg.push_back(" <!> State Update: p1_38 => p1_39");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_26_3398822"<<std::endl;
					std::cout<<" <!> State Update: p1_38 => p1_39"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_26_3398822();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_26_3398822");
					if(smc->m_outTRp1_26_3398822_Handler != nullptr)
					{
						smc->m_outTRp1_26_3398822_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_38 => p1_39");
					smc->setCurrent(new p1_39());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_38");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_38!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p2_18 ***********/

list<string> p2_18::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_18::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_1_3398721");
	return retStr;
}
		
list<string> p2_18::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_18::getCurrentState() { return name; }

list<string> p2_18::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_18::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_1_3398721
	{
	list_of_enabled_signals.push_back("V2_inTRp2_1_3398721");
	}
	return list_of_enabled_signals;
}

void p2_18::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_1_3398721"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_1_3398721();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_1_3398721( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_1_3398721( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_1_3398721"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_1_3398721" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_1_3398721(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_1_3398721" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_1_3398721( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_1_3398721 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_1_3398721(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_1_3398721(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_1_3398721(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_1_3398721 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_1_3398721 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_1_3398721" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_1_3398721( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_1_3398721 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_18"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_18", NO_ENABLED_GUARDS));
	}
}

bool p2_18::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_18::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_18::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_1_3398721
bool p2_18::isEnabledV2_inTRp2_1_3398721(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_1_3398721
std::vector<int> p2_18::V2_inTRp2_1_3398721(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398721");
							smc->event_status_msg.push_back(" <!> State Update: p2_18 => p1_35");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398721"<<std::endl;
							// std::cout<<" <!> State Update: From p2_18 => p1_35"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_18 => p1_35");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398721 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_18");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_18!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_1_3398721
void p2_18::V2_inTRp2_1_3398721(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398721");
							smc->event_status_msg.push_back(" <!> State Update: p2_18 => p1_35");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398721"<<std::endl;
							std::cout<<" <!> State Update: From p2_18 => p1_35"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_18 => p1_35");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_35());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398721 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_18");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_18!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_1_3398721
void p2_18::V2_inTRp2_1_3398721(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398721");
				smc->event_status_msg.push_back(" <!> State Update: p2_18 => p1_35");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398721"<<std::endl;
				std::cout<<" <!> State Update: From p2_18 => p1_35"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_18 => p1_35");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_35());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398721 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_18");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_18!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_40 ***********/

list<string> p1_40::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_40::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_40::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_17_3398791");
	return retStr;
}

string p1_40::getCurrentState() { return name; }

list<string> p1_40::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_40::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_40::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_40"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_40", NO_ENABLED_GUARDS));
	}
}

bool p1_40::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_40::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_40::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_17_3398791
void p1_40::V2_outTRp1_17_3398791(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_17_3398791 -> Going From p1_40 to p1_41"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_40 => p1_41");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_17_3398791");
								smc->event_status_msg.push_back(" <!> State Update: p1_40 => p1_41");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_17_3398791"<<std::endl;
							std::cout<<" <!> State Update: p1_40 => p1_41"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_41());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_40");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_17_3398791
std::vector<int> p1_40::match_V2_outTRp1_17_3398791(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_17_3398791");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_40");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_17_3398791
void p1_40::V2_outTRp1_17_3398791(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_17_3398791 -> Going From p1_40 to p1_41"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_40 => p1_41");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_17_3398791");
							smc->event_status_msg.push_back(" <!> State Update: p1_40 => p1_41");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_17_3398791"<<std::endl;
						std::cout<<" <!> State Update: p1_40 => p1_41"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_41());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_40");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_40::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_17_3398791");
					smc->event_status_msg.push_back(" <!> State Update: p1_40 => p1_41");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_17_3398791"<<std::endl;
					std::cout<<" <!> State Update: p1_40 => p1_41"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_17_3398791();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_17_3398791");
					if(smc->m_outTRp1_17_3398791_Handler != nullptr)
					{
						smc->m_outTRp1_17_3398791_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_40 => p1_41");
					smc->setCurrent(new p1_41());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_40");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_40!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_39 ***********/

list<string> p1_39::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_39::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_27_3398823");
	return retStr;
}
		
list<string> p1_39::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_39::getCurrentState() { return name; }

list<string> p1_39::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_39::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_27_3398823
	{
	list_of_enabled_signals.push_back("V2_inTRp1_27_3398823");
	}
	return list_of_enabled_signals;
}

void p1_39::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_27_3398823"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_27_3398823();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_27_3398823( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_27_3398823( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_27_3398823"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_27_3398823" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_27_3398823(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_27_3398823" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_27_3398823( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_27_3398823 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_27_3398823(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_27_3398823(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_27_3398823(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_27_3398823 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_27_3398823 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_27_3398823" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_27_3398823( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_27_3398823 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_39"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_39", NO_ENABLED_GUARDS));
	}
}

bool p1_39::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_39::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_39::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_27_3398823
bool p1_39::isEnabledV2_inTRp1_27_3398823(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_27_3398823
std::vector<int> p1_39::V2_inTRp1_27_3398823(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_27_3398823");
							smc->event_status_msg.push_back(" <!> State Update: p1_39 => p1_40");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_27_3398823"<<std::endl;
							// std::cout<<" <!> State Update: From p1_39 => p1_40"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_39 => p1_40");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_27_3398823 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_39");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_39!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_27_3398823
void p1_39::V2_inTRp1_27_3398823(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_27_3398823");
							smc->event_status_msg.push_back(" <!> State Update: p1_39 => p1_40");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_27_3398823"<<std::endl;
							std::cout<<" <!> State Update: From p1_39 => p1_40"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_39 => p1_40");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_40());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_27_3398823 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_39");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_39!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_27_3398823
void p1_39::V2_inTRp1_27_3398823(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_27_3398823");
				smc->event_status_msg.push_back(" <!> State Update: p1_39 => p1_40");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_27_3398823"<<std::endl;
				std::cout<<" <!> State Update: From p1_39 => p1_40"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_39 => p1_40");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_40());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_27_3398823 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_39");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_39!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p11_2 ***********/

list<string> p11_2::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p11_2::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp11_1_3398796");
	return retStr;
}
		
list<string> p11_2::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p11_2::getCurrentState() { return name; }

list<string> p11_2::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p11_2::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp11_1_3398796
	{
	list_of_enabled_signals.push_back("V2_inTRp11_1_3398796");
	}
	return list_of_enabled_signals;
}

void p11_2::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp11_1_3398796"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp11_1_3398796();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp11_1_3398796( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp11_1_3398796( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp11_1_3398796"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp11_1_3398796" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp11_1_3398796(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp11_1_3398796" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp11_1_3398796( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp11_1_3398796 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp11_1_3398796(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp11_1_3398796(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp11_1_3398796(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp11_1_3398796 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp11_1_3398796 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp11_1_3398796" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp11_1_3398796( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp11_1_3398796 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p11_2"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p11_2", NO_ENABLED_GUARDS));
	}
}

bool p11_2::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p11_2::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p11_2::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp11_1_3398796
bool p11_2::isEnabledV2_inTRp11_1_3398796(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp11_1_3398796
std::vector<int> p11_2::V2_inTRp11_1_3398796(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp11_1_3398796");
							smc->event_status_msg.push_back(" <!> State Update: p11_2 => p1_23");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp11_1_3398796"<<std::endl;
							// std::cout<<" <!> State Update: From p11_2 => p1_23"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p11_2 => p1_23");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp11_1_3398796 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p11_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p11_2!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp11_1_3398796
void p11_2::V2_inTRp11_1_3398796(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp11_1_3398796");
							smc->event_status_msg.push_back(" <!> State Update: p11_2 => p1_23");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp11_1_3398796"<<std::endl;
							std::cout<<" <!> State Update: From p11_2 => p1_23"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p11_2 => p1_23");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_23());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp11_1_3398796 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p11_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p11_2!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp11_1_3398796
void p11_2::V2_inTRp11_1_3398796(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp11_1_3398796");
				smc->event_status_msg.push_back(" <!> State Update: p11_2 => p1_23");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp11_1_3398796"<<std::endl;
				std::cout<<" <!> State Update: From p11_2 => p1_23"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p11_2 => p1_23");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_23());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp11_1_3398796 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p11_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p11_2!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_8 ***********/

list<string> p1_8::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_8::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_7_3398862");
	return retStr;
}
		
list<string> p1_8::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_8::getCurrentState() { return name; }

list<string> p1_8::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_8::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_7_3398862
	{
	list_of_enabled_signals.push_back("V2_inTRp1_7_3398862");
	}
	return list_of_enabled_signals;
}

void p1_8::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_7_3398862"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_7_3398862();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_7_3398862( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_7_3398862( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_7_3398862"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_7_3398862" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_7_3398862(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_7_3398862" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_7_3398862( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_7_3398862 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_7_3398862(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_7_3398862(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_7_3398862(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_7_3398862 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_7_3398862 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_7_3398862" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_7_3398862( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_7_3398862 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_8"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_8", NO_ENABLED_GUARDS));
	}
}

bool p1_8::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_8::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_8::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_7_3398862
bool p1_8::isEnabledV2_inTRp1_7_3398862(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_7_3398862
std::vector<int> p1_8::V2_inTRp1_7_3398862(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_7_3398862");
							smc->event_status_msg.push_back(" <!> State Update: p1_8 => p1_9");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_7_3398862"<<std::endl;
							// std::cout<<" <!> State Update: From p1_8 => p1_9"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_8 => p1_9");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_7_3398862 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_8");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_8!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_7_3398862
void p1_8::V2_inTRp1_7_3398862(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_7_3398862");
							smc->event_status_msg.push_back(" <!> State Update: p1_8 => p1_9");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_7_3398862"<<std::endl;
							std::cout<<" <!> State Update: From p1_8 => p1_9"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_8 => p1_9");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_9());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_7_3398862 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_8");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_8!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_7_3398862
void p1_8::V2_inTRp1_7_3398862(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_7_3398862");
				smc->event_status_msg.push_back(" <!> State Update: p1_8 => p1_9");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_7_3398862"<<std::endl;
				std::cout<<" <!> State Update: From p1_8 => p1_9"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_8 => p1_9");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_9());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_7_3398862 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_8");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_8!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p2_8 ***********/

list<string> p2_8::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_8::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_6_3398850");
	return retStr;
}
		
list<string> p2_8::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_8::getCurrentState() { return name; }

list<string> p2_8::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_8::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_6_3398850
	{
	list_of_enabled_signals.push_back("V2_inTRp2_6_3398850");
	}
	return list_of_enabled_signals;
}

void p2_8::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_6_3398850"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_6_3398850();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_6_3398850( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_6_3398850( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_6_3398850"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_6_3398850" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_6_3398850(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_6_3398850" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_6_3398850( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_6_3398850 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_6_3398850(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_6_3398850(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_6_3398850(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_6_3398850 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_6_3398850 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_6_3398850" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_6_3398850( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_6_3398850 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_8"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_8", NO_ENABLED_GUARDS));
	}
}

bool p2_8::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_8::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_8::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_6_3398850
bool p2_8::isEnabledV2_inTRp2_6_3398850(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_6_3398850
std::vector<int> p2_8::V2_inTRp2_6_3398850(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_6_3398850");
							smc->event_status_msg.push_back(" <!> State Update: p2_8 => p2_9");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_6_3398850"<<std::endl;
							// std::cout<<" <!> State Update: From p2_8 => p2_9"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_8 => p2_9");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_6_3398850 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_8");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_8!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_6_3398850
void p2_8::V2_inTRp2_6_3398850(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_6_3398850");
							smc->event_status_msg.push_back(" <!> State Update: p2_8 => p2_9");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_6_3398850"<<std::endl;
							std::cout<<" <!> State Update: From p2_8 => p2_9"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_8 => p2_9");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_9());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_6_3398850 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_8");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_8!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_6_3398850
void p2_8::V2_inTRp2_6_3398850(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_6_3398850");
				smc->event_status_msg.push_back(" <!> State Update: p2_8 => p2_9");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_6_3398850"<<std::endl;
				std::cout<<" <!> State Update: From p2_8 => p2_9"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_8 => p2_9");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_9());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_6_3398850 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_8");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_8!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_22 ***********/

list<string> p3_22::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_22::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_14_3398803");
	return retStr;
}
		
list<string> p3_22::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_22::getCurrentState() { return name; }

list<string> p3_22::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_22::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_14_3398803
	{
	list_of_enabled_signals.push_back("V2_inTRp3_14_3398803");
	}
	return list_of_enabled_signals;
}

void p3_22::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_14_3398803"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_14_3398803();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_14_3398803( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_14_3398803( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_14_3398803"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_14_3398803" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_14_3398803(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_14_3398803" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_14_3398803( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_14_3398803 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_14_3398803(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_14_3398803(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_14_3398803(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_14_3398803 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_14_3398803 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_14_3398803" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_14_3398803( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_14_3398803 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_22"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_22", NO_ENABLED_GUARDS));
	}
}

bool p3_22::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_22::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_22::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_14_3398803
bool p3_22::isEnabledV2_inTRp3_14_3398803(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_14_3398803
std::vector<int> p3_22::V2_inTRp3_14_3398803(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_14_3398803");
							smc->event_status_msg.push_back(" <!> State Update: p3_22 => p3_23");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_14_3398803"<<std::endl;
							// std::cout<<" <!> State Update: From p3_22 => p3_23"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_22 => p3_23");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_14_3398803 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_22");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_22!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_14_3398803
void p3_22::V2_inTRp3_14_3398803(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_14_3398803");
							smc->event_status_msg.push_back(" <!> State Update: p3_22 => p3_23");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_14_3398803"<<std::endl;
							std::cout<<" <!> State Update: From p3_22 => p3_23"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_22 => p3_23");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_23());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_14_3398803 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_22");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_22!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_14_3398803
void p3_22::V2_inTRp3_14_3398803(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_14_3398803");
				smc->event_status_msg.push_back(" <!> State Update: p3_22 => p3_23");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_14_3398803"<<std::endl;
				std::cout<<" <!> State Update: From p3_22 => p3_23"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_22 => p3_23");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_23());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_14_3398803 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_22");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_22!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_44 ***********/

list<string> p1_44::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_44::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_44::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_14_3398782");
	return retStr;
}

string p1_44::getCurrentState() { return name; }

list<string> p1_44::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_44::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_44::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_44"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_44", NO_ENABLED_GUARDS));
	}
}

bool p1_44::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_44::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_44::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_14_3398782
void p1_44::V2_outTRp1_14_3398782(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_14_3398782 -> Going From p1_44 to p1_45"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_44 => p1_45");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_14_3398782");
								smc->event_status_msg.push_back(" <!> State Update: p1_44 => p1_45");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_14_3398782"<<std::endl;
							std::cout<<" <!> State Update: p1_44 => p1_45"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_45());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_44");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_14_3398782
std::vector<int> p1_44::match_V2_outTRp1_14_3398782(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_14_3398782");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_44");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_14_3398782
void p1_44::V2_outTRp1_14_3398782(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_14_3398782 -> Going From p1_44 to p1_45"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_44 => p1_45");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_14_3398782");
							smc->event_status_msg.push_back(" <!> State Update: p1_44 => p1_45");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_14_3398782"<<std::endl;
						std::cout<<" <!> State Update: p1_44 => p1_45"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_45());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_44");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_44::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_14_3398782");
					smc->event_status_msg.push_back(" <!> State Update: p1_44 => p1_45");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_14_3398782"<<std::endl;
					std::cout<<" <!> State Update: p1_44 => p1_45"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_14_3398782();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_14_3398782");
					if(smc->m_outTRp1_14_3398782_Handler != nullptr)
					{
						smc->m_outTRp1_14_3398782_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_44 => p1_45");
					smc->setCurrent(new p1_45());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_44");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_44!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p9_2 ***********/

list<string> p9_2::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p9_2::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp9_1_3398800");
	return retStr;
}
		
list<string> p9_2::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p9_2::getCurrentState() { return name; }

list<string> p9_2::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p9_2::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp9_1_3398800
	{
	list_of_enabled_signals.push_back("V2_inTRp9_1_3398800");
	}
	return list_of_enabled_signals;
}

void p9_2::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp9_1_3398800"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp9_1_3398800();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp9_1_3398800( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp9_1_3398800( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp9_1_3398800"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp9_1_3398800" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp9_1_3398800(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp9_1_3398800" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp9_1_3398800( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp9_1_3398800 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp9_1_3398800(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp9_1_3398800(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp9_1_3398800(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp9_1_3398800 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp9_1_3398800 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp9_1_3398800" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp9_1_3398800( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp9_1_3398800 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p9_2"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p9_2", NO_ENABLED_GUARDS));
	}
}

bool p9_2::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p9_2::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p9_2::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp9_1_3398800
bool p9_2::isEnabledV2_inTRp9_1_3398800(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp9_1_3398800
std::vector<int> p9_2::V2_inTRp9_1_3398800(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp9_1_3398800");
							smc->event_status_msg.push_back(" <!> State Update: p9_2 => p9_3");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp9_1_3398800"<<std::endl;
							// std::cout<<" <!> State Update: From p9_2 => p9_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p9_2 => p9_3");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp9_1_3398800 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p9_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p9_2!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp9_1_3398800
void p9_2::V2_inTRp9_1_3398800(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp9_1_3398800");
							smc->event_status_msg.push_back(" <!> State Update: p9_2 => p9_3");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp9_1_3398800"<<std::endl;
							std::cout<<" <!> State Update: From p9_2 => p9_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p9_2 => p9_3");
							smc->setTextColor("ANY");
							smc->setCurrent(new p9_3());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp9_1_3398800 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p9_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p9_2!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp9_1_3398800
void p9_2::V2_inTRp9_1_3398800(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp9_1_3398800");
				smc->event_status_msg.push_back(" <!> State Update: p9_2 => p9_3");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp9_1_3398800"<<std::endl;
				std::cout<<" <!> State Update: From p9_2 => p9_3"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p9_2 => p9_3");
				smc->setTextColor("ANY");
				smc->setCurrent(new p9_3());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp9_1_3398800 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p9_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p9_2!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_3 ***********/

list<string> p3_3::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_3::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_3_3398842");
	return retStr;
}
		
list<string> p3_3::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_3::getCurrentState() { return name; }

list<string> p3_3::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_3::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_3_3398842
	{
	list_of_enabled_signals.push_back("V2_inTRp3_3_3398842");
	}
	return list_of_enabled_signals;
}

void p3_3::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_3_3398842"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_3_3398842();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_3_3398842( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_3_3398842( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_3_3398842"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_3_3398842" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_3_3398842(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_3_3398842" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_3_3398842( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_3_3398842 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_3_3398842(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_3_3398842(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_3_3398842(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_3_3398842 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_3_3398842 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_3_3398842" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_3_3398842( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_3_3398842 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_3"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_3", NO_ENABLED_GUARDS));
	}
}

bool p3_3::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_3::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_3::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_3_3398842
bool p3_3::isEnabledV2_inTRp3_3_3398842(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_3_3398842
std::vector<int> p3_3::V2_inTRp3_3_3398842(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_3_3398842");
							smc->event_status_msg.push_back(" <!> State Update: p3_3 => p3_4");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_3_3398842"<<std::endl;
							// std::cout<<" <!> State Update: From p3_3 => p3_4"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_3 => p3_4");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_3_3398842 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_3!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_3_3398842
void p3_3::V2_inTRp3_3_3398842(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_3_3398842");
							smc->event_status_msg.push_back(" <!> State Update: p3_3 => p3_4");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_3_3398842"<<std::endl;
							std::cout<<" <!> State Update: From p3_3 => p3_4"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_3 => p3_4");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_4());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_3_3398842 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_3!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_3_3398842
void p3_3::V2_inTRp3_3_3398842(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_3_3398842");
				smc->event_status_msg.push_back(" <!> State Update: p3_3 => p3_4");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_3_3398842"<<std::endl;
				std::cout<<" <!> State Update: From p3_3 => p3_4"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_3 => p3_4");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_4());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_3_3398842 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_3!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p9_6 ***********/

list<string> p9_6::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p9_6::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p9_6::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp9_1_3398789");
	return retStr;
}

string p9_6::getCurrentState() { return name; }

list<string> p9_6::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p9_6::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p9_6::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p9_6"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p9_6", NO_ENABLED_GUARDS));
	}
}

bool p9_6::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p9_6::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p9_6::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp9_1_3398789
void p9_6::V2_outTRp9_1_3398789(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp9_1_3398789 -> Going From p9_6 to p3_20"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p9_6 => p3_20");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_1_3398789");
								smc->event_status_msg.push_back(" <!> State Update: p9_6 => p3_20");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_1_3398789"<<std::endl;
							std::cout<<" <!> State Update: p9_6 => p3_20"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_20());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp9_1_3398789
std::vector<int> p9_6::match_V2_outTRp9_1_3398789(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp9_1_3398789");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp9_1_3398789
void p9_6::V2_outTRp9_1_3398789(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp9_1_3398789 -> Going From p9_6 to p3_20"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p9_6 => p3_20");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_1_3398789");
							smc->event_status_msg.push_back(" <!> State Update: p9_6 => p3_20");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_1_3398789"<<std::endl;
						std::cout<<" <!> State Update: p9_6 => p3_20"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_20());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p9_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p9_6::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp9_1_3398789");
					smc->event_status_msg.push_back(" <!> State Update: p9_6 => p3_20");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp9_1_3398789"<<std::endl;
					std::cout<<" <!> State Update: p9_6 => p3_20"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp9_1_3398789();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp9_1_3398789");
					if(smc->m_outTRp9_1_3398789_Handler != nullptr)
					{
						smc->m_outTRp9_1_3398789_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p9_6 => p3_20");
					smc->setCurrent(new p3_20());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p9_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p9_6!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_32 ***********/

list<string> p1_32::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_32::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_32::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_10_3398769");
	return retStr;
}

string p1_32::getCurrentState() { return name; }

list<string> p1_32::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_32::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_32::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_32"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_32", NO_ENABLED_GUARDS));
	}
}

bool p1_32::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_32::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_32::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_10_3398769
void p1_32::V2_outTRp1_10_3398769(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_10_3398769 -> Going From p1_32 to p1_33"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_32 => p1_33");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_10_3398769");
								smc->event_status_msg.push_back(" <!> State Update: p1_32 => p1_33");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_10_3398769"<<std::endl;
							std::cout<<" <!> State Update: p1_32 => p1_33"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_33());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_32");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_10_3398769
std::vector<int> p1_32::match_V2_outTRp1_10_3398769(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_10_3398769");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_32");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_10_3398769
void p1_32::V2_outTRp1_10_3398769(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_10_3398769 -> Going From p1_32 to p1_33"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_32 => p1_33");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_10_3398769");
							smc->event_status_msg.push_back(" <!> State Update: p1_32 => p1_33");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_10_3398769"<<std::endl;
						std::cout<<" <!> State Update: p1_32 => p1_33"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_33());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_32");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_32::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_10_3398769");
					smc->event_status_msg.push_back(" <!> State Update: p1_32 => p1_33");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_10_3398769"<<std::endl;
					std::cout<<" <!> State Update: p1_32 => p1_33"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_10_3398769();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_10_3398769");
					if(smc->m_outTRp1_10_3398769_Handler != nullptr)
					{
						smc->m_outTRp1_10_3398769_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_32 => p1_33");
					smc->setCurrent(new p1_33());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_32");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_32!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_22 ***********/

list<string> p1_22::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_22::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_22::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_7_3398793");
	retStr.push_back("V2_outTRp1_7_3398794");
	return retStr;
}

string p1_22::getCurrentState() { return name; }

list<string> p1_22::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_22::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_22::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_22"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_22", NO_ENABLED_GUARDS));
	}
}

bool p1_22::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_22::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_22::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true ||   true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_7_3398793
void p1_22::V2_outTRp1_7_3398793(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_7_3398793 -> Going From p1_22 to p10_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_22 => p10_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_7_3398793");
								smc->event_status_msg.push_back(" <!> State Update: p1_22 => p10_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_7_3398793"<<std::endl;
							std::cout<<" <!> State Update: p1_22 => p10_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p10_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_22");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Deterministic Notification Handler: V2_outTRp1_7_3398794
void p1_22::V2_outTRp1_7_3398794(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_7_3398794 -> Going From p1_22 to p11_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_22 => p11_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_7_3398794");
								smc->event_status_msg.push_back(" <!> State Update: p1_22 => p11_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_7_3398794"<<std::endl;
							std::cout<<" <!> State Update: p1_22 => p11_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p11_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_22");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_7_3398793
std::vector<int> p1_22::match_V2_outTRp1_7_3398793(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_7_3398793");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_22");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Validator: V2_outTRp1_7_3398794
std::vector<int> p1_22::match_V2_outTRp1_7_3398794(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_7_3398794");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_22");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_7_3398793
void p1_22::V2_outTRp1_7_3398793(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_7_3398793 -> Going From p1_22 to p10_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_22 => p10_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_7_3398793");
							smc->event_status_msg.push_back(" <!> State Update: p1_22 => p10_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_7_3398793"<<std::endl;
						std::cout<<" <!> State Update: p1_22 => p10_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p10_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_22");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Handler: V2_outTRp1_7_3398794
void p1_22::V2_outTRp1_7_3398794(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_7_3398794 -> Going From p1_22 to p11_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_22 => p11_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_7_3398794");
							smc->event_status_msg.push_back(" <!> State Update: p1_22 => p11_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_7_3398794"<<std::endl;
						std::cout<<" <!> State Update: p1_22 => p11_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p11_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_22");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_22::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true ||   true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %2; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_7_3398793");
					smc->event_status_msg.push_back(" <!> State Update: p1_22 => p10_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_7_3398793"<<std::endl;
					std::cout<<" <!> State Update: p1_22 => p10_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_7_3398793();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_7_3398793");
					if(smc->m_outTRp1_7_3398793_Handler != nullptr)
					{
						smc->m_outTRp1_7_3398793_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_22 => p10_1");
					smc->setCurrent(new p10_1());
					delete this;
					break;
		case 1:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_7_3398794");
					smc->event_status_msg.push_back(" <!> State Update: p1_22 => p11_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_7_3398794"<<std::endl;
					std::cout<<" <!> State Update: p1_22 => p11_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_7_3398794();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_7_3398794");
					if(smc->m_outTRp1_7_3398794_Handler != nullptr)
					{
						smc->m_outTRp1_7_3398794_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_22 => p11_1");
					smc->setCurrent(new p11_1());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_22");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_22!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_42 ***********/

list<string> p1_42::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_42::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_42::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_1_3398718");
	return retStr;
}

string p1_42::getCurrentState() { return name; }

list<string> p1_42::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_42::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_42::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_42"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_42", NO_ENABLED_GUARDS));
	}
}

bool p1_42::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_42::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_42::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_1_3398718
void p1_42::V2_outTRp1_1_3398718(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_1_3398718 -> Going From p1_42 to p1_43"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_42 => p1_43");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398718");
								smc->event_status_msg.push_back(" <!> State Update: p1_42 => p1_43");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398718"<<std::endl;
							std::cout<<" <!> State Update: p1_42 => p1_43"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_43());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_42");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_1_3398718
std::vector<int> p1_42::match_V2_outTRp1_1_3398718(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_1_3398718");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_42");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_1_3398718
void p1_42::V2_outTRp1_1_3398718(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_1_3398718 -> Going From p1_42 to p1_43"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_42 => p1_43");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398718");
							smc->event_status_msg.push_back(" <!> State Update: p1_42 => p1_43");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398718"<<std::endl;
						std::cout<<" <!> State Update: p1_42 => p1_43"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_43());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_42");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_42::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398718");
					smc->event_status_msg.push_back(" <!> State Update: p1_42 => p1_43");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398718"<<std::endl;
					std::cout<<" <!> State Update: p1_42 => p1_43"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_1_3398718();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_1_3398718");
					if(smc->m_outTRp1_1_3398718_Handler != nullptr)
					{
						smc->m_outTRp1_1_3398718_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_42 => p1_43");
					smc->setCurrent(new p1_43());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_42");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_42!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_43 ***********/

list<string> p3_43::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_43::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_34_3398860");
	return retStr;
}
		
list<string> p3_43::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_43::getCurrentState() { return name; }

list<string> p3_43::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_43::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_34_3398860
	{
	list_of_enabled_signals.push_back("V2_inTRp3_34_3398860");
	}
	return list_of_enabled_signals;
}

void p3_43::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_34_3398860"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_34_3398860();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_34_3398860( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_34_3398860( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_34_3398860"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_34_3398860" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_34_3398860(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_34_3398860" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_34_3398860( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_34_3398860 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_34_3398860(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_34_3398860(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_34_3398860(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_34_3398860 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_34_3398860 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_34_3398860" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_34_3398860( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_34_3398860 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_43"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_43", NO_ENABLED_GUARDS));
	}
}

bool p3_43::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_43::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_43::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_34_3398860
bool p3_43::isEnabledV2_inTRp3_34_3398860(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_34_3398860
std::vector<int> p3_43::V2_inTRp3_34_3398860(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_34_3398860");
							smc->event_status_msg.push_back(" <!> State Update: p3_43 => p3_44");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_34_3398860"<<std::endl;
							// std::cout<<" <!> State Update: From p3_43 => p3_44"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_43 => p3_44");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_34_3398860 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_43");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_43!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_34_3398860
void p3_43::V2_inTRp3_34_3398860(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_34_3398860");
							smc->event_status_msg.push_back(" <!> State Update: p3_43 => p3_44");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_34_3398860"<<std::endl;
							std::cout<<" <!> State Update: From p3_43 => p3_44"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_43 => p3_44");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_44());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_34_3398860 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_43");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_43!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_34_3398860
void p3_43::V2_inTRp3_34_3398860(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_34_3398860");
				smc->event_status_msg.push_back(" <!> State Update: p3_43 => p3_44");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_34_3398860"<<std::endl;
				std::cout<<" <!> State Update: From p3_43 => p3_44"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_43 => p3_44");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_44());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_34_3398860 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_43");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_43!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_28 ***********/

list<string> p3_28::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_28::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_11_3398770");
	return retStr;
}
		
list<string> p3_28::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_28::getCurrentState() { return name; }

list<string> p3_28::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_28::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_11_3398770
	{
	list_of_enabled_signals.push_back("V2_inTRp3_11_3398770");
	}
	return list_of_enabled_signals;
}

void p3_28::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_11_3398770"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_11_3398770();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_11_3398770( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_11_3398770( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_11_3398770"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_11_3398770" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_11_3398770(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_11_3398770" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_11_3398770( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_11_3398770 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_11_3398770(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_11_3398770(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_11_3398770(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_11_3398770 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_11_3398770 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_11_3398770" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_11_3398770( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_11_3398770 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_28"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_28", NO_ENABLED_GUARDS));
	}
}

bool p3_28::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_28::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_28::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_11_3398770
bool p3_28::isEnabledV2_inTRp3_11_3398770(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_11_3398770
std::vector<int> p3_28::V2_inTRp3_11_3398770(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_11_3398770");
							smc->event_status_msg.push_back(" <!> State Update: p3_28 => p3_29");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_11_3398770"<<std::endl;
							// std::cout<<" <!> State Update: From p3_28 => p3_29"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_28 => p3_29");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_11_3398770 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_28");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_28!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_11_3398770
void p3_28::V2_inTRp3_11_3398770(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_11_3398770");
							smc->event_status_msg.push_back(" <!> State Update: p3_28 => p3_29");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_11_3398770"<<std::endl;
							std::cout<<" <!> State Update: From p3_28 => p3_29"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_28 => p3_29");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_29());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_11_3398770 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_28");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_28!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_11_3398770
void p3_28::V2_inTRp3_11_3398770(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_11_3398770");
				smc->event_status_msg.push_back(" <!> State Update: p3_28 => p3_29");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_11_3398770"<<std::endl;
				std::cout<<" <!> State Update: From p3_28 => p3_29"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_28 => p3_29");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_29());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_11_3398770 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_28");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_28!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_29 ***********/

list<string> p1_29::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_29::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_8_3398767");
	return retStr;
}
		
list<string> p1_29::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_29::getCurrentState() { return name; }

list<string> p1_29::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_29::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_8_3398767
	{
	list_of_enabled_signals.push_back("V2_inTRp1_8_3398767");
	}
	return list_of_enabled_signals;
}

void p1_29::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_8_3398767"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_8_3398767();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_8_3398767( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_8_3398767( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_8_3398767"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_8_3398767" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_8_3398767(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_8_3398767" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_8_3398767( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_8_3398767 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_8_3398767(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_8_3398767(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_8_3398767(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_8_3398767 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_8_3398767 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_8_3398767" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_8_3398767( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_8_3398767 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_29"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_29", NO_ENABLED_GUARDS));
	}
}

bool p1_29::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_29::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_29::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_8_3398767
bool p1_29::isEnabledV2_inTRp1_8_3398767(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_8_3398767
std::vector<int> p1_29::V2_inTRp1_8_3398767(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_8_3398767");
							smc->event_status_msg.push_back(" <!> State Update: p1_29 => p1_30");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_8_3398767"<<std::endl;
							// std::cout<<" <!> State Update: From p1_29 => p1_30"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_29 => p1_30");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_8_3398767 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_29");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_29!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_8_3398767
void p1_29::V2_inTRp1_8_3398767(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_8_3398767");
							smc->event_status_msg.push_back(" <!> State Update: p1_29 => p1_30");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_8_3398767"<<std::endl;
							std::cout<<" <!> State Update: From p1_29 => p1_30"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_29 => p1_30");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_30());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_8_3398767 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_29");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_29!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_8_3398767
void p1_29::V2_inTRp1_8_3398767(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_8_3398767");
				smc->event_status_msg.push_back(" <!> State Update: p1_29 => p1_30");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_8_3398767"<<std::endl;
				std::cout<<" <!> State Update: From p1_29 => p1_30"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_29 => p1_30");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_30());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_8_3398767 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_29");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_29!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p4_6 ***********/

list<string> p4_6::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p4_6::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p4_6::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp4_1_3398744");
	return retStr;
}

string p4_6::getCurrentState() { return name; }

list<string> p4_6::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p4_6::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p4_6::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p4_6"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p4_6", NO_ENABLED_GUARDS));
	}
}

bool p4_6::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p4_6::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p4_6::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp4_1_3398744
void p4_6::V2_outTRp4_1_3398744(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp4_1_3398744 -> Going From p4_6 to p1_13"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p4_6 => p1_13");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_1_3398744");
								smc->event_status_msg.push_back(" <!> State Update: p4_6 => p1_13");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_1_3398744"<<std::endl;
							std::cout<<" <!> State Update: p4_6 => p1_13"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_13());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp4_1_3398744
std::vector<int> p4_6::match_V2_outTRp4_1_3398744(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp4_1_3398744");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp4_1_3398744
void p4_6::V2_outTRp4_1_3398744(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp4_1_3398744 -> Going From p4_6 to p1_13"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p4_6 => p1_13");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_1_3398744");
							smc->event_status_msg.push_back(" <!> State Update: p4_6 => p1_13");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_1_3398744"<<std::endl;
						std::cout<<" <!> State Update: p4_6 => p1_13"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_13());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p4_6::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_1_3398744");
					smc->event_status_msg.push_back(" <!> State Update: p4_6 => p1_13");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_1_3398744"<<std::endl;
					std::cout<<" <!> State Update: p4_6 => p1_13"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp4_1_3398744();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp4_1_3398744");
					if(smc->m_outTRp4_1_3398744_Handler != nullptr)
					{
						smc->m_outTRp4_1_3398744_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p4_6 => p1_13");
					smc->setCurrent(new p1_13());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p4_6");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p4_6!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p4_2 ***********/

list<string> p4_2::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p4_2::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p4_2::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp4_2_3398873");
	return retStr;
}

string p4_2::getCurrentState() { return name; }

list<string> p4_2::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p4_2::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p4_2::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p4_2"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p4_2", NO_ENABLED_GUARDS));
	}
}

bool p4_2::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p4_2::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p4_2::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp4_2_3398873
void p4_2::V2_outTRp4_2_3398873(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp4_2_3398873 -> Going From p4_2 to p4_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p4_2 => p4_3");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_2_3398873");
								smc->event_status_msg.push_back(" <!> State Update: p4_2 => p4_3");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_2_3398873"<<std::endl;
							std::cout<<" <!> State Update: p4_2 => p4_3"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p4_3());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp4_2_3398873
std::vector<int> p4_2::match_V2_outTRp4_2_3398873(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp4_2_3398873");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp4_2_3398873
void p4_2::V2_outTRp4_2_3398873(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp4_2_3398873 -> Going From p4_2 to p4_3"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p4_2 => p4_3");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_2_3398873");
							smc->event_status_msg.push_back(" <!> State Update: p4_2 => p4_3");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_2_3398873"<<std::endl;
						std::cout<<" <!> State Update: p4_2 => p4_3"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p4_3());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p4_2::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_2_3398873");
					smc->event_status_msg.push_back(" <!> State Update: p4_2 => p4_3");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_2_3398873"<<std::endl;
					std::cout<<" <!> State Update: p4_2 => p4_3"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp4_2_3398873();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp4_2_3398873");
					if(smc->m_outTRp4_2_3398873_Handler != nullptr)
					{
						smc->m_outTRp4_2_3398873_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p4_2 => p4_3");
					smc->setCurrent(new p4_3());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p4_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p4_2!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p14_1 ***********/

list<string> p14_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p14_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp14_1_3398841");
	return retStr;
}
		
list<string> p14_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p14_1::getCurrentState() { return name; }

list<string> p14_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p14_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp14_1_3398841
	{
	list_of_enabled_signals.push_back("V2_inTRp14_1_3398841");
	}
	return list_of_enabled_signals;
}

void p14_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp14_1_3398841"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp14_1_3398841();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp14_1_3398841( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp14_1_3398841( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp14_1_3398841"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp14_1_3398841" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp14_1_3398841(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp14_1_3398841" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp14_1_3398841( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp14_1_3398841 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp14_1_3398841(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp14_1_3398841(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp14_1_3398841(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp14_1_3398841 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp14_1_3398841 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp14_1_3398841" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp14_1_3398841( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp14_1_3398841 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p14_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p14_1", NO_ENABLED_GUARDS));
	}
}

bool p14_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p14_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p14_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp14_1_3398841
bool p14_1::isEnabledV2_inTRp14_1_3398841(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp14_1_3398841
std::vector<int> p14_1::V2_inTRp14_1_3398841(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp14_1_3398841");
							smc->event_status_msg.push_back(" <!> State Update: p14_1 => p3_10");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp14_1_3398841"<<std::endl;
							// std::cout<<" <!> State Update: From p14_1 => p3_10"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p14_1 => p3_10");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp14_1_3398841 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p14_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p14_1!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp14_1_3398841
void p14_1::V2_inTRp14_1_3398841(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp14_1_3398841");
							smc->event_status_msg.push_back(" <!> State Update: p14_1 => p3_10");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp14_1_3398841"<<std::endl;
							std::cout<<" <!> State Update: From p14_1 => p3_10"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p14_1 => p3_10");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_10());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp14_1_3398841 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p14_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p14_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp14_1_3398841
void p14_1::V2_inTRp14_1_3398841(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp14_1_3398841");
				smc->event_status_msg.push_back(" <!> State Update: p14_1 => p3_10");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp14_1_3398841"<<std::endl;
				std::cout<<" <!> State Update: From p14_1 => p3_10"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p14_1 => p3_10");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_10());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp14_1_3398841 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p14_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p14_1!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_4 ***********/

list<string> p3_4::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_4::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_4::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_2_3398735");
	return retStr;
}

string p3_4::getCurrentState() { return name; }

list<string> p3_4::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_4::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_4::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_4"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_4", NO_ENABLED_GUARDS));
	}
}

bool p3_4::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_4::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_4::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_2_3398735
void p3_4::V2_outTRp3_2_3398735(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_2_3398735 -> Going From p3_4 to p3_6"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_4 => p3_6");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_2_3398735");
								smc->event_status_msg.push_back(" <!> State Update: p3_4 => p3_6");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_2_3398735"<<std::endl;
							std::cout<<" <!> State Update: p3_4 => p3_6"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_6());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_2_3398735
std::vector<int> p3_4::match_V2_outTRp3_2_3398735(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_2_3398735");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_2_3398735
void p3_4::V2_outTRp3_2_3398735(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_2_3398735 -> Going From p3_4 to p3_6"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_4 => p3_6");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_2_3398735");
							smc->event_status_msg.push_back(" <!> State Update: p3_4 => p3_6");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_2_3398735"<<std::endl;
						std::cout<<" <!> State Update: p3_4 => p3_6"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_6());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_4::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_2_3398735");
					smc->event_status_msg.push_back(" <!> State Update: p3_4 => p3_6");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_2_3398735"<<std::endl;
					std::cout<<" <!> State Update: p3_4 => p3_6"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_2_3398735();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_2_3398735");
					if(smc->m_outTRp3_2_3398735_Handler != nullptr)
					{
						smc->m_outTRp3_2_3398735_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_4 => p3_6");
					smc->setCurrent(new p3_6());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_4!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_7 ***********/

list<string> p1_7::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_7::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_5_3398825");
	return retStr;
}
		
list<string> p1_7::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_7::getCurrentState() { return name; }

list<string> p1_7::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_7::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_5_3398825
	{
	list_of_enabled_signals.push_back("V2_inTRp1_5_3398825");
	}
	return list_of_enabled_signals;
}

void p1_7::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_5_3398825"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_5_3398825();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_5_3398825( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_5_3398825( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_5_3398825"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_5_3398825" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_5_3398825(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_5_3398825" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_5_3398825( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_5_3398825 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_5_3398825(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_5_3398825(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_5_3398825(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_5_3398825 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_5_3398825 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_5_3398825" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_5_3398825( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_5_3398825 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_7"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_7", NO_ENABLED_GUARDS));
	}
}

bool p1_7::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_7::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_7::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_5_3398825
bool p1_7::isEnabledV2_inTRp1_5_3398825(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_5_3398825
std::vector<int> p1_7::V2_inTRp1_5_3398825(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_5_3398825");
							smc->event_status_msg.push_back(" <!> State Update: p1_7 => p1_8");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_5_3398825"<<std::endl;
							// std::cout<<" <!> State Update: From p1_7 => p1_8"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_7 => p1_8");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_5_3398825 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_7");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_7!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_5_3398825
void p1_7::V2_inTRp1_5_3398825(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_5_3398825");
							smc->event_status_msg.push_back(" <!> State Update: p1_7 => p1_8");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_5_3398825"<<std::endl;
							std::cout<<" <!> State Update: From p1_7 => p1_8"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_7 => p1_8");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_8());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_5_3398825 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_7");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_7!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_5_3398825
void p1_7::V2_inTRp1_5_3398825(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_5_3398825");
				smc->event_status_msg.push_back(" <!> State Update: p1_7 => p1_8");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_5_3398825"<<std::endl;
				std::cout<<" <!> State Update: From p1_7 => p1_8"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_7 => p1_8");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_8());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_5_3398825 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_7");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_7!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p1_17 ***********/

list<string> p1_17::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_17::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_17::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_7_3398804");
	return retStr;
}

string p1_17::getCurrentState() { return name; }

list<string> p1_17::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_17::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_17::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_17"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_17", NO_ENABLED_GUARDS));
	}
}

bool p1_17::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_17::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_17::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_7_3398804
void p1_17::V2_outTRp1_7_3398804(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_7_3398804 -> Going From p1_17 to p1_18"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_17 => p1_18");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_7_3398804");
								smc->event_status_msg.push_back(" <!> State Update: p1_17 => p1_18");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_7_3398804"<<std::endl;
							std::cout<<" <!> State Update: p1_17 => p1_18"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_18());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_7_3398804
std::vector<int> p1_17::match_V2_outTRp1_7_3398804(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_7_3398804");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_7_3398804
void p1_17::V2_outTRp1_7_3398804(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_7_3398804 -> Going From p1_17 to p1_18"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_17 => p1_18");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_7_3398804");
							smc->event_status_msg.push_back(" <!> State Update: p1_17 => p1_18");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_7_3398804"<<std::endl;
						std::cout<<" <!> State Update: p1_17 => p1_18"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_18());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_17::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_7_3398804");
					smc->event_status_msg.push_back(" <!> State Update: p1_17 => p1_18");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_7_3398804"<<std::endl;
					std::cout<<" <!> State Update: p1_17 => p1_18"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_7_3398804();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_7_3398804");
					if(smc->m_outTRp1_7_3398804_Handler != nullptr)
					{
						smc->m_outTRp1_7_3398804_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_17 => p1_18");
					smc->setCurrent(new p1_18());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_17");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_17!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p2_14 ***********/

list<string> p2_14::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_14::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p2_14::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp2_6_3398762");
	return retStr;
}

string p2_14::getCurrentState() { return name; }

list<string> p2_14::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_14::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p2_14::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_14"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_14", NO_ENABLED_GUARDS));
	}
}

bool p2_14::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_14::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_14::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp2_6_3398762
void p2_14::V2_outTRp2_6_3398762(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp2_6_3398762 -> Going From p2_14 to p2_15"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_14 => p2_15");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_6_3398762");
								smc->event_status_msg.push_back(" <!> State Update: p2_14 => p2_15");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_6_3398762"<<std::endl;
							std::cout<<" <!> State Update: p2_14 => p2_15"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_15());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp2_6_3398762
std::vector<int> p2_14::match_V2_outTRp2_6_3398762(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp2_6_3398762");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp2_6_3398762
void p2_14::V2_outTRp2_6_3398762(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp2_6_3398762 -> Going From p2_14 to p2_15"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p2_14 => p2_15");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_6_3398762");
							smc->event_status_msg.push_back(" <!> State Update: p2_14 => p2_15");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_6_3398762"<<std::endl;
						std::cout<<" <!> State Update: p2_14 => p2_15"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p2_15());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p2_14::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_6_3398762");
					smc->event_status_msg.push_back(" <!> State Update: p2_14 => p2_15");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_6_3398762"<<std::endl;
					std::cout<<" <!> State Update: p2_14 => p2_15"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp2_6_3398762();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp2_6_3398762");
					if(smc->m_outTRp2_6_3398762_Handler != nullptr)
					{
						smc->m_outTRp2_6_3398762_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p2_14 => p2_15");
					smc->setCurrent(new p2_15());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_14!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p2_13 ***********/

list<string> p2_13::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_13::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p2_13::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp2_9_3398848");
	return retStr;
}

string p2_13::getCurrentState() { return name; }

list<string> p2_13::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_13::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p2_13::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_13"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_13", NO_ENABLED_GUARDS));
	}
}

bool p2_13::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_13::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_13::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp2_9_3398848
void p2_13::V2_outTRp2_9_3398848(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp2_9_3398848 -> Going From p2_13 to p2_14"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_13 => p2_14");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_9_3398848");
								smc->event_status_msg.push_back(" <!> State Update: p2_13 => p2_14");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_9_3398848"<<std::endl;
							std::cout<<" <!> State Update: p2_13 => p2_14"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_14());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp2_9_3398848
std::vector<int> p2_13::match_V2_outTRp2_9_3398848(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp2_9_3398848");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp2_9_3398848
void p2_13::V2_outTRp2_9_3398848(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp2_9_3398848 -> Going From p2_13 to p2_14"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p2_13 => p2_14");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_9_3398848");
							smc->event_status_msg.push_back(" <!> State Update: p2_13 => p2_14");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_9_3398848"<<std::endl;
						std::cout<<" <!> State Update: p2_13 => p2_14"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p2_14());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p2_13::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_9_3398848");
					smc->event_status_msg.push_back(" <!> State Update: p2_13 => p2_14");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_9_3398848"<<std::endl;
					std::cout<<" <!> State Update: p2_13 => p2_14"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp2_9_3398848();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp2_9_3398848");
					if(smc->m_outTRp2_9_3398848_Handler != nullptr)
					{
						smc->m_outTRp2_9_3398848_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p2_13 => p2_14");
					smc->setCurrent(new p2_14());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_13");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_13!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_14 ***********/

list<string> p1_14::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_14::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp1_3_3398758");
	return retStr;
}
		
list<string> p1_14::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p1_14::getCurrentState() { return name; }

list<string> p1_14::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_14::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp1_3_3398758
	{
	list_of_enabled_signals.push_back("V2_inTRp1_3_3398758");
	}
	return list_of_enabled_signals;
}

void p1_14::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp1_3_3398758"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp1_3_3398758();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp1_3_3398758( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp1_3_3398758( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp1_3_3398758"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp1_3_3398758" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp1_3_3398758(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp1_3_3398758" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_3_3398758( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_3_3398758 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp1_3_3398758(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp1_3_3398758(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp1_3_3398758(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp1_3_3398758 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp1_3_3398758 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp1_3_3398758" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp1_3_3398758( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp1_3_3398758 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_14"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_14", NO_ENABLED_GUARDS));
	}
}

bool p1_14::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_14::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_14::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp1_3_3398758
bool p1_14::isEnabledV2_inTRp1_3_3398758(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp1_3_3398758
std::vector<int> p1_14::V2_inTRp1_3_3398758(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_3_3398758");
							smc->event_status_msg.push_back(" <!> State Update: p1_14 => p1_15");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_3_3398758"<<std::endl;
							// std::cout<<" <!> State Update: From p1_14 => p1_15"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_14 => p1_15");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_3_3398758 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_14!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp1_3_3398758
void p1_14::V2_inTRp1_3_3398758(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_3_3398758");
							smc->event_status_msg.push_back(" <!> State Update: p1_14 => p1_15");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_3_3398758"<<std::endl;
							std::cout<<" <!> State Update: From p1_14 => p1_15"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_14 => p1_15");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_15());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_3_3398758 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_14!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp1_3_3398758
void p1_14::V2_inTRp1_3_3398758(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp1_3_3398758");
				smc->event_status_msg.push_back(" <!> State Update: p1_14 => p1_15");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp1_3_3398758"<<std::endl;
				std::cout<<" <!> State Update: From p1_14 => p1_15"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p1_14 => p1_15");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_15());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp1_3_3398758 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_14");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p1_14!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p2_10 ***********/

list<string> p2_10::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_10::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_3_3398754");
	retStr.push_back("V2_inTRp2_4_3398772");
	return retStr;
}
		
list<string> p2_10::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_10::getCurrentState() { return name; }

list<string> p2_10::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_10::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_3_3398754
	{
	list_of_enabled_signals.push_back("V2_inTRp2_3_3398754");
	}
	// Signal Name: V2_inTRp2_4_3398772
	{
	list_of_enabled_signals.push_back("V2_inTRp2_4_3398772");
	}
	return list_of_enabled_signals;
}

void p2_10::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_3_3398754"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_3_3398754();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_3_3398754( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_3_3398754( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		if(!(*it).compare("V2_inTRp2_4_3398772"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_4_3398772();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_4_3398772( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_4_3398772( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_3_3398754"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_3_3398754" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_3_3398754(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_3_3398754" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_3_3398754( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_3_3398754 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_3_3398754(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_3_3398754(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_3_3398754(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_3_3398754 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_3_3398754 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_3_3398754" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_3_3398754( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_3_3398754 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		if(!(*it).compare("V2_inTRp2_4_3398772"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_4_3398772" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_4_3398772(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_4_3398772" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_4_3398772( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_4_3398772 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_4_3398772(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_4_3398772(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_4_3398772(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_4_3398772 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_4_3398772 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_4_3398772" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_4_3398772( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_4_3398772 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_10"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_10", NO_ENABLED_GUARDS));
	}
}

bool p2_10::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_10::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_10::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_3_3398754
bool p2_10::isEnabledV2_inTRp2_3_3398754(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Enabling Test for Signal: V2_inTRp2_4_3398772
bool p2_10::isEnabledV2_inTRp2_4_3398772(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_3_3398754
std::vector<int> p2_10::V2_inTRp2_3_3398754(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_3_3398754");
							smc->event_status_msg.push_back(" <!> State Update: p2_10 => p2_11");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_3_3398754"<<std::endl;
							// std::cout<<" <!> State Update: From p2_10 => p2_11"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_10 => p2_11");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_3_3398754 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Signal Context NI Validator: V2_inTRp2_4_3398772
std::vector<int> p2_10::V2_inTRp2_4_3398772(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_4_3398772");
							smc->event_status_msg.push_back(" <!> State Update: p2_10 => p6_1");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_4_3398772"<<std::endl;
							// std::cout<<" <!> State Update: From p2_10 => p6_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_10 => p6_1");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_4_3398772 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_3_3398754
void p2_10::V2_inTRp2_3_3398754(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_3_3398754");
							smc->event_status_msg.push_back(" <!> State Update: p2_10 => p2_11");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_3_3398754"<<std::endl;
							std::cout<<" <!> State Update: From p2_10 => p2_11"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_10 => p2_11");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_11());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_3_3398754 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Deterministic Signal Handler: V2_inTRp2_4_3398772
void p2_10::V2_inTRp2_4_3398772(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_4_3398772");
							smc->event_status_msg.push_back(" <!> State Update: p2_10 => p6_1");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_4_3398772"<<std::endl;
							std::cout<<" <!> State Update: From p2_10 => p6_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_10 => p6_1");
							smc->setTextColor("ANY");
							smc->setCurrent(new p6_1());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_4_3398772 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_3_3398754
void p2_10::V2_inTRp2_3_3398754(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_3_3398754");
				smc->event_status_msg.push_back(" <!> State Update: p2_10 => p2_11");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_3_3398754"<<std::endl;
				std::cout<<" <!> State Update: From p2_10 => p2_11"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_10 => p2_11");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_11());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_3_3398754 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_4_3398772
void p2_10::V2_inTRp2_4_3398772(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_4_3398772");
				smc->event_status_msg.push_back(" <!> State Update: p2_10 => p6_1");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_4_3398772"<<std::endl;
				std::cout<<" <!> State Update: From p2_10 => p6_1"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_10 => p6_1");
				smc->setTextColor("ANY");
				smc->setCurrent(new p6_1());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_4_3398772 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_10!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p2_9 ***********/

list<string> p2_9::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_9::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p2_9::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp2_7_3398851");
	return retStr;
}

string p2_9::getCurrentState() { return name; }

list<string> p2_9::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_9::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p2_9::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_9"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_9", NO_ENABLED_GUARDS));
	}
}

bool p2_9::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_9::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_9::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp2_7_3398851
void p2_9::V2_outTRp2_7_3398851(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp2_7_3398851 -> Going From p2_9 to p2_10"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_9 => p2_10");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_7_3398851");
								smc->event_status_msg.push_back(" <!> State Update: p2_9 => p2_10");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_7_3398851"<<std::endl;
							std::cout<<" <!> State Update: p2_9 => p2_10"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_10());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp2_7_3398851
std::vector<int> p2_9::match_V2_outTRp2_7_3398851(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp2_7_3398851");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp2_7_3398851
void p2_9::V2_outTRp2_7_3398851(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp2_7_3398851 -> Going From p2_9 to p2_10"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p2_9 => p2_10");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_7_3398851");
							smc->event_status_msg.push_back(" <!> State Update: p2_9 => p2_10");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_7_3398851"<<std::endl;
						std::cout<<" <!> State Update: p2_9 => p2_10"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p2_10());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p2_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p2_9::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp2_7_3398851");
					smc->event_status_msg.push_back(" <!> State Update: p2_9 => p2_10");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp2_7_3398851"<<std::endl;
					std::cout<<" <!> State Update: p2_9 => p2_10"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp2_7_3398851();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp2_7_3398851");
					if(smc->m_outTRp2_7_3398851_Handler != nullptr)
					{
						smc->m_outTRp2_7_3398851_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p2_9 => p2_10");
					smc->setCurrent(new p2_10());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p2_9!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_15 ***********/

list<string> p3_15::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_15::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_10_3398813");
	return retStr;
}
		
list<string> p3_15::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_15::getCurrentState() { return name; }

list<string> p3_15::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_15::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_10_3398813
	{
	list_of_enabled_signals.push_back("V2_inTRp3_10_3398813");
	}
	return list_of_enabled_signals;
}

void p3_15::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_10_3398813"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_10_3398813();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_10_3398813( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_10_3398813( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_10_3398813"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_10_3398813" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_10_3398813(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_10_3398813" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_10_3398813( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_10_3398813 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_10_3398813(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_10_3398813(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_10_3398813(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_10_3398813 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_10_3398813 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_10_3398813" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_10_3398813( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_10_3398813 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_15"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_15", NO_ENABLED_GUARDS));
	}
}

bool p3_15::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_15::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_15::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_10_3398813
bool p3_15::isEnabledV2_inTRp3_10_3398813(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_10_3398813
std::vector<int> p3_15::V2_inTRp3_10_3398813(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_10_3398813");
							smc->event_status_msg.push_back(" <!> State Update: p3_15 => p3_16");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_10_3398813"<<std::endl;
							// std::cout<<" <!> State Update: From p3_15 => p3_16"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_15 => p3_16");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_10_3398813 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_15!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_10_3398813
void p3_15::V2_inTRp3_10_3398813(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_10_3398813");
							smc->event_status_msg.push_back(" <!> State Update: p3_15 => p3_16");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_10_3398813"<<std::endl;
							std::cout<<" <!> State Update: From p3_15 => p3_16"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_15 => p3_16");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_16());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_10_3398813 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_15!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_10_3398813
void p3_15::V2_inTRp3_10_3398813(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_10_3398813");
				smc->event_status_msg.push_back(" <!> State Update: p3_15 => p3_16");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_10_3398813"<<std::endl;
				std::cout<<" <!> State Update: From p3_15 => p3_16"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_15 => p3_16");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_16());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_10_3398813 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_15");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_15!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p15_1 ***********/

list<string> p15_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p15_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp15_1_3398854");
	return retStr;
}
		
list<string> p15_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p15_1::getCurrentState() { return name; }

list<string> p15_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p15_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp15_1_3398854
	{
	list_of_enabled_signals.push_back("V2_inTRp15_1_3398854");
	}
	return list_of_enabled_signals;
}

void p15_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp15_1_3398854"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp15_1_3398854();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp15_1_3398854( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp15_1_3398854( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp15_1_3398854"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp15_1_3398854" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp15_1_3398854(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp15_1_3398854" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp15_1_3398854( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp15_1_3398854 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp15_1_3398854(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp15_1_3398854(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp15_1_3398854(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp15_1_3398854 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp15_1_3398854 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp15_1_3398854" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp15_1_3398854( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp15_1_3398854 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p15_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p15_1", NO_ENABLED_GUARDS));
	}
}

bool p15_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p15_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p15_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp15_1_3398854
bool p15_1::isEnabledV2_inTRp15_1_3398854(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp15_1_3398854
std::vector<int> p15_1::V2_inTRp15_1_3398854(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp15_1_3398854");
							smc->event_status_msg.push_back(" <!> State Update: p15_1 => p3_51");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp15_1_3398854"<<std::endl;
							// std::cout<<" <!> State Update: From p15_1 => p3_51"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p15_1 => p3_51");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp15_1_3398854 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p15_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p15_1!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp15_1_3398854
void p15_1::V2_inTRp15_1_3398854(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp15_1_3398854");
							smc->event_status_msg.push_back(" <!> State Update: p15_1 => p3_51");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp15_1_3398854"<<std::endl;
							std::cout<<" <!> State Update: From p15_1 => p3_51"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p15_1 => p3_51");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_51());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp15_1_3398854 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p15_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p15_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp15_1_3398854
void p15_1::V2_inTRp15_1_3398854(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp15_1_3398854");
				smc->event_status_msg.push_back(" <!> State Update: p15_1 => p3_51");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp15_1_3398854"<<std::endl;
				std::cout<<" <!> State Update: From p15_1 => p3_51"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p15_1 => p3_51");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_51());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp15_1_3398854 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p15_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p15_1!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p16_1 ***********/

list<string> p16_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p16_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp16_1_3398856");
	return retStr;
}
		
list<string> p16_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p16_1::getCurrentState() { return name; }

list<string> p16_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p16_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp16_1_3398856
	{
	list_of_enabled_signals.push_back("V2_inTRp16_1_3398856");
	}
	return list_of_enabled_signals;
}

void p16_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp16_1_3398856"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp16_1_3398856();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp16_1_3398856( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp16_1_3398856( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp16_1_3398856"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp16_1_3398856" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp16_1_3398856(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp16_1_3398856" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp16_1_3398856( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp16_1_3398856 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp16_1_3398856(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp16_1_3398856(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp16_1_3398856(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp16_1_3398856 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp16_1_3398856 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp16_1_3398856" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp16_1_3398856( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp16_1_3398856 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p16_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p16_1", NO_ENABLED_GUARDS));
	}
}

bool p16_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p16_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p16_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp16_1_3398856
bool p16_1::isEnabledV2_inTRp16_1_3398856(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp16_1_3398856
std::vector<int> p16_1::V2_inTRp16_1_3398856(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp16_1_3398856");
							smc->event_status_msg.push_back(" <!> State Update: p16_1 => p3_51");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp16_1_3398856"<<std::endl;
							// std::cout<<" <!> State Update: From p16_1 => p3_51"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p16_1 => p3_51");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp16_1_3398856 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p16_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p16_1!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp16_1_3398856
void p16_1::V2_inTRp16_1_3398856(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp16_1_3398856");
							smc->event_status_msg.push_back(" <!> State Update: p16_1 => p3_51");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp16_1_3398856"<<std::endl;
							std::cout<<" <!> State Update: From p16_1 => p3_51"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p16_1 => p3_51");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_51());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp16_1_3398856 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p16_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p16_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp16_1_3398856
void p16_1::V2_inTRp16_1_3398856(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp16_1_3398856");
				smc->event_status_msg.push_back(" <!> State Update: p16_1 => p3_51");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp16_1_3398856"<<std::endl;
				std::cout<<" <!> State Update: From p16_1 => p3_51"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p16_1 => p3_51");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_51());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp16_1_3398856 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p16_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p16_1!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p17_1 ***********/

list<string> p17_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p17_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p17_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp17_1_3398863");
	return retStr;
}

string p17_1::getCurrentState() { return name; }

list<string> p17_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p17_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p17_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p17_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p17_1", NO_ENABLED_GUARDS));
	}
}

bool p17_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p17_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p17_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp17_1_3398863
void p17_1::V2_outTRp17_1_3398863(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp17_1_3398863 -> Going From p17_1 to p17_2"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p17_1 => p17_2");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp17_1_3398863");
								smc->event_status_msg.push_back(" <!> State Update: p17_1 => p17_2");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp17_1_3398863"<<std::endl;
							std::cout<<" <!> State Update: p17_1 => p17_2"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p17_2());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p17_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp17_1_3398863
std::vector<int> p17_1::match_V2_outTRp17_1_3398863(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp17_1_3398863");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p17_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp17_1_3398863
void p17_1::V2_outTRp17_1_3398863(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp17_1_3398863 -> Going From p17_1 to p17_2"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p17_1 => p17_2");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp17_1_3398863");
							smc->event_status_msg.push_back(" <!> State Update: p17_1 => p17_2");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp17_1_3398863"<<std::endl;
						std::cout<<" <!> State Update: p17_1 => p17_2"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p17_2());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p17_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p17_1::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp17_1_3398863");
					smc->event_status_msg.push_back(" <!> State Update: p17_1 => p17_2");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp17_1_3398863"<<std::endl;
					std::cout<<" <!> State Update: p17_1 => p17_2"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp17_1_3398863();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp17_1_3398863");
					if(smc->m_outTRp17_1_3398863_Handler != nullptr)
					{
						smc->m_outTRp17_1_3398863_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p17_1 => p17_2");
					smc->setCurrent(new p17_2());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p17_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p17_1!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_19 ***********/

list<string> p1_19::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_19::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_19::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_4_3398759");
	return retStr;
}

string p1_19::getCurrentState() { return name; }

list<string> p1_19::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_19::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_19::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_19"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_19", NO_ENABLED_GUARDS));
	}
}

bool p1_19::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_19::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_19::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_4_3398759
void p1_19::V2_outTRp1_4_3398759(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_4_3398759 -> Going From p1_19 to p1_20"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_19 => p1_20");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_4_3398759");
								smc->event_status_msg.push_back(" <!> State Update: p1_19 => p1_20");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_4_3398759"<<std::endl;
							std::cout<<" <!> State Update: p1_19 => p1_20"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_20());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_19");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_4_3398759
std::vector<int> p1_19::match_V2_outTRp1_4_3398759(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_4_3398759");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_19");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_4_3398759
void p1_19::V2_outTRp1_4_3398759(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_4_3398759 -> Going From p1_19 to p1_20"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_19 => p1_20");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_4_3398759");
							smc->event_status_msg.push_back(" <!> State Update: p1_19 => p1_20");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_4_3398759"<<std::endl;
						std::cout<<" <!> State Update: p1_19 => p1_20"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_20());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_19");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_19::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_4_3398759");
					smc->event_status_msg.push_back(" <!> State Update: p1_19 => p1_20");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_4_3398759"<<std::endl;
					std::cout<<" <!> State Update: p1_19 => p1_20"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_4_3398759();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_4_3398759");
					if(smc->m_outTRp1_4_3398759_Handler != nullptr)
					{
						smc->m_outTRp1_4_3398759_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_19 => p1_20");
					smc->setCurrent(new p1_20());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_19");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_19!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_44 ***********/

list<string> p3_44::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_44::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_44::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_3_3398727");
	return retStr;
}

string p3_44::getCurrentState() { return name; }

list<string> p3_44::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_44::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_44::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_44"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_44", NO_ENABLED_GUARDS));
	}
}

bool p3_44::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_44::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_44::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_3_3398727
void p3_44::V2_outTRp3_3_3398727(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_3_3398727 -> Going From p3_44 to p3_45"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_44 => p3_45");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_3_3398727");
								smc->event_status_msg.push_back(" <!> State Update: p3_44 => p3_45");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_3_3398727"<<std::endl;
							std::cout<<" <!> State Update: p3_44 => p3_45"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_45());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_44");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_3_3398727
std::vector<int> p3_44::match_V2_outTRp3_3_3398727(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_3_3398727");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_44");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_3_3398727
void p3_44::V2_outTRp3_3_3398727(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_3_3398727 -> Going From p3_44 to p3_45"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_44 => p3_45");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_3_3398727");
							smc->event_status_msg.push_back(" <!> State Update: p3_44 => p3_45");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_3_3398727"<<std::endl;
						std::cout<<" <!> State Update: p3_44 => p3_45"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_45());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_44");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_44::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_3_3398727");
					smc->event_status_msg.push_back(" <!> State Update: p3_44 => p3_45");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_3_3398727"<<std::endl;
					std::cout<<" <!> State Update: p3_44 => p3_45"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_3_3398727();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_3_3398727");
					if(smc->m_outTRp3_3_3398727_Handler != nullptr)
					{
						smc->m_outTRp3_3_3398727_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_44 => p3_45");
					smc->setCurrent(new p3_45());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_44");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_44!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_28 ***********/

list<string> p1_28::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_28::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_28::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_20_3398837");
	return retStr;
}

string p1_28::getCurrentState() { return name; }

list<string> p1_28::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_28::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_28::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_28"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_28", NO_ENABLED_GUARDS));
	}
}

bool p1_28::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_28::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_28::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_20_3398837
void p1_28::V2_outTRp1_20_3398837(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_20_3398837 -> Going From p1_28 to p1_29"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_28 => p1_29");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_20_3398837");
								smc->event_status_msg.push_back(" <!> State Update: p1_28 => p1_29");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_20_3398837"<<std::endl;
							std::cout<<" <!> State Update: p1_28 => p1_29"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_29());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_28");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_20_3398837
std::vector<int> p1_28::match_V2_outTRp1_20_3398837(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_20_3398837");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_28");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_20_3398837
void p1_28::V2_outTRp1_20_3398837(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_20_3398837 -> Going From p1_28 to p1_29"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_28 => p1_29");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_20_3398837");
							smc->event_status_msg.push_back(" <!> State Update: p1_28 => p1_29");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_20_3398837"<<std::endl;
						std::cout<<" <!> State Update: p1_28 => p1_29"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_29());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_28");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_28::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_20_3398837");
					smc->event_status_msg.push_back(" <!> State Update: p1_28 => p1_29");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_20_3398837"<<std::endl;
					std::cout<<" <!> State Update: p1_28 => p1_29"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_20_3398837();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_20_3398837");
					if(smc->m_outTRp1_20_3398837_Handler != nullptr)
					{
						smc->m_outTRp1_20_3398837_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_28 => p1_29");
					smc->setCurrent(new p1_29());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_28");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_28!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_9 ***********/

list<string> p1_9::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_9::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_9::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_3_3398784");
	return retStr;
}

string p1_9::getCurrentState() { return name; }

list<string> p1_9::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_9::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_9::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_9"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_9", NO_ENABLED_GUARDS));
	}
}

bool p1_9::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_9::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_9::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_3_3398784
void p1_9::V2_outTRp1_3_3398784(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_3_3398784 -> Going From p1_9 to p1_10"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_9 => p1_10");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_3_3398784");
								smc->event_status_msg.push_back(" <!> State Update: p1_9 => p1_10");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_3_3398784"<<std::endl;
							std::cout<<" <!> State Update: p1_9 => p1_10"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_10());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_3_3398784
std::vector<int> p1_9::match_V2_outTRp1_3_3398784(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_3_3398784");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_3_3398784
void p1_9::V2_outTRp1_3_3398784(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_3_3398784 -> Going From p1_9 to p1_10"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_9 => p1_10");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_3_3398784");
							smc->event_status_msg.push_back(" <!> State Update: p1_9 => p1_10");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_3_3398784"<<std::endl;
						std::cout<<" <!> State Update: p1_9 => p1_10"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_10());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_9::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_3_3398784");
					smc->event_status_msg.push_back(" <!> State Update: p1_9 => p1_10");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_3_3398784"<<std::endl;
					std::cout<<" <!> State Update: p1_9 => p1_10"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_3_3398784();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_3_3398784");
					if(smc->m_outTRp1_3_3398784_Handler != nullptr)
					{
						smc->m_outTRp1_3_3398784_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_9 => p1_10");
					smc->setCurrent(new p1_10());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_9");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_9!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p17_3 ***********/

list<string> p17_3::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p17_3::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp17_1_3398858");
	return retStr;
}
		
list<string> p17_3::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p17_3::getCurrentState() { return name; }

list<string> p17_3::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p17_3::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp17_1_3398858
	{
	list_of_enabled_signals.push_back("V2_inTRp17_1_3398858");
	}
	return list_of_enabled_signals;
}

void p17_3::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp17_1_3398858"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp17_1_3398858();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp17_1_3398858( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp17_1_3398858( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp17_1_3398858"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp17_1_3398858" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp17_1_3398858(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp17_1_3398858" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp17_1_3398858( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp17_1_3398858 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp17_1_3398858(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp17_1_3398858(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp17_1_3398858(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp17_1_3398858 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp17_1_3398858 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp17_1_3398858" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp17_1_3398858( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp17_1_3398858 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p17_3"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p17_3", NO_ENABLED_GUARDS));
	}
}

bool p17_3::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p17_3::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p17_3::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp17_1_3398858
bool p17_3::isEnabledV2_inTRp17_1_3398858(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp17_1_3398858
std::vector<int> p17_3::V2_inTRp17_1_3398858(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp17_1_3398858");
							smc->event_status_msg.push_back(" <!> State Update: p17_3 => p3_6");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp17_1_3398858"<<std::endl;
							// std::cout<<" <!> State Update: From p17_3 => p3_6"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p17_3 => p3_6");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp17_1_3398858 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_3!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp17_1_3398858
void p17_3::V2_inTRp17_1_3398858(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp17_1_3398858");
							smc->event_status_msg.push_back(" <!> State Update: p17_3 => p3_6");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp17_1_3398858"<<std::endl;
							std::cout<<" <!> State Update: From p17_3 => p3_6"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p17_3 => p3_6");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_6());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp17_1_3398858 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_3!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp17_1_3398858
void p17_3::V2_inTRp17_1_3398858(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp17_1_3398858");
				smc->event_status_msg.push_back(" <!> State Update: p17_3 => p3_6");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp17_1_3398858"<<std::endl;
				std::cout<<" <!> State Update: From p17_3 => p3_6"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p17_3 => p3_6");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_6());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp17_1_3398858 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_3!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p17_2 ***********/

list<string> p17_2::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p17_2::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp17_2_3398864");
	return retStr;
}
		
list<string> p17_2::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p17_2::getCurrentState() { return name; }

list<string> p17_2::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p17_2::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp17_2_3398864
	{
	list_of_enabled_signals.push_back("V2_inTRp17_2_3398864");
	}
	return list_of_enabled_signals;
}

void p17_2::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp17_2_3398864"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp17_2_3398864();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp17_2_3398864( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp17_2_3398864( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp17_2_3398864"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp17_2_3398864" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp17_2_3398864(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp17_2_3398864" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp17_2_3398864( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp17_2_3398864 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp17_2_3398864(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp17_2_3398864(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp17_2_3398864(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp17_2_3398864 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp17_2_3398864 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp17_2_3398864" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp17_2_3398864( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp17_2_3398864 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p17_2"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p17_2", NO_ENABLED_GUARDS));
	}
}

bool p17_2::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p17_2::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p17_2::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp17_2_3398864
bool p17_2::isEnabledV2_inTRp17_2_3398864(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp17_2_3398864
std::vector<int> p17_2::V2_inTRp17_2_3398864(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp17_2_3398864");
							smc->event_status_msg.push_back(" <!> State Update: p17_2 => p17_3");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp17_2_3398864"<<std::endl;
							// std::cout<<" <!> State Update: From p17_2 => p17_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p17_2 => p17_3");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp17_2_3398864 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_2!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp17_2_3398864
void p17_2::V2_inTRp17_2_3398864(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp17_2_3398864");
							smc->event_status_msg.push_back(" <!> State Update: p17_2 => p17_3");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp17_2_3398864"<<std::endl;
							std::cout<<" <!> State Update: From p17_2 => p17_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p17_2 => p17_3");
							smc->setTextColor("ANY");
							smc->setCurrent(new p17_3());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp17_2_3398864 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_2!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp17_2_3398864
void p17_2::V2_inTRp17_2_3398864(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp17_2_3398864");
				smc->event_status_msg.push_back(" <!> State Update: p17_2 => p17_3");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp17_2_3398864"<<std::endl;
				std::cout<<" <!> State Update: From p17_2 => p17_3"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p17_2 => p17_3");
				smc->setTextColor("ANY");
				smc->setCurrent(new p17_3());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp17_2_3398864 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p17_2!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_33 ***********/

list<string> p3_33::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_33::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_33::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_31_3398886");
	return retStr;
}

string p3_33::getCurrentState() { return name; }

list<string> p3_33::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_33::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_33::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_33"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_33", NO_ENABLED_GUARDS));
	}
}

bool p3_33::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_33::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_33::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_31_3398886
void p3_33::V2_outTRp3_31_3398886(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_31_3398886 -> Going From p3_33 to p3_34"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_33 => p3_34");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_31_3398886");
								smc->event_status_msg.push_back(" <!> State Update: p3_33 => p3_34");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_31_3398886"<<std::endl;
							std::cout<<" <!> State Update: p3_33 => p3_34"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_34());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_33");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_31_3398886
std::vector<int> p3_33::match_V2_outTRp3_31_3398886(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_31_3398886");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_33");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_31_3398886
void p3_33::V2_outTRp3_31_3398886(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_31_3398886 -> Going From p3_33 to p3_34"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_33 => p3_34");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_31_3398886");
							smc->event_status_msg.push_back(" <!> State Update: p3_33 => p3_34");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_31_3398886"<<std::endl;
						std::cout<<" <!> State Update: p3_33 => p3_34"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_34());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_33");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_33::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_31_3398886");
					smc->event_status_msg.push_back(" <!> State Update: p3_33 => p3_34");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_31_3398886"<<std::endl;
					std::cout<<" <!> State Update: p3_33 => p3_34"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_31_3398886();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_31_3398886");
					if(smc->m_outTRp3_31_3398886_Handler != nullptr)
					{
						smc->m_outTRp3_31_3398886_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_33 => p3_34");
					smc->setCurrent(new p3_34());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_33");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_33!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_4 ***********/

list<string> p1_4::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_4::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_4::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_1_3398738");
	return retStr;
}

string p1_4::getCurrentState() { return name; }

list<string> p1_4::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_4::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_4::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_4"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_4", NO_ENABLED_GUARDS));
	}
}

bool p1_4::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_4::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_4::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_1_3398738
void p1_4::V2_outTRp1_1_3398738(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_1_3398738 -> Going From p1_4 to p1_5"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_4 => p1_5");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398738");
								smc->event_status_msg.push_back(" <!> State Update: p1_4 => p1_5");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398738"<<std::endl;
							std::cout<<" <!> State Update: p1_4 => p1_5"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_5());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_1_3398738
std::vector<int> p1_4::match_V2_outTRp1_1_3398738(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_1_3398738");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_1_3398738
void p1_4::V2_outTRp1_1_3398738(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_1_3398738 -> Going From p1_4 to p1_5"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_4 => p1_5");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398738");
							smc->event_status_msg.push_back(" <!> State Update: p1_4 => p1_5");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398738"<<std::endl;
						std::cout<<" <!> State Update: p1_4 => p1_5"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_5());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_4::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_1_3398738");
					smc->event_status_msg.push_back(" <!> State Update: p1_4 => p1_5");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_1_3398738"<<std::endl;
					std::cout<<" <!> State Update: p1_4 => p1_5"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_1_3398738();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_1_3398738");
					if(smc->m_outTRp1_1_3398738_Handler != nullptr)
					{
						smc->m_outTRp1_1_3398738_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_4 => p1_5");
					smc->setCurrent(new p1_5());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_4!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_11 ***********/

list<string> p3_11::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_11::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_8_3398780");
	return retStr;
}
		
list<string> p3_11::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_8_3398840");
	return retStr;
}

string p3_11::getCurrentState() { return name; }

list<string> p3_11::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_11::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_8_3398780
	{
	list_of_enabled_signals.push_back("V2_inTRp3_8_3398780");
	}
	return list_of_enabled_signals;
}

void p3_11::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_8_3398780"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_8_3398780();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_8_3398780( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_8_3398780( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_8_3398780"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_8_3398780" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_8_3398780(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_8_3398780" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_8_3398780( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_8_3398780 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_8_3398780(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_8_3398780(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_8_3398780(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_8_3398780 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_8_3398780 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_8_3398780" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_8_3398780( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_8_3398780 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_11"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_11", NO_ENABLED_GUARDS));
	}
}

bool p3_11::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_11::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_11::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Enabling Test for Signal: V2_inTRp3_8_3398780
bool p3_11::isEnabledV2_inTRp3_8_3398780(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_8_3398780
std::vector<int> p3_11::V2_inTRp3_8_3398780(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_8_3398780");
							smc->event_status_msg.push_back(" <!> State Update: p3_11 => p3_13");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_8_3398780"<<std::endl;
							// std::cout<<" <!> State Update: From p3_11 => p3_13"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_11 => p3_13");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_8_3398780 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_11!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_8_3398780
void p3_11::V2_inTRp3_8_3398780(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_8_3398780");
							smc->event_status_msg.push_back(" <!> State Update: p3_11 => p3_13");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_8_3398780"<<std::endl;
							std::cout<<" <!> State Update: From p3_11 => p3_13"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_11 => p3_13");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_13());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_8_3398780 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_11!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_8_3398780
void p3_11::V2_inTRp3_8_3398780(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_8_3398780");
				smc->event_status_msg.push_back(" <!> State Update: p3_11 => p3_13");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_8_3398780"<<std::endl;
				std::cout<<" <!> State Update: From p3_11 => p3_13"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_11 => p3_13");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_13());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_8_3398780 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_11!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Deterministic Notification Handler: V2_outTRp3_8_3398840
void p3_11::V2_outTRp3_8_3398840(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_8_3398840 -> Going From p3_11 to p14_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_11 => p14_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_8_3398840");
								smc->event_status_msg.push_back(" <!> State Update: p3_11 => p14_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_8_3398840"<<std::endl;
							std::cout<<" <!> State Update: p3_11 => p14_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p14_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_8_3398840
std::vector<int> p3_11::match_V2_outTRp3_8_3398840(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_8_3398840");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_8_3398840
void p3_11::V2_outTRp3_8_3398840(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_8_3398840 -> Going From p3_11 to p14_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_11 => p14_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_8_3398840");
							smc->event_status_msg.push_back(" <!> State Update: p3_11 => p14_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_8_3398840"<<std::endl;
						std::cout<<" <!> State Update: p3_11 => p14_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p14_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_11::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_8_3398840");
					smc->event_status_msg.push_back(" <!> State Update: p3_11 => p14_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_8_3398840"<<std::endl;
					std::cout<<" <!> State Update: p3_11 => p14_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_8_3398840();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_8_3398840");
					if(smc->m_outTRp3_8_3398840_Handler != nullptr)
					{
						smc->m_outTRp3_8_3398840_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_11 => p14_1");
					smc->setCurrent(new p14_1());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_11!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p4_5 ***********/

list<string> p4_5::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p4_5::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p4_5::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp4_2_3398839");
	return retStr;
}

string p4_5::getCurrentState() { return name; }

list<string> p4_5::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p4_5::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p4_5::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p4_5"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p4_5", NO_ENABLED_GUARDS));
	}
}

bool p4_5::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p4_5::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p4_5::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp4_2_3398839
void p4_5::V2_outTRp4_2_3398839(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp4_2_3398839 -> Going From p4_5 to p4_6"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p4_5 => p4_6");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_2_3398839");
								smc->event_status_msg.push_back(" <!> State Update: p4_5 => p4_6");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_2_3398839"<<std::endl;
							std::cout<<" <!> State Update: p4_5 => p4_6"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p4_6());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp4_2_3398839
std::vector<int> p4_5::match_V2_outTRp4_2_3398839(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp4_2_3398839");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp4_2_3398839
void p4_5::V2_outTRp4_2_3398839(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp4_2_3398839 -> Going From p4_5 to p4_6"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p4_5 => p4_6");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_2_3398839");
							smc->event_status_msg.push_back(" <!> State Update: p4_5 => p4_6");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_2_3398839"<<std::endl;
						std::cout<<" <!> State Update: p4_5 => p4_6"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p4_6());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p4_5::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_2_3398839");
					smc->event_status_msg.push_back(" <!> State Update: p4_5 => p4_6");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_2_3398839"<<std::endl;
					std::cout<<" <!> State Update: p4_5 => p4_6"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp4_2_3398839();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp4_2_3398839");
					if(smc->m_outTRp4_2_3398839_Handler != nullptr)
					{
						smc->m_outTRp4_2_3398839_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p4_5 => p4_6");
					smc->setCurrent(new p4_6());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p4_5");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p4_5!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p4_4 ***********/

list<string> p4_4::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p4_4::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p4_4::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp4_3_3398869");
	return retStr;
}

string p4_4::getCurrentState() { return name; }

list<string> p4_4::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p4_4::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p4_4::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p4_4"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p4_4", NO_ENABLED_GUARDS));
	}
}

bool p4_4::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p4_4::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p4_4::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp4_3_3398869
void p4_4::V2_outTRp4_3_3398869(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp4_3_3398869 -> Going From p4_4 to p4_5"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p4_4 => p4_5");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_3_3398869");
								smc->event_status_msg.push_back(" <!> State Update: p4_4 => p4_5");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_3_3398869"<<std::endl;
							std::cout<<" <!> State Update: p4_4 => p4_5"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p4_5());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp4_3_3398869
std::vector<int> p4_4::match_V2_outTRp4_3_3398869(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp4_3_3398869");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp4_3_3398869
void p4_4::V2_outTRp4_3_3398869(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp4_3_3398869 -> Going From p4_4 to p4_5"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p4_4 => p4_5");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_3_3398869");
							smc->event_status_msg.push_back(" <!> State Update: p4_4 => p4_5");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_3_3398869"<<std::endl;
						std::cout<<" <!> State Update: p4_4 => p4_5"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p4_5());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p4_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p4_4::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp4_3_3398869");
					smc->event_status_msg.push_back(" <!> State Update: p4_4 => p4_5");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp4_3_3398869"<<std::endl;
					std::cout<<" <!> State Update: p4_4 => p4_5"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp4_3_3398869();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp4_3_3398869");
					if(smc->m_outTRp4_3_3398869_Handler != nullptr)
					{
						smc->m_outTRp4_3_3398869_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p4_4 => p4_5");
					smc->setCurrent(new p4_5());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p4_4");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p4_4!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p18_1 ***********/

list<string> p18_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p18_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp18_1_3398871");
	return retStr;
}
		
list<string> p18_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p18_1::getCurrentState() { return name; }

list<string> p18_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p18_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp18_1_3398871
	{
	list_of_enabled_signals.push_back("V2_inTRp18_1_3398871");
	}
	return list_of_enabled_signals;
}

void p18_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp18_1_3398871"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp18_1_3398871();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp18_1_3398871( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp18_1_3398871( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp18_1_3398871"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp18_1_3398871" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp18_1_3398871(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp18_1_3398871" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp18_1_3398871( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp18_1_3398871 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp18_1_3398871(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp18_1_3398871(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp18_1_3398871(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp18_1_3398871 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp18_1_3398871 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp18_1_3398871" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp18_1_3398871( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp18_1_3398871 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p18_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p18_1", NO_ENABLED_GUARDS));
	}
}

bool p18_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p18_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p18_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp18_1_3398871
bool p18_1::isEnabledV2_inTRp18_1_3398871(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp18_1_3398871
std::vector<int> p18_1::V2_inTRp18_1_3398871(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp18_1_3398871");
							smc->event_status_msg.push_back(" <!> State Update: p18_1 => p9_1");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp18_1_3398871"<<std::endl;
							// std::cout<<" <!> State Update: From p18_1 => p9_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p18_1 => p9_1");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp18_1_3398871 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p18_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p18_1!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp18_1_3398871
void p18_1::V2_inTRp18_1_3398871(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp18_1_3398871");
							smc->event_status_msg.push_back(" <!> State Update: p18_1 => p9_1");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp18_1_3398871"<<std::endl;
							std::cout<<" <!> State Update: From p18_1 => p9_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p18_1 => p9_1");
							smc->setTextColor("ANY");
							smc->setCurrent(new p9_1());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp18_1_3398871 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p18_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p18_1!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp18_1_3398871
void p18_1::V2_inTRp18_1_3398871(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp18_1_3398871");
				smc->event_status_msg.push_back(" <!> State Update: p18_1 => p9_1");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp18_1_3398871"<<std::endl;
				std::cout<<" <!> State Update: From p18_1 => p9_1"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p18_1 => p9_1");
				smc->setTextColor("ANY");
				smc->setCurrent(new p9_1());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp18_1_3398871 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p18_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p18_1!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_24 ***********/

list<string> p3_24::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_24::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_13_3398792");
	return retStr;
}
		
list<string> p3_24::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_24::getCurrentState() { return name; }

list<string> p3_24::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_24::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_13_3398792
	{
	list_of_enabled_signals.push_back("V2_inTRp3_13_3398792");
	}
	return list_of_enabled_signals;
}

void p3_24::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_13_3398792"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_13_3398792();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_13_3398792( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_13_3398792( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_13_3398792"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_13_3398792" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_13_3398792(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_13_3398792" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_13_3398792( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_13_3398792 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_13_3398792(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_13_3398792(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_13_3398792(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_13_3398792 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_13_3398792 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_13_3398792" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_13_3398792( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_13_3398792 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_24"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_24", NO_ENABLED_GUARDS));
	}
}

bool p3_24::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_24::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_24::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_13_3398792
bool p3_24::isEnabledV2_inTRp3_13_3398792(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_13_3398792
std::vector<int> p3_24::V2_inTRp3_13_3398792(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_13_3398792");
							smc->event_status_msg.push_back(" <!> State Update: p3_24 => p3_25");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_13_3398792"<<std::endl;
							// std::cout<<" <!> State Update: From p3_24 => p3_25"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_24 => p3_25");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_13_3398792 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_24");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_24!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_13_3398792
void p3_24::V2_inTRp3_13_3398792(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_13_3398792");
							smc->event_status_msg.push_back(" <!> State Update: p3_24 => p3_25");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_13_3398792"<<std::endl;
							std::cout<<" <!> State Update: From p3_24 => p3_25"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_24 => p3_25");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_25());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_13_3398792 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_24");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_24!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_13_3398792
void p3_24::V2_inTRp3_13_3398792(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_13_3398792");
				smc->event_status_msg.push_back(" <!> State Update: p3_24 => p3_25");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_13_3398792"<<std::endl;
				std::cout<<" <!> State Update: From p3_24 => p3_25"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_24 => p3_25");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_25());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_13_3398792 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_24");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_24!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p4_3 ***********/

list<string> p4_3::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p4_3::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp4_2_3398868");
	return retStr;
}
		
list<string> p4_3::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p4_3::getCurrentState() { return name; }

list<string> p4_3::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p4_3::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp4_2_3398868
	{
	list_of_enabled_signals.push_back("V2_inTRp4_2_3398868");
	}
	return list_of_enabled_signals;
}

void p4_3::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp4_2_3398868"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp4_2_3398868();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp4_2_3398868( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp4_2_3398868( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp4_2_3398868"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp4_2_3398868" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp4_2_3398868(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp4_2_3398868" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp4_2_3398868( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp4_2_3398868 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp4_2_3398868(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp4_2_3398868(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp4_2_3398868(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp4_2_3398868 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp4_2_3398868 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp4_2_3398868" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp4_2_3398868( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp4_2_3398868 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p4_3"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p4_3", NO_ENABLED_GUARDS));
	}
}

bool p4_3::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p4_3::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p4_3::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp4_2_3398868
bool p4_3::isEnabledV2_inTRp4_2_3398868(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp4_2_3398868
std::vector<int> p4_3::V2_inTRp4_2_3398868(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp4_2_3398868");
							smc->event_status_msg.push_back(" <!> State Update: p4_3 => p4_4");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp4_2_3398868"<<std::endl;
							// std::cout<<" <!> State Update: From p4_3 => p4_4"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p4_3 => p4_4");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp4_2_3398868 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_3!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp4_2_3398868
void p4_3::V2_inTRp4_2_3398868(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp4_2_3398868");
							smc->event_status_msg.push_back(" <!> State Update: p4_3 => p4_4");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp4_2_3398868"<<std::endl;
							std::cout<<" <!> State Update: From p4_3 => p4_4"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p4_3 => p4_4");
							smc->setTextColor("ANY");
							smc->setCurrent(new p4_4());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp4_2_3398868 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_3!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp4_2_3398868
void p4_3::V2_inTRp4_2_3398868(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp4_2_3398868");
				smc->event_status_msg.push_back(" <!> State Update: p4_3 => p4_4");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp4_2_3398868"<<std::endl;
				std::cout<<" <!> State Update: From p4_3 => p4_4"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p4_3 => p4_4");
				smc->setTextColor("ANY");
				smc->setCurrent(new p4_4());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp4_2_3398868 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p4_3!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p2_3 ***********/

list<string> p2_3::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_3::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_1_3398757");
	return retStr;
}
		
list<string> p2_3::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_3::getCurrentState() { return name; }

list<string> p2_3::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_3::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_1_3398757
	{
	list_of_enabled_signals.push_back("V2_inTRp2_1_3398757");
	}
	return list_of_enabled_signals;
}

void p2_3::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_1_3398757"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_1_3398757();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_1_3398757( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_1_3398757( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_1_3398757"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_1_3398757" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_1_3398757(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_1_3398757" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_1_3398757( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_1_3398757 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_1_3398757(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_1_3398757(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_1_3398757(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_1_3398757 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_1_3398757 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_1_3398757" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_1_3398757( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_1_3398757 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_3"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_3", NO_ENABLED_GUARDS));
	}
}

bool p2_3::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_3::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_3::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_1_3398757
bool p2_3::isEnabledV2_inTRp2_1_3398757(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_1_3398757
std::vector<int> p2_3::V2_inTRp2_1_3398757(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398757");
							smc->event_status_msg.push_back(" <!> State Update: p2_3 => p2_4");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398757"<<std::endl;
							// std::cout<<" <!> State Update: From p2_3 => p2_4"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_3 => p2_4");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398757 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_3!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_1_3398757
void p2_3::V2_inTRp2_1_3398757(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398757");
							smc->event_status_msg.push_back(" <!> State Update: p2_3 => p2_4");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398757"<<std::endl;
							std::cout<<" <!> State Update: From p2_3 => p2_4"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_3 => p2_4");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_4());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398757 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_3!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_1_3398757
void p2_3::V2_inTRp2_1_3398757(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_1_3398757");
				smc->event_status_msg.push_back(" <!> State Update: p2_3 => p2_4");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_1_3398757"<<std::endl;
				std::cout<<" <!> State Update: From p2_3 => p2_4"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_3 => p2_4");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_4());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_1_3398757 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_3");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_3!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p2_2 ***********/

list<string> p2_2::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p2_2::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp2_2_3398875");
	return retStr;
}
		
list<string> p2_2::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p2_2::getCurrentState() { return name; }

list<string> p2_2::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p2_2::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp2_2_3398875
	{
	list_of_enabled_signals.push_back("V2_inTRp2_2_3398875");
	}
	return list_of_enabled_signals;
}

void p2_2::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp2_2_3398875"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp2_2_3398875();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp2_2_3398875( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp2_2_3398875( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp2_2_3398875"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp2_2_3398875" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp2_2_3398875(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp2_2_3398875" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_2_3398875( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_2_3398875 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp2_2_3398875(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp2_2_3398875(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp2_2_3398875(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp2_2_3398875 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp2_2_3398875 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp2_2_3398875" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp2_2_3398875( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp2_2_3398875 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p2_2"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p2_2", NO_ENABLED_GUARDS));
	}
}

bool p2_2::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p2_2::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p2_2::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp2_2_3398875
bool p2_2::isEnabledV2_inTRp2_2_3398875(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp2_2_3398875
std::vector<int> p2_2::V2_inTRp2_2_3398875(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_2_3398875");
							smc->event_status_msg.push_back(" <!> State Update: p2_2 => p2_3");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_2_3398875"<<std::endl;
							// std::cout<<" <!> State Update: From p2_2 => p2_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_2 => p2_3");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_2_3398875 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_2!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp2_2_3398875
void p2_2::V2_inTRp2_2_3398875(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_2_3398875");
							smc->event_status_msg.push_back(" <!> State Update: p2_2 => p2_3");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_2_3398875"<<std::endl;
							std::cout<<" <!> State Update: From p2_2 => p2_3"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p2_2 => p2_3");
							smc->setTextColor("ANY");
							smc->setCurrent(new p2_3());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_2_3398875 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_2!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp2_2_3398875
void p2_2::V2_inTRp2_2_3398875(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp2_2_3398875");
				smc->event_status_msg.push_back(" <!> State Update: p2_2 => p2_3");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp2_2_3398875"<<std::endl;
				std::cout<<" <!> State Update: From p2_2 => p2_3"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p2_2 => p2_3");
				smc->setTextColor("ANY");
				smc->setCurrent(new p2_3());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp2_2_3398875 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_2");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p2_2!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p19_1 ***********/

list<string> p19_1::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p19_1::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p19_1::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp19_1_3398877");
	return retStr;
}

string p19_1::getCurrentState() { return name; }

list<string> p19_1::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p19_1::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p19_1::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p19_1"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p19_1", NO_ENABLED_GUARDS));
	}
}

bool p19_1::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p19_1::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p19_1::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp19_1_3398877
void p19_1::V2_outTRp19_1_3398877(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp19_1_3398877 -> Going From p19_1 to p4_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p19_1 => p4_1");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp19_1_3398877");
								smc->event_status_msg.push_back(" <!> State Update: p19_1 => p4_1");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp19_1_3398877"<<std::endl;
							std::cout<<" <!> State Update: p19_1 => p4_1"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p4_1());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p19_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp19_1_3398877
std::vector<int> p19_1::match_V2_outTRp19_1_3398877(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp19_1_3398877");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p19_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp19_1_3398877
void p19_1::V2_outTRp19_1_3398877(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp19_1_3398877 -> Going From p19_1 to p4_1"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p19_1 => p4_1");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp19_1_3398877");
							smc->event_status_msg.push_back(" <!> State Update: p19_1 => p4_1");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp19_1_3398877"<<std::endl;
						std::cout<<" <!> State Update: p19_1 => p4_1"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p4_1());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p19_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p19_1::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp19_1_3398877");
					smc->event_status_msg.push_back(" <!> State Update: p19_1 => p4_1");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp19_1_3398877"<<std::endl;
					std::cout<<" <!> State Update: p19_1 => p4_1"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp19_1_3398877();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp19_1_3398877");
					if(smc->m_outTRp19_1_3398877_Handler != nullptr)
					{
						smc->m_outTRp19_1_3398877_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p19_1 => p4_1");
					smc->setCurrent(new p4_1());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p19_1");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p19_1!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_30 ***********/

list<string> p3_30::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_30::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_30::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_29_3398887");
	return retStr;
}

string p3_30::getCurrentState() { return name; }

list<string> p3_30::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_30::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_30::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_30"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_30", NO_ENABLED_GUARDS));
	}
}

bool p3_30::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_30::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_30::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_29_3398887
void p3_30::V2_outTRp3_29_3398887(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_29_3398887 -> Going From p3_30 to p3_31"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_30 => p3_31");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_29_3398887");
								smc->event_status_msg.push_back(" <!> State Update: p3_30 => p3_31");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_29_3398887"<<std::endl;
							std::cout<<" <!> State Update: p3_30 => p3_31"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_31());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_30");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_29_3398887
std::vector<int> p3_30::match_V2_outTRp3_29_3398887(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_29_3398887");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_30");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_29_3398887
void p3_30::V2_outTRp3_29_3398887(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_29_3398887 -> Going From p3_30 to p3_31"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_30 => p3_31");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_29_3398887");
							smc->event_status_msg.push_back(" <!> State Update: p3_30 => p3_31");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_29_3398887"<<std::endl;
						std::cout<<" <!> State Update: p3_30 => p3_31"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_31());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_30");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_30::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_29_3398887");
					smc->event_status_msg.push_back(" <!> State Update: p3_30 => p3_31");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_29_3398887"<<std::endl;
					std::cout<<" <!> State Update: p3_30 => p3_31"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_29_3398887();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_29_3398887");
					if(smc->m_outTRp3_29_3398887_Handler != nullptr)
					{
						smc->m_outTRp3_29_3398887_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_30 => p3_31");
					smc->setCurrent(new p3_31());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_30");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_30!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p1_11 ***********/

list<string> p1_11::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p1_11::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p1_11::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp1_4_3398797");
	return retStr;
}

string p1_11::getCurrentState() { return name; }

list<string> p1_11::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p1_11::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p1_11::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p1_11"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p1_11", NO_ENABLED_GUARDS));
	}
}

bool p1_11::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p1_11::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p1_11::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp1_4_3398797
void p1_11::V2_outTRp1_4_3398797(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp1_4_3398797 -> Going From p1_11 to p1_12"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p1_11 => p1_12");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_4_3398797");
								smc->event_status_msg.push_back(" <!> State Update: p1_11 => p1_12");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_4_3398797"<<std::endl;
							std::cout<<" <!> State Update: p1_11 => p1_12"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_12());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp1_4_3398797
std::vector<int> p1_11::match_V2_outTRp1_4_3398797(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp1_4_3398797");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp1_4_3398797
void p1_11::V2_outTRp1_4_3398797(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp1_4_3398797 -> Going From p1_11 to p1_12"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p1_11 => p1_12");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_4_3398797");
							smc->event_status_msg.push_back(" <!> State Update: p1_11 => p1_12");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_4_3398797"<<std::endl;
						std::cout<<" <!> State Update: p1_11 => p1_12"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p1_12());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p1_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p1_11::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp1_4_3398797");
					smc->event_status_msg.push_back(" <!> State Update: p1_11 => p1_12");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp1_4_3398797"<<std::endl;
					std::cout<<" <!> State Update: p1_11 => p1_12"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp1_4_3398797();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp1_4_3398797");
					if(smc->m_outTRp1_4_3398797_Handler != nullptr)
					{
						smc->m_outTRp1_4_3398797_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p1_11 => p1_12");
					smc->setCurrent(new p1_12());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_11");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p1_11!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_66 ***********/

list<string> p3_66::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_66::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_66::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_62_3398890");
	return retStr;
}

string p3_66::getCurrentState() { return name; }

list<string> p3_66::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_66::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_66::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_66"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_66", NO_ENABLED_GUARDS));
	}
}

bool p3_66::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_66::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_66::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_62_3398890
void p3_66::V2_outTRp3_62_3398890(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_62_3398890 -> Going From p3_66 to p3_67"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_66 => p3_67");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_62_3398890");
								smc->event_status_msg.push_back(" <!> State Update: p3_66 => p3_67");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_62_3398890"<<std::endl;
							std::cout<<" <!> State Update: p3_66 => p3_67"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_67());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_66");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_62_3398890
std::vector<int> p3_66::match_V2_outTRp3_62_3398890(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_62_3398890");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_66");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_62_3398890
void p3_66::V2_outTRp3_62_3398890(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_62_3398890 -> Going From p3_66 to p3_67"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_66 => p3_67");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_62_3398890");
							smc->event_status_msg.push_back(" <!> State Update: p3_66 => p3_67");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_62_3398890"<<std::endl;
						std::cout<<" <!> State Update: p3_66 => p3_67"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_67());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_66");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_66::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_62_3398890");
					smc->event_status_msg.push_back(" <!> State Update: p3_66 => p3_67");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_62_3398890"<<std::endl;
					std::cout<<" <!> State Update: p3_66 => p3_67"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_62_3398890();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_62_3398890");
					if(smc->m_outTRp3_62_3398890_Handler != nullptr)
					{
						smc->m_outTRp3_62_3398890_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_66 => p3_67");
					smc->setCurrent(new p3_67());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_66");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_66!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_60 ***********/

list<string> p3_60::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_60::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_60::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_60_3398891");
	return retStr;
}

string p3_60::getCurrentState() { return name; }

list<string> p3_60::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_60::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_60::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_60"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_60", NO_ENABLED_GUARDS));
	}
}

bool p3_60::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_60::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_60::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_60_3398891
void p3_60::V2_outTRp3_60_3398891(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_60_3398891 -> Going From p3_60 to p3_61"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_60 => p3_61");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_60_3398891");
								smc->event_status_msg.push_back(" <!> State Update: p3_60 => p3_61");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_60_3398891"<<std::endl;
							std::cout<<" <!> State Update: p3_60 => p3_61"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_61());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_60");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_60_3398891
std::vector<int> p3_60::match_V2_outTRp3_60_3398891(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_60_3398891");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_60");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_60_3398891
void p3_60::V2_outTRp3_60_3398891(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_60_3398891 -> Going From p3_60 to p3_61"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_60 => p3_61");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_60_3398891");
							smc->event_status_msg.push_back(" <!> State Update: p3_60 => p3_61");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_60_3398891"<<std::endl;
						std::cout<<" <!> State Update: p3_60 => p3_61"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_61());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_60");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_60::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_60_3398891");
					smc->event_status_msg.push_back(" <!> State Update: p3_60 => p3_61");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_60_3398891"<<std::endl;
					std::cout<<" <!> State Update: p3_60 => p3_61"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_60_3398891();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_60_3398891");
					if(smc->m_outTRp3_60_3398891_Handler != nullptr)
					{
						smc->m_outTRp3_60_3398891_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_60 => p3_61");
					smc->setCurrent(new p3_61());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_60");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_60!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_47 ***********/

list<string> p3_47::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_47::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_47::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_4_3398731");
	return retStr;
}

string p3_47::getCurrentState() { return name; }

list<string> p3_47::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_47::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_47::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_47"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_47", NO_ENABLED_GUARDS));
	}
}

bool p3_47::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_47::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_47::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_4_3398731
void p3_47::V2_outTRp3_4_3398731(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_4_3398731 -> Going From p3_47 to p3_48"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_47 => p3_48");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_4_3398731");
								smc->event_status_msg.push_back(" <!> State Update: p3_47 => p3_48");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_4_3398731"<<std::endl;
							std::cout<<" <!> State Update: p3_47 => p3_48"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_48());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_47");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_4_3398731
std::vector<int> p3_47::match_V2_outTRp3_4_3398731(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_4_3398731");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_47");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_4_3398731
void p3_47::V2_outTRp3_4_3398731(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_4_3398731 -> Going From p3_47 to p3_48"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_47 => p3_48");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_4_3398731");
							smc->event_status_msg.push_back(" <!> State Update: p3_47 => p3_48");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_4_3398731"<<std::endl;
						std::cout<<" <!> State Update: p3_47 => p3_48"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_48());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_47");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_47::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_4_3398731");
					smc->event_status_msg.push_back(" <!> State Update: p3_47 => p3_48");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_4_3398731"<<std::endl;
					std::cout<<" <!> State Update: p3_47 => p3_48"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_4_3398731();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_4_3398731");
					if(smc->m_outTRp3_4_3398731_Handler != nullptr)
					{
						smc->m_outTRp3_4_3398731_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_47 => p3_48");
					smc->setCurrent(new p3_48());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_47");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_47!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_41 ***********/

list<string> p3_41::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_41::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_8_3398752");
	return retStr;
}
		
list<string> p3_41::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_41::getCurrentState() { return name; }

list<string> p3_41::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_41::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_8_3398752
	{
	list_of_enabled_signals.push_back("V2_inTRp3_8_3398752");
	}
	return list_of_enabled_signals;
}

void p3_41::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_8_3398752"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_8_3398752();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_8_3398752( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_8_3398752( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_8_3398752"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_8_3398752" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_8_3398752(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_8_3398752" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_8_3398752( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_8_3398752 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_8_3398752(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_8_3398752(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_8_3398752(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_8_3398752 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_8_3398752 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_8_3398752" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_8_3398752( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_8_3398752 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_41"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_41", NO_ENABLED_GUARDS));
	}
}

bool p3_41::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_41::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_41::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_8_3398752
bool p3_41::isEnabledV2_inTRp3_8_3398752(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_8_3398752
std::vector<int> p3_41::V2_inTRp3_8_3398752(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_8_3398752");
							smc->event_status_msg.push_back(" <!> State Update: p3_41 => p3_42");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_8_3398752"<<std::endl;
							// std::cout<<" <!> State Update: From p3_41 => p3_42"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_41 => p3_42");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_8_3398752 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_41");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_41!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_8_3398752
void p3_41::V2_inTRp3_8_3398752(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_8_3398752");
							smc->event_status_msg.push_back(" <!> State Update: p3_41 => p3_42");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_8_3398752"<<std::endl;
							std::cout<<" <!> State Update: From p3_41 => p3_42"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_41 => p3_42");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_42());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_8_3398752 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_41");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_41!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_8_3398752
void p3_41::V2_inTRp3_8_3398752(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_8_3398752");
				smc->event_status_msg.push_back(" <!> State Update: p3_41 => p3_42");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_8_3398752"<<std::endl;
				std::cout<<" <!> State Update: From p3_41 => p3_42"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_41 => p3_42");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_42());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_8_3398752 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_41");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_41!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_38 ***********/

list<string> p3_38::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_38::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_38::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_11_3398764");
	return retStr;
}

string p3_38::getCurrentState() { return name; }

list<string> p3_38::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_38::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_38::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_38"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_38", NO_ENABLED_GUARDS));
	}
}

bool p3_38::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_38::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_38::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_11_3398764
void p3_38::V2_outTRp3_11_3398764(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_11_3398764 -> Going From p3_38 to p3_39"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_38 => p3_39");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_11_3398764");
								smc->event_status_msg.push_back(" <!> State Update: p3_38 => p3_39");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_11_3398764"<<std::endl;
							std::cout<<" <!> State Update: p3_38 => p3_39"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_39());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_38");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_11_3398764
std::vector<int> p3_38::match_V2_outTRp3_11_3398764(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_11_3398764");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_38");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_11_3398764
void p3_38::V2_outTRp3_11_3398764(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_11_3398764 -> Going From p3_38 to p3_39"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_38 => p3_39");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_11_3398764");
							smc->event_status_msg.push_back(" <!> State Update: p3_38 => p3_39");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_11_3398764"<<std::endl;
						std::cout<<" <!> State Update: p3_38 => p3_39"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_39());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_38");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_38::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_11_3398764");
					smc->event_status_msg.push_back(" <!> State Update: p3_38 => p3_39");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_11_3398764"<<std::endl;
					std::cout<<" <!> State Update: p3_38 => p3_39"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_11_3398764();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_11_3398764");
					if(smc->m_outTRp3_11_3398764_Handler != nullptr)
					{
						smc->m_outTRp3_11_3398764_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_38 => p3_39");
					smc->setCurrent(new p3_39());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_38");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_38!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_34 ***********/

list<string> p3_34::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_34::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_5_3398749");
	return retStr;
}
		
list<string> p3_34::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_34::getCurrentState() { return name; }

list<string> p3_34::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_34::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_5_3398749
	{
	list_of_enabled_signals.push_back("V2_inTRp3_5_3398749");
	}
	return list_of_enabled_signals;
}

void p3_34::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_5_3398749"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_5_3398749();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_5_3398749( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_5_3398749( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_5_3398749"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_5_3398749" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_5_3398749(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_5_3398749" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_5_3398749( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_5_3398749 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_5_3398749(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_5_3398749(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_5_3398749(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_5_3398749 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_5_3398749 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_5_3398749" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_5_3398749( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_5_3398749 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_34"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_34", NO_ENABLED_GUARDS));
	}
}

bool p3_34::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_34::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_34::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_5_3398749
bool p3_34::isEnabledV2_inTRp3_5_3398749(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_5_3398749
std::vector<int> p3_34::V2_inTRp3_5_3398749(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_5_3398749");
							smc->event_status_msg.push_back(" <!> State Update: p3_34 => p3_35");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_5_3398749"<<std::endl;
							// std::cout<<" <!> State Update: From p3_34 => p3_35"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_34 => p3_35");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_5_3398749 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_34");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_34!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_5_3398749
void p3_34::V2_inTRp3_5_3398749(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_5_3398749");
							smc->event_status_msg.push_back(" <!> State Update: p3_34 => p3_35");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_5_3398749"<<std::endl;
							std::cout<<" <!> State Update: From p3_34 => p3_35"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_34 => p3_35");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_35());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_5_3398749 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_34");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_34!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_5_3398749
void p3_34::V2_inTRp3_5_3398749(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_5_3398749");
				smc->event_status_msg.push_back(" <!> State Update: p3_34 => p3_35");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_5_3398749"<<std::endl;
				std::cout<<" <!> State Update: From p3_34 => p3_35"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_34 => p3_35");
				smc->setTextColor("ANY");
				smc->setCurrent(new p3_35());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_5_3398749 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_34");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_34!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_31 ***********/

list<string> p3_31::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_31::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_31::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_12_3398771");
	return retStr;
}

string p3_31::getCurrentState() { return name; }

list<string> p3_31::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_31::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_31::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_31"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_31", NO_ENABLED_GUARDS));
	}
}

bool p3_31::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_31::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_31::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_12_3398771
void p3_31::V2_outTRp3_12_3398771(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_12_3398771 -> Going From p3_31 to p3_32"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_31 => p3_32");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_12_3398771");
								smc->event_status_msg.push_back(" <!> State Update: p3_31 => p3_32");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_12_3398771"<<std::endl;
							std::cout<<" <!> State Update: p3_31 => p3_32"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_32());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_31");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_12_3398771
std::vector<int> p3_31::match_V2_outTRp3_12_3398771(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_12_3398771");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_31");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_12_3398771
void p3_31::V2_outTRp3_12_3398771(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_12_3398771 -> Going From p3_31 to p3_32"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_31 => p3_32");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_12_3398771");
							smc->event_status_msg.push_back(" <!> State Update: p3_31 => p3_32");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_12_3398771"<<std::endl;
						std::cout<<" <!> State Update: p3_31 => p3_32"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_32());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_31");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_31::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_12_3398771");
					smc->event_status_msg.push_back(" <!> State Update: p3_31 => p3_32");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_12_3398771"<<std::endl;
					std::cout<<" <!> State Update: p3_31 => p3_32"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_12_3398771();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_12_3398771");
					if(smc->m_outTRp3_12_3398771_Handler != nullptr)
					{
						smc->m_outTRp3_12_3398771_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_31 => p3_32");
					smc->setCurrent(new p3_32());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_31");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_31!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_19 ***********/

list<string> p3_19::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_19::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_12_3398786");
	retStr.push_back("V2_inTRp3_12_3398787");
	return retStr;
}
		
list<string> p3_19::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_19::getCurrentState() { return name; }

list<string> p3_19::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_19::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_12_3398786
	{
	list_of_enabled_signals.push_back("V2_inTRp3_12_3398786");
	}
	// Signal Name: V2_inTRp3_12_3398787
	{
	list_of_enabled_signals.push_back("V2_inTRp3_12_3398787");
	}
	return list_of_enabled_signals;
}

void p3_19::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_12_3398786"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_12_3398786();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_12_3398786( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_12_3398786( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		if(!(*it).compare("V2_inTRp3_12_3398787"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_12_3398787();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_12_3398787( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_12_3398787( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_12_3398786"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_12_3398786" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_12_3398786(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_12_3398786" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_12_3398786( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_12_3398786 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_12_3398786(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_12_3398786(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_12_3398786(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_12_3398786 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_12_3398786 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_12_3398786" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_12_3398786( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_12_3398786 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		if(!(*it).compare("V2_inTRp3_12_3398787"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_12_3398787" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_12_3398787(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_12_3398787" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_12_3398787( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_12_3398787 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_12_3398787(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_12_3398787(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_12_3398787(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_12_3398787 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_12_3398787 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_12_3398787" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_12_3398787( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_12_3398787 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_19"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_19", NO_ENABLED_GUARDS));
	}
}

bool p3_19::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_19::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_19::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_12_3398786
bool p3_19::isEnabledV2_inTRp3_12_3398786(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Enabling Test for Signal: V2_inTRp3_12_3398787
bool p3_19::isEnabledV2_inTRp3_12_3398787(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_12_3398786
std::vector<int> p3_19::V2_inTRp3_12_3398786(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_12_3398786");
							smc->event_status_msg.push_back(" <!> State Update: p3_19 => p8_1");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_12_3398786"<<std::endl;
							// std::cout<<" <!> State Update: From p3_19 => p8_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_19 => p8_1");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_12_3398786 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Signal Context NI Validator: V2_inTRp3_12_3398787
std::vector<int> p3_19::V2_inTRp3_12_3398787(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_12_3398787");
							smc->event_status_msg.push_back(" <!> State Update: p3_19 => p9_1");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_12_3398787"<<std::endl;
							// std::cout<<" <!> State Update: From p3_19 => p9_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_19 => p9_1");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_12_3398787 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_12_3398786
void p3_19::V2_inTRp3_12_3398786(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_12_3398786");
							smc->event_status_msg.push_back(" <!> State Update: p3_19 => p8_1");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_12_3398786"<<std::endl;
							std::cout<<" <!> State Update: From p3_19 => p8_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_19 => p8_1");
							smc->setTextColor("ANY");
							smc->setCurrent(new p8_1());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_12_3398786 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Deterministic Signal Handler: V2_inTRp3_12_3398787
void p3_19::V2_inTRp3_12_3398787(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_12_3398787");
							smc->event_status_msg.push_back(" <!> State Update: p3_19 => p9_1");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_12_3398787"<<std::endl;
							std::cout<<" <!> State Update: From p3_19 => p9_1"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_19 => p9_1");
							smc->setTextColor("ANY");
							smc->setCurrent(new p9_1());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_12_3398787 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_12_3398786
void p3_19::V2_inTRp3_12_3398786(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_12_3398786");
				smc->event_status_msg.push_back(" <!> State Update: p3_19 => p8_1");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_12_3398786"<<std::endl;
				std::cout<<" <!> State Update: From p3_19 => p8_1"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_19 => p8_1");
				smc->setTextColor("ANY");
				smc->setCurrent(new p8_1());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_12_3398786 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_12_3398787
void p3_19::V2_inTRp3_12_3398787(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_12_3398787");
				smc->event_status_msg.push_back(" <!> State Update: p3_19 => p9_1");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_12_3398787"<<std::endl;
				std::cout<<" <!> State Update: From p3_19 => p9_1"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_19 => p9_1");
				smc->setTextColor("ANY");
				smc->setCurrent(new p9_1());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_12_3398787 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_19!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_63 ***********/

list<string> p3_63::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_63::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_63::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_62_3398893");
	return retStr;
}

string p3_63::getCurrentState() { return name; }

list<string> p3_63::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_63::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_63::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_63"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_63", NO_ENABLED_GUARDS));
	}
}

bool p3_63::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_63::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_63::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_62_3398893
void p3_63::V2_outTRp3_62_3398893(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_62_3398893 -> Going From p3_63 to p3_64"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_63 => p3_64");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_62_3398893");
								smc->event_status_msg.push_back(" <!> State Update: p3_63 => p3_64");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_62_3398893"<<std::endl;
							std::cout<<" <!> State Update: p3_63 => p3_64"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_64());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_63");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_62_3398893
std::vector<int> p3_63::match_V2_outTRp3_62_3398893(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_62_3398893");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_63");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_62_3398893
void p3_63::V2_outTRp3_62_3398893(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_62_3398893 -> Going From p3_63 to p3_64"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_63 => p3_64");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_62_3398893");
							smc->event_status_msg.push_back(" <!> State Update: p3_63 => p3_64");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_62_3398893"<<std::endl;
						std::cout<<" <!> State Update: p3_63 => p3_64"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_64());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_63");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_63::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_62_3398893");
					smc->event_status_msg.push_back(" <!> State Update: p3_63 => p3_64");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_62_3398893"<<std::endl;
					std::cout<<" <!> State Update: p3_63 => p3_64"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_62_3398893();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_62_3398893");
					if(smc->m_outTRp3_62_3398893_Handler != nullptr)
					{
						smc->m_outTRp3_62_3398893_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_63 => p3_64");
					smc->setCurrent(new p3_64());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_63");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_63!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_67 ***********/

list<string> p3_67::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_67::getCurrentSignalStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_inTRp3_1_3398722");
	return retStr;
}
		
list<string> p3_67::getCurrentNotificationStatusList()
{
	list<string> retStr;
	return retStr;
}

string p3_67::getCurrentState() { return name; }

list<string> p3_67::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_67::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	// Signal Name: V2_inTRp3_1_3398722
	{
	list_of_enabled_signals.push_back("V2_inTRp3_1_3398722");
	}
	return list_of_enabled_signals;
}

void p3_67::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		if(!(*it).compare("V2_inTRp3_1_3398722"))
		{
			// #1. Call the interface function
			smc->client_api_handler->openEventContext();
			smc->client_api_handler->inTRp3_1_3398722();

			// #1a. Get the list of received notification and close the context.
			std::vector<string> list_of_rcvd_notifications = smc->client_api_handler->getListOfReceivedNotifications();
			//smc->client_api_handler->closeEventContext();
			std::cout << "[INFO] Number of Notifications Received in Context: " << list_of_rcvd_notifications.size() << std::endl;
			
			vector<int> instance_clause_id = V2_inTRp3_1_3398722( smc, list_of_rcvd_notifications);
			std::cout << std::endl << "Notifications List matched to Instance ID: " << instance_clause_id.at(0) << " and Clause ID: " << instance_clause_id.at(1) << std::endl;

			// #3. Call the the signal method
			V2_inTRp3_1_3398722( smc, instance_clause_id.at(0), instance_clause_id.at(1));
			smc->client_api_handler->closeEventContext();
		}
		#endif
		
		#ifndef CLIENT_STUB_API
		if(!(*it).compare("V2_inTRp3_1_3398722"))
		{
			
			std::cout << "Checking Instance-Clause Preferences for Signal: inTRp3_1_3398722" << std::endl;
			std::vector<int> instance_clause_id = smc->c.getInstanceClauseIDofinTRp3_1_3398722(smc->getCurrentState(), false);
			if (instance_clause_id.at(0) == UNDEFINED_CHOICE || instance_clause_id.at(1) == UNDEFINED_CHOICE)
			{
				// Call the function with Parameters Only
				std::cout << "No preferences found for Signal: inTRp3_1_3398722" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_1_3398722( smc);
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_1_3398722 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
			else
			{
				std::vector<int> list_of_instance_id = smc->c.getListOfInstanceIDofinTRp3_1_3398722(smc->getCurrentState(), false);
				bool isAtleastOneInstanceEnabled = false;
				for (unsigned int i = 0; i < list_of_instance_id.size(); i++)
				{
					if (isEnabledV2_inTRp3_1_3398722(smc, list_of_instance_id.at(i)))
					{
						instance_clause_id.at(0) = list_of_instance_id.at(i);
						std::vector<int> list_of_clause_id = smc->c.getListOfClauseIDofinTRp3_1_3398722(smc->getCurrentState(), list_of_instance_id.at(i), false);
						instance_clause_id.at(1) = list_of_clause_id.at(rand() % list_of_clause_id.size());
						isAtleastOneInstanceEnabled = true;
					}
				}
				if(!isAtleastOneInstanceEnabled)
				{
					std::cout << "EXCEPTION: None of the instances of command: inTRp3_1_3398722 specified in the input file are enabled. Check the parameter set, if any!" << std::endl;
					//throw (StateMachineController::StubException("EXCEPTION: None of the instances of command: inTRp3_1_3398722 specified in the input file are enabled. Check the parameter set, if any!", NO_ENABLED_GUARDS));
				}
					
				// Call function with Parameters and Instance-Clause ID
				std::cout << "Instance-Clause ID ["<< instance_clause_id.at(0) <<":"<< instance_clause_id.at(1) <<"] found for Command: inTRp3_1_3398722" << std::endl;
				
				// Call the function with Parameters
				V2_inTRp3_1_3398722( smc, instance_clause_id.at(0), instance_clause_id.at(1));
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Command inTRp3_1_3398722 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
			}
		}
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_67"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_67", NO_ENABLED_GUARDS));
	}
}

bool p3_67::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_67::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_67::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	UNREF_PARAM(smc);
	// Means there is no notification?
	return false;
}

// Enabling Test for Signal: V2_inTRp3_1_3398722
bool p3_67::isEnabledV2_inTRp3_1_3398722(V2_StateMachineController *smc, int instance_choice)
{
	// Switch Block for Signal Instances
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					return true;
				} // End of Guarded Block
				else
				{
					return false;
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid Random Choice of Transition Instance [Enabling]"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid Random Choice of Transition Instance [Enabling]!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block

	return false;
}
// Concrete Signal Context NI Validator: V2_inTRp3_1_3398722
std::vector<int> p3_67::V2_inTRp3_1_3398722(V2_StateMachineController *smc, std::vector<std::string> list_of_rcvd_notifications)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	std::vector<int> instance_clause_id;
	std::vector<std::string> observed_notifications;

	// Switch Block for Signal Instances
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					for(int choice = 0; choice < 1; choice++)
					{
					const StateMachineController::V2_StateMachineController& smcRef = *smc;
					StateMachineController::smVarContainer var_copy(smcRef);
					switch(choice)
					{
					case 0: // Signal Clause
							{
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_1_3398722");
							smc->event_status_msg.push_back(" <!> State Update: p3_67 => p1_35");
							#endif
							// std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_1_3398722"<<std::endl;
							// std::cout<<" <!> State Update: From p3_67 => p1_35"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_67 => p1_35");
							smc->setTextColor("ANY");
							bool is_equal = false;
							if (observed_notifications.size() == list_of_rcvd_notifications.size())
								is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
							if (is_equal) { instance_clause_id.push_back(0); instance_clause_id.push_back(0); return instance_clause_id; }
							else { observed_notifications.clear(); }
							smc->setTextColor("EVENT");
							// std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_1_3398722 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
							}
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of Signal Clause"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of Signal Clause!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
					} // End of Clause For-Loop
				} // End of Guarded Block
				else {
					//smc->setTextColor("EVENT");
					//std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					//smc->setTextColor("ANY");
					////throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of Transition Instance"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of Transition Instance!", LOGICAL_ERROR));
				 break;
	} // End of Switch Block
	} // End of Instance For-Loop
	
	// To reach here means either none of the guards were true, or the reply did not match!
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_67");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_67!", NO_ENABLED_GUARDS));
		
	}
	else 
	{
		smc->setTextColor("EVENT");
		std::cout << "FATAL: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!" << std::endl;
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: THE RECEIVED NOTIFICATIONS IN CONTEXT OF SIGNAL COULD NOT BE MATCHED!", LOGICAL_ERROR));
	}
	// UNREACHABLE CODE. To be removed..
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	instance_clause_id.push_back(UNDEFINED_CHOICE);
	return instance_clause_id;
}
// Concrete Deterministic Signal Handler: V2_inTRp3_1_3398722
void p3_67::V2_inTRp3_1_3398722(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;

	// Switch Block for Signal Clauses
	int instance_choice = instance_id; //rand() %1;
	switch(instance_choice)
	{
		case 0: //Signal Instance
				// Guard Expression
				if(true)
				{
					isAtleastOneGuardEnabled = true;
					isAtleastOneInstanceExecuted = true;
					// Switch Block for Signal Clauses
					int choice = clause_id; //rand() %1;
					switch(choice)
					{
					case 0: // Signal Clause
							smc->setTextColor("EVENT");
							#ifdef QT_GUI
							smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_1_3398722");
							smc->event_status_msg.push_back(" <!> State Update: p3_67 => p1_35");
							#endif
							std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_1_3398722"<<std::endl;
							std::cout<<" <!> State Update: From p3_67 => p1_35"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_67 => p1_35");
							smc->setTextColor("ANY");
							smc->setCurrent(new p1_35());
							delete this;
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_1_3398722 has been Executed!"<<std::endl;
							smc->setTextColor("ANY");
							break;
					default: smc->setTextColor("EVENT");
							 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
							 smc->setTextColor("ANY");
							 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
							 break;
					} // End of Switch Block
				} // End of Guarded Block
				else {
					smc->setTextColor("EVENT");
					std::cout<<"FATAL: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!"<<std::endl;
					smc->setTextColor("ANY");
					//throw (StubException("EXCEPTION: Choice of Signal Transition Instance and Clause in a Deterministic Context has Disabled Guards!", INPUT_PARAMS_ERROR));
				}
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
	}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_67");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_67!", NO_ENABLED_GUARDS));
		
	}
}
// Concrete Signal Handler: V2_inTRp3_1_3398722
void p3_67::V2_inTRp3_1_3398722(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	// Guard Expression
	if(true && !isAtleastOneInstanceExecuted)
	{
		isAtleastOneGuardEnabled = true;
		isAtleastOneInstanceExecuted = true;
		// Switch Block for Signal Clauses
		int choice = rand() %1;
		switch(choice)
		{
		case 0: // Signal Clause
				smc->setTextColor("EVENT");
				#ifdef QT_GUI
				smc->event_status_msg.push_back(" >>>>>>>> Received Signal: inTRp3_1_3398722");
				smc->event_status_msg.push_back(" <!> State Update: p3_67 => p1_35");
				#endif
				std::cout<<std::endl<<" >>>>>>>> Received Signal: inTRp3_1_3398722"<<std::endl;
				std::cout<<" <!> State Update: From p3_67 => p1_35"<<std::endl;
				// smc->event_status_msg.push_back("State Changed: p3_67 => p1_35");
				smc->setTextColor("ANY");
				smc->setCurrent(new p1_35());
				delete this;
				smc->setTextColor("EVENT");
				std::cout<<std::endl<<" <<<<<<<< Signal inTRp3_1_3398722 has been Executed!"<<std::endl;
				smc->setTextColor("ANY");
				break;
		default: smc->setTextColor("EVENT");
				 std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
				 smc->setTextColor("ANY");
				 //throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
				 break;
		} // End of Switch Block
	} // End of Guarded Block
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_67");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS FOR THIS SIGNAL ARE ENABLED in STATE: p3_67!", NO_ENABLED_GUARDS));
		
	}
}




/*********** Concrete State Class: p3_61 ***********/

list<string> p3_61::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_61::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_61::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_61_3398894");
	return retStr;
}

string p3_61::getCurrentState() { return name; }

list<string> p3_61::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_61::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_61::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_61"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_61", NO_ENABLED_GUARDS));
	}
}

bool p3_61::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_61::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_61::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_61_3398894
void p3_61::V2_outTRp3_61_3398894(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_61_3398894 -> Going From p3_61 to p3_62"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_61 => p3_62");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_61_3398894");
								smc->event_status_msg.push_back(" <!> State Update: p3_61 => p3_62");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_61_3398894"<<std::endl;
							std::cout<<" <!> State Update: p3_61 => p3_62"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_62());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_61");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_61_3398894
std::vector<int> p3_61::match_V2_outTRp3_61_3398894(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_61_3398894");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_61");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_61_3398894
void p3_61::V2_outTRp3_61_3398894(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_61_3398894 -> Going From p3_61 to p3_62"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_61 => p3_62");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_61_3398894");
							smc->event_status_msg.push_back(" <!> State Update: p3_61 => p3_62");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_61_3398894"<<std::endl;
						std::cout<<" <!> State Update: p3_61 => p3_62"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_62());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_61");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_61::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_61_3398894");
					smc->event_status_msg.push_back(" <!> State Update: p3_61 => p3_62");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_61_3398894"<<std::endl;
					std::cout<<" <!> State Update: p3_61 => p3_62"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_61_3398894();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_61_3398894");
					if(smc->m_outTRp3_61_3398894_Handler != nullptr)
					{
						smc->m_outTRp3_61_3398894_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_61 => p3_62");
					smc->setCurrent(new p3_62());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_61");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_61!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_65 ***********/

list<string> p3_65::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_65::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_65::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_52_3398880");
	return retStr;
}

string p3_65::getCurrentState() { return name; }

list<string> p3_65::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_65::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_65::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_65"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_65", NO_ENABLED_GUARDS));
	}
}

bool p3_65::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_65::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_65::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_52_3398880
void p3_65::V2_outTRp3_52_3398880(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_52_3398880 -> Going From p3_65 to p3_66"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_65 => p3_66");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_52_3398880");
								smc->event_status_msg.push_back(" <!> State Update: p3_65 => p3_66");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_52_3398880"<<std::endl;
							std::cout<<" <!> State Update: p3_65 => p3_66"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_66());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_65");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_52_3398880
std::vector<int> p3_65::match_V2_outTRp3_52_3398880(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_52_3398880");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_65");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_52_3398880
void p3_65::V2_outTRp3_52_3398880(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_52_3398880 -> Going From p3_65 to p3_66"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_65 => p3_66");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_52_3398880");
							smc->event_status_msg.push_back(" <!> State Update: p3_65 => p3_66");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_52_3398880"<<std::endl;
						std::cout<<" <!> State Update: p3_65 => p3_66"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_66());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_65");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_65::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_52_3398880");
					smc->event_status_msg.push_back(" <!> State Update: p3_65 => p3_66");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_52_3398880"<<std::endl;
					std::cout<<" <!> State Update: p3_65 => p3_66"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_52_3398880();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_52_3398880");
					if(smc->m_outTRp3_52_3398880_Handler != nullptr)
					{
						smc->m_outTRp3_52_3398880_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_65 => p3_66");
					smc->setCurrent(new p3_66());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_65");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_65!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_64 ***********/

list<string> p3_64::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_64::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_64::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_62_3398892");
	return retStr;
}

string p3_64::getCurrentState() { return name; }

list<string> p3_64::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_64::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_64::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_64"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_64", NO_ENABLED_GUARDS));
	}
}

bool p3_64::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_64::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_64::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_62_3398892
void p3_64::V2_outTRp3_62_3398892(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_62_3398892 -> Going From p3_64 to p3_65"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_64 => p3_65");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_62_3398892");
								smc->event_status_msg.push_back(" <!> State Update: p3_64 => p3_65");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_62_3398892"<<std::endl;
							std::cout<<" <!> State Update: p3_64 => p3_65"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_65());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_64");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_62_3398892
std::vector<int> p3_64::match_V2_outTRp3_62_3398892(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_62_3398892");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_64");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_62_3398892
void p3_64::V2_outTRp3_62_3398892(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_62_3398892 -> Going From p3_64 to p3_65"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_64 => p3_65");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_62_3398892");
							smc->event_status_msg.push_back(" <!> State Update: p3_64 => p3_65");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_62_3398892"<<std::endl;
						std::cout<<" <!> State Update: p3_64 => p3_65"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_65());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_64");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_64::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_62_3398892");
					smc->event_status_msg.push_back(" <!> State Update: p3_64 => p3_65");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_62_3398892"<<std::endl;
					std::cout<<" <!> State Update: p3_64 => p3_65"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_62_3398892();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_62_3398892");
					if(smc->m_outTRp3_62_3398892_Handler != nullptr)
					{
						smc->m_outTRp3_62_3398892_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_64 => p3_65");
					smc->setCurrent(new p3_65());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_64");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_64!", NO_ENABLED_GUARDS));
	}
}



/*********** Concrete State Class: p3_62 ***********/

list<string> p3_62::getCurrentCommandStatusList() 
{
	list<string> retStr;
	return retStr;
}

list<string> p3_62::getCurrentSignalStatusList()
{
	list<string> retStr;
	return retStr;
}
		
list<string> p3_62::getCurrentNotificationStatusList()
{
	list<string> retStr;
	retStr.push_back("V2_outTRp3_60_3398889");
	return retStr;
}

string p3_62::getCurrentState() { return name; }

list<string> p3_62::isAtleastOneEnabledCommand(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_commands;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_commands;
}
list<string> p3_62::isAtleastOneEnabledSignal(V2_StateMachineController *smc)
{
	list<string> list_of_enabled_signals;
	//StateMachineController::InputParametersContainer c;
	return list_of_enabled_signals;
}

void p3_62::executeAvailableCommandsAndSignalsInState(V2_StateMachineController *smc)
{
	//StateMachineController::InputParametersContainer c;
	list<string> list_of_enabled_commands_and_signals = determineEnabledCommandAndSignalInState(smc);
	if(checkEnabledCommandAndSignalInState(smc))
	{
		std::list<string>::iterator it = list_of_enabled_commands_and_signals.begin();
		
		// Choose a random element from the list
		std::advance(it, rand() %list_of_enabled_commands_and_signals.size());

		// TODO: Do not match reply(*). Find out how to do this.
		#ifdef CLIENT_STUB_API

		#endif
		
		#ifndef CLIENT_STUB_API
		#endif
	}
	else
	{
		std::cout<<std::endl<<"ERROR: No Enabled Commands or Signals in State: p3_62"<<std::endl;
		//throw (StubException("EXCEPTION: No Enabled Commands or Signals in State: p3_62", NO_ENABLED_GUARDS));
	}
}

bool p3_62::checkEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	if(determineEnabledCommandAndSignalInState(smc).empty())
			return false;
		else
			return true;
}

list<string> p3_62::determineEnabledCommandAndSignalInState(V2_StateMachineController *smc)
{
	list<string> enabled_commands_and_signals_list = isAtleastOneEnabledCommand(smc);
	enabled_commands_and_signals_list.splice(enabled_commands_and_signals_list.end(), isAtleastOneEnabledSignal(smc));
	return enabled_commands_and_signals_list;
}


bool p3_62::isAtleastOneEnabledNotification(V2_StateMachineController *smc)
{
	if( true )
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Concrete Deterministic Notification Handler: V2_outTRp3_60_3398889
void p3_62::V2_outTRp3_60_3398889(V2_StateMachineController *smc, int instance_id, int clause_id)
{
	bool isAtleastOneGuardEnabled = false;
	int instance_choice = instance_id;
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				int clause_choice = clause_id;
					switch(clause_choice)
					{
					case 0:
							{
							// std::cout<<"Raising Notification: V2_outTRp3_60_3398889 -> Going From p3_62 to p3_63"<<std::endl;
							// smc->event_status_msg.push_back("State Changed: p3_62 => p3_63");
							#ifdef QT_GUI
								smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_60_3398889");
								smc->event_status_msg.push_back(" <!> State Update: p3_62 => p3_63");
							#endif
							smc->setTextColor("EVENT");
							std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_60_3398889"<<std::endl;
							std::cout<<" <!> State Update: p3_62 => p3_63"<<std::endl;
							smc->setTextColor("DATA");
							smc->setTextColor("ANY");
							smc->setCurrent(new p3_63());
							delete this;
							break;
							}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance!"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_62");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}
// Concrete Notification Validator: V2_outTRp3_60_3398889
std::vector<int> p3_62::match_V2_outTRp3_60_3398889(V2_StateMachineController *smc, std::vector<std::string>  list_of_rcvd_notifications)
{
	std::vector<std::string> observed_notifications;
	std::vector<int> matched_instance_clause_id;
	bool is_equal = false;
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
	
	for(int instance_choice = 0; instance_choice < 1; instance_choice++)
	{
	switch(instance_choice)
	{
		case 0: 
			// Guard Expression
			if(true)
			{
				isAtleastOneGuardEnabled = true;
				isAtleastOneInstanceExecuted = true;
				
				for(int clause_choice = 0; clause_choice < 1; clause_choice++)
				{
					switch(clause_choice)
					{
					case 0:	{
									const StateMachineController::V2_StateMachineController& smcRef = *smc;
									StateMachineController::smVarContainer var_copy(smcRef);
									observed_notifications.push_back("V2_outTRp3_60_3398889");
									bool is_equal = false;
									if (observed_notifications.size() == list_of_rcvd_notifications.size())
										is_equal = std::equal(observed_notifications.begin(), observed_notifications.end(), list_of_rcvd_notifications.begin());
									if (is_equal) { matched_instance_clause_id.push_back(0); matched_instance_clause_id.push_back(0); return matched_instance_clause_id; }
									else { observed_notifications.clear(); }		
									break;
								}
					default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause"<<std::endl;
								//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
								break;
					}// End of clause switch-case
				}// End of clause selector for-loop
			}
			break;
		default: 	std::cout<<"ERROR: Invalid random choice of Notification Instance"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of Notification Instance!", LOGICAL_ERROR));
					break;
	}// End of instance switch-case
	}// End of instance selector for-loop
	
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_62");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
	
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	matched_instance_clause_id.push_back(UNDEFINED_CHOICE); 
	return matched_instance_clause_id;
}
// Concrete Notification Handler: V2_outTRp3_60_3398889
void p3_62::V2_outTRp3_60_3398889(V2_StateMachineController *smc)
{
	bool isAtleastOneGuardEnabled = true;
	bool isAtleastOneInstanceExecuted = false;
		// Guard Expression
		if(true && !isAtleastOneInstanceExecuted)
		{
			isAtleastOneGuardEnabled = true;
			isAtleastOneInstanceExecuted = true;
			int clause_choice = rand() %1;
			switch(clause_choice)
			{
			case 0:	{
						// std::cout<<"Raising Notification: V2_outTRp3_60_3398889 -> Going From p3_62 to p3_63"<<std::endl;
						// smc->event_status_msg.push_back("State Changed: p3_62 => p3_63");
						#ifdef QT_GUI
							smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_60_3398889");
							smc->event_status_msg.push_back(" <!> State Update: p3_62 => p3_63");
						#endif
						smc->setTextColor("EVENT");
						std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_60_3398889"<<std::endl;
						std::cout<<" <!> State Update: p3_62 => p3_63"<<std::endl;
						smc->setTextColor("DATA");
						smc->setTextColor("ANY");
						smc->setCurrent(new p3_63());
						delete this;
						return;
			}
			default: 	std::cout<<"ERROR: Invalid random choice of Notification Clause!"<<std::endl;
						//throw (StubException("EXCEPTION: Invalid random choice of Notification Clause!", LOGICAL_ERROR));
						break;
			}// End of clause switch-case
		}
	if(!isAtleastOneGuardEnabled)
	{
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NO GUARDS OF THIS NOTIFICATION ARE ENABLED in STATE: p3_62");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NO GUARDS OF THIS NOTIFICATION ARE ENABLED!", NO_ENABLED_GUARDS));
	}
}

void p3_62::executeInternalTransitions(V2_StateMachineController *smc)
{
	bool found_enabled_notification = false;
	if( true )
	{
	while(!found_enabled_notification)
	{
	int choice = rand() %1; //%END;
	switch(choice)
	{
		case 0:
					found_enabled_notification = true;
					// found_enabled_notification = true;
					#ifdef QT_GUI
					smc->event_status_msg.push_back(" <<<<<<<< Notification Raised: V2_outTRp3_60_3398889");
					smc->event_status_msg.push_back(" <!> State Update: p3_62 => p3_63");
					#endif
					smc->setTextColor("EVENT");
					std::cout<<std::endl<<" <<<<<<<< Notification Raised: V2_outTRp3_60_3398889"<<std::endl;
					std::cout<<" <!> State Update: p3_62 => p3_63"<<std::endl;
					smc->setTextColor("DATA");
					smc->setTextColor("ANY");
					// Note: For SSCF push the notification out here...
					#ifdef SSCF_VERSION
					
					smc->m_serverPtr->raiseNotification_outTRp3_60_3398889();
					#endif
					#ifndef SSCF_VERSION
					if(smc->m_niHandler != nullptr) smc->m_niHandler("V2_outTRp3_60_3398889");
					if(smc->m_outTRp3_60_3398889_Handler != nullptr)
					{
						smc->m_outTRp3_60_3398889_Handler();
					}
					#endif
					// smc->event_status_msg.push_back("State Changed: p3_62 => p3_63");
					smc->setCurrent(new p3_63());
					delete this;
					break;
		default: 	std::cout<<"ERROR: Invalid random choice of target state"<<std::endl;
					//throw (StubException("EXCEPTION: Invalid random choice of target state!", LOGICAL_ERROR));
					break;
	}
	}
	}
	else
	{
		// NO ENABLED GUARDS
		smc->setTextColor("EVENT");
		std::cout<<"ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED!"<<std::endl;
		smc->event_status_msg.push_back("ERROR: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_62");
		smc->setTextColor("ANY");
		//throw (StubException("EXCEPTION: NONE OF THE NOTIFICATION GUARDS ARE ENABLED in STATE: p3_62!", NO_ENABLED_GUARDS));
	}
}

}
